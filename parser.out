Grammar:

Rule 0     S' -> translation_unit
Rule 1     literal -> FLOAT
Rule 2     literal -> INTEGER
Rule 3     primary_expr -> ( expr )
Rule 4     primary_expr -> literal
Rule 5     primary_expr -> IDENTIFIER
Rule 6     postfix_expr -> postfix_expr DEC
Rule 7     postfix_expr -> postfix_expr INC
Rule 8     postfix_expr -> postfix_expr . IDENTIFIER
Rule 9     postfix_expr -> postfix_expr ( arg_expr_list )
Rule 10    postfix_expr -> postfix_expr ( )
Rule 11    postfix_expr -> postfix_expr [ expr ]
Rule 12    postfix_expr -> primary_expr
Rule 13    arg_expr_list -> arg_expr_list , expr
Rule 14    arg_expr_list -> expr
Rule 15    unary_expr -> ! cast_expr
Rule 16    unary_expr -> - cast_expr
Rule 17    unary_expr -> + cast_expr
Rule 18    unary_expr -> DEC unary_expr
Rule 19    unary_expr -> INC unary_expr
Rule 20    unary_expr -> postfix_expr
Rule 21    cast_expr -> unary_expr
Rule 22    cast_expr -> ( type ) cast_expr
Rule 23    mult_expr -> mult_expr % cast_expr
Rule 24    mult_expr -> mult_expr / cast_expr
Rule 25    mult_expr -> mult_expr * cast_expr
Rule 26    mult_expr -> cast_expr
Rule 27    add_expr -> add_expr - mult_expr
Rule 28    add_expr -> add_expr + mult_expr
Rule 29    add_expr -> mult_expr
Rule 30    rel_expr -> rel_expr LE add_expr
Rule 31    rel_expr -> rel_expr GE add_expr
Rule 32    rel_expr -> rel_expr < add_expr
Rule 33    rel_expr -> rel_expr > add_expr
Rule 34    rel_expr -> add_expr
Rule 35    eq_expr -> eq_expr NE rel_expr
Rule 36    eq_expr -> eq_expr EQ rel_expr
Rule 37    eq_expr -> rel_expr
Rule 38    and_expr -> and_expr AND eq_expr
Rule 39    and_expr -> eq_expr
Rule 40    cond_expr -> cond_expr OR and_expr
Rule 41    cond_expr -> and_expr
Rule 42    expr -> unary_expr assignment_op expr
Rule 43    expr -> cond_expr
Rule 44    assignment_op -> =
Rule 45    assignment_op -> MODEQ
Rule 46    assignment_op -> DIVEQ
Rule 47    assignment_op -> MULEQ
Rule 48    assignment_op -> MINUSEQ
Rule 49    assignment_op -> PLUSEQ
Rule 50    decl -> type init_declarator ;
Rule 51    init_declarator -> declarator = initializer
Rule 52    init_declarator -> declarator
Rule 53    type -> VOID
Rule 54    type -> STRING_T
Rule 55    type -> DOUBLE
Rule 56    type -> INT
Rule 57    declarator -> declarator [ ]
Rule 58    declarator -> declarator [ cond_expr ]
Rule 59    declarator -> declarator ( )
Rule 60    declarator -> declarator ( param_list )
Rule 61    declarator -> IDENTIFIER
Rule 62    param_list -> param_list , param_decl
Rule 63    param_list -> param_decl
Rule 64    param_decl -> type declarator
Rule 65    initializer -> { initializer_list }
Rule 66    initializer -> expr
Rule 67    initializer_list -> initializer_list , initializer
Rule 68    initializer_list -> initializer
Rule 69    stmt -> jump_stmt
Rule 70    stmt -> loop_stmt
Rule 71    stmt -> if_stmt
Rule 72    stmt -> expr_stmt
Rule 73    stmt -> block_stmt
Rule 74    stmt -> labeled_stmt
Rule 75    labeled_stmt -> IDENTIFIER : stmt
Rule 76    block_stmt -> { stmt_list }
Rule 77    block_stmt -> { }
Rule 78    stmt_list -> stmt_list stmt
Rule 79    stmt_list -> stmt
Rule 80    expr_stmt -> decl
Rule 81    expr_stmt -> expr ;
Rule 82    expr_stmt -> ;
Rule 83    if_stmt -> IF ( expr ) stmt ELSE stmt
Rule 84    if_stmt -> IF ( expr ) stmt
Rule 85    loop_stmt -> FOR ( expr_stmt expr_stmt expr ) stmt
Rule 86    loop_stmt -> DO stmt WHILE ( expr ) ;
Rule 87    loop_stmt -> WHILE ( expr ) stmt
Rule 88    jump_stmt -> RETURN expr ;
Rule 89    jump_stmt -> RETURN ;
Rule 90    jump_stmt -> BREAK ;
Rule 91    jump_stmt -> CONTINUE ;
Rule 92    jump_stmt -> GOTO IDENTIFIER ;
Rule 93    translation_unit -> translation_unit ext_decl
Rule 94    translation_unit -> ext_decl
Rule 95    ext_decl -> import_decl
Rule 96    ext_decl -> define_decl
Rule 97    ext_decl -> include_decl
Rule 98    ext_decl -> func_decl
Rule 99    ext_decl -> decl
Rule 100   func_decl -> type declarator block_stmt
Rule 101   include_decl -> INCLUDE STRING
Rule 102   define_decl -> DEFINE IDENTIFIER STRING
Rule 103   define_decl -> DEFINE IDENTIFIER literal
Rule 104   define_decl -> DEFINE IDENTIFIER IDENTIFIER
Rule 105   import_decl -> IMPORT IDENTIFIER INTEGER INTEGER STRING IDENTIFIER

Terminals, with rules where they appear:

!                    : 15
%                    : 23
(                    : 3 9 10 22 59 60 83 84 85 86 87
)                    : 3 9 10 22 59 60 83 84 85 86 87
*                    : 25
+                    : 17 28
,                    : 13 62 67
-                    : 16 27
.                    : 8
/                    : 24
:                    : 75
;                    : 50 81 82 86 88 89 90 91 92
<                    : 32
=                    : 44 51
>                    : 33
AND                  : 38
BREAK                : 90
CONTINUE             : 91
DEC                  : 6 18
DEFINE               : 102 103 104
DIVEQ                : 46
DO                   : 86
DOUBLE               : 55
ELSE                 : 83
EQ                   : 36
FLOAT                : 1
FOR                  : 85
GE                   : 31
GOTO                 : 92
IDENTIFIER           : 5 8 61 75 92 102 103 104 104 105 105
IF                   : 83 84
IMPORT               : 105
INC                  : 7 19
INCLUDE              : 101
INT                  : 56
INTEGER              : 2 105 105
LE                   : 30
MINUSEQ              : 48
MODEQ                : 45
MULEQ                : 47
NE                   : 35
OR                   : 40
PLUSEQ               : 49
RETURN               : 88 89
STRING               : 101 102 105
STRING_T             : 54
VOID                 : 53
WHILE                : 86 87
[                    : 11 57 58
]                    : 11 57 58
error                : 
{                    : 65 76 77
}                    : 65 76 77

Nonterminals, with rules where they appear:

add_expr             : 27 28 30 31 32 33 34
and_expr             : 38 40 41
arg_expr_list        : 9 13
assignment_op        : 42
block_stmt           : 73 100
cast_expr            : 15 16 17 22 23 24 25 26
cond_expr            : 40 43 58
decl                 : 80 99
declarator           : 51 52 57 58 59 60 64 100
define_decl          : 96
eq_expr              : 35 36 38 39
expr                 : 3 11 13 14 42 66 81 83 84 85 86 87 88
expr_stmt            : 72 85 85
ext_decl             : 93 94
func_decl            : 98
if_stmt              : 71
import_decl          : 95
include_decl         : 97
init_declarator      : 50
initializer          : 51 67 68
initializer_list     : 65 67
jump_stmt            : 69
labeled_stmt         : 74
literal              : 4 103
loop_stmt            : 70
mult_expr            : 23 24 25 27 28 29
param_decl           : 62 63
param_list           : 60 62
postfix_expr         : 6 7 8 9 10 11 20
primary_expr         : 12
rel_expr             : 30 31 32 33 35 36 37
stmt                 : 75 78 79 83 83 84 85 86 87
stmt_list            : 76 78
translation_unit     : 93 0
type                 : 22 50 64 100
unary_expr           : 18 19 21 42


state 0

    (0) S' -> . translation_unit
    (93) translation_unit -> . translation_unit ext_decl
    (94) translation_unit -> . ext_decl
    (95) ext_decl -> . import_decl
    (96) ext_decl -> . define_decl
    (97) ext_decl -> . include_decl
    (98) ext_decl -> . func_decl
    (99) ext_decl -> . decl
    (105) import_decl -> . IMPORT IDENTIFIER INTEGER INTEGER STRING IDENTIFIER
    (102) define_decl -> . DEFINE IDENTIFIER STRING
    (103) define_decl -> . DEFINE IDENTIFIER literal
    (104) define_decl -> . DEFINE IDENTIFIER IDENTIFIER
    (101) include_decl -> . INCLUDE STRING
    (100) func_decl -> . type declarator block_stmt
    (50) decl -> . type init_declarator ;
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    IMPORT          shift and go to state 8
    DEFINE          shift and go to state 9
    INCLUDE         shift and go to state 10
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15

    translation_unit               shift and go to state 1
    ext_decl                       shift and go to state 2
    import_decl                    shift and go to state 3
    define_decl                    shift and go to state 4
    include_decl                   shift and go to state 5
    func_decl                      shift and go to state 6
    decl                           shift and go to state 7
    type                           shift and go to state 11

state 1

    (0) S' -> translation_unit .
    (93) translation_unit -> translation_unit . ext_decl
    (95) ext_decl -> . import_decl
    (96) ext_decl -> . define_decl
    (97) ext_decl -> . include_decl
    (98) ext_decl -> . func_decl
    (99) ext_decl -> . decl
    (105) import_decl -> . IMPORT IDENTIFIER INTEGER INTEGER STRING IDENTIFIER
    (102) define_decl -> . DEFINE IDENTIFIER STRING
    (103) define_decl -> . DEFINE IDENTIFIER literal
    (104) define_decl -> . DEFINE IDENTIFIER IDENTIFIER
    (101) include_decl -> . INCLUDE STRING
    (100) func_decl -> . type declarator block_stmt
    (50) decl -> . type init_declarator ;
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    IMPORT          shift and go to state 8
    DEFINE          shift and go to state 9
    INCLUDE         shift and go to state 10
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15

    ext_decl                       shift and go to state 16
    import_decl                    shift and go to state 3
    define_decl                    shift and go to state 4
    include_decl                   shift and go to state 5
    func_decl                      shift and go to state 6
    decl                           shift and go to state 7
    type                           shift and go to state 11

state 2

    (94) translation_unit -> ext_decl .
    IMPORT          reduce using rule 94 (translation_unit -> ext_decl .)
    DEFINE          reduce using rule 94 (translation_unit -> ext_decl .)
    INCLUDE         reduce using rule 94 (translation_unit -> ext_decl .)
    VOID            reduce using rule 94 (translation_unit -> ext_decl .)
    STRING_T        reduce using rule 94 (translation_unit -> ext_decl .)
    DOUBLE          reduce using rule 94 (translation_unit -> ext_decl .)
    INT             reduce using rule 94 (translation_unit -> ext_decl .)
    $end            reduce using rule 94 (translation_unit -> ext_decl .)


state 3

    (95) ext_decl -> import_decl .
    IMPORT          reduce using rule 95 (ext_decl -> import_decl .)
    DEFINE          reduce using rule 95 (ext_decl -> import_decl .)
    INCLUDE         reduce using rule 95 (ext_decl -> import_decl .)
    VOID            reduce using rule 95 (ext_decl -> import_decl .)
    STRING_T        reduce using rule 95 (ext_decl -> import_decl .)
    DOUBLE          reduce using rule 95 (ext_decl -> import_decl .)
    INT             reduce using rule 95 (ext_decl -> import_decl .)
    $end            reduce using rule 95 (ext_decl -> import_decl .)


state 4

    (96) ext_decl -> define_decl .
    IMPORT          reduce using rule 96 (ext_decl -> define_decl .)
    DEFINE          reduce using rule 96 (ext_decl -> define_decl .)
    INCLUDE         reduce using rule 96 (ext_decl -> define_decl .)
    VOID            reduce using rule 96 (ext_decl -> define_decl .)
    STRING_T        reduce using rule 96 (ext_decl -> define_decl .)
    DOUBLE          reduce using rule 96 (ext_decl -> define_decl .)
    INT             reduce using rule 96 (ext_decl -> define_decl .)
    $end            reduce using rule 96 (ext_decl -> define_decl .)


state 5

    (97) ext_decl -> include_decl .
    IMPORT          reduce using rule 97 (ext_decl -> include_decl .)
    DEFINE          reduce using rule 97 (ext_decl -> include_decl .)
    INCLUDE         reduce using rule 97 (ext_decl -> include_decl .)
    VOID            reduce using rule 97 (ext_decl -> include_decl .)
    STRING_T        reduce using rule 97 (ext_decl -> include_decl .)
    DOUBLE          reduce using rule 97 (ext_decl -> include_decl .)
    INT             reduce using rule 97 (ext_decl -> include_decl .)
    $end            reduce using rule 97 (ext_decl -> include_decl .)


state 6

    (98) ext_decl -> func_decl .
    IMPORT          reduce using rule 98 (ext_decl -> func_decl .)
    DEFINE          reduce using rule 98 (ext_decl -> func_decl .)
    INCLUDE         reduce using rule 98 (ext_decl -> func_decl .)
    VOID            reduce using rule 98 (ext_decl -> func_decl .)
    STRING_T        reduce using rule 98 (ext_decl -> func_decl .)
    DOUBLE          reduce using rule 98 (ext_decl -> func_decl .)
    INT             reduce using rule 98 (ext_decl -> func_decl .)
    $end            reduce using rule 98 (ext_decl -> func_decl .)


state 7

    (99) ext_decl -> decl .
    IMPORT          reduce using rule 99 (ext_decl -> decl .)
    DEFINE          reduce using rule 99 (ext_decl -> decl .)
    INCLUDE         reduce using rule 99 (ext_decl -> decl .)
    VOID            reduce using rule 99 (ext_decl -> decl .)
    STRING_T        reduce using rule 99 (ext_decl -> decl .)
    DOUBLE          reduce using rule 99 (ext_decl -> decl .)
    INT             reduce using rule 99 (ext_decl -> decl .)
    $end            reduce using rule 99 (ext_decl -> decl .)


state 8

    (105) import_decl -> IMPORT . IDENTIFIER INTEGER INTEGER STRING IDENTIFIER
    IDENTIFIER      shift and go to state 17


state 9

    (102) define_decl -> DEFINE . IDENTIFIER STRING
    (103) define_decl -> DEFINE . IDENTIFIER literal
    (104) define_decl -> DEFINE . IDENTIFIER IDENTIFIER
    IDENTIFIER      shift and go to state 18


state 10

    (101) include_decl -> INCLUDE . STRING
    STRING          shift and go to state 19


state 11

    (100) func_decl -> type . declarator block_stmt
    (50) decl -> type . init_declarator ;
    (57) declarator -> . declarator [ ]
    (58) declarator -> . declarator [ cond_expr ]
    (59) declarator -> . declarator ( )
    (60) declarator -> . declarator ( param_list )
    (61) declarator -> . IDENTIFIER
    (51) init_declarator -> . declarator = initializer
    (52) init_declarator -> . declarator
    IDENTIFIER      shift and go to state 22

    declarator                     shift and go to state 20
    init_declarator                shift and go to state 21

state 12

    (53) type -> VOID .
    IDENTIFIER      reduce using rule 53 (type -> VOID .)
    )               reduce using rule 53 (type -> VOID .)


state 13

    (54) type -> STRING_T .
    IDENTIFIER      reduce using rule 54 (type -> STRING_T .)
    )               reduce using rule 54 (type -> STRING_T .)


state 14

    (55) type -> DOUBLE .
    IDENTIFIER      reduce using rule 55 (type -> DOUBLE .)
    )               reduce using rule 55 (type -> DOUBLE .)


state 15

    (56) type -> INT .
    IDENTIFIER      reduce using rule 56 (type -> INT .)
    )               reduce using rule 56 (type -> INT .)


state 16

    (93) translation_unit -> translation_unit ext_decl .
    IMPORT          reduce using rule 93 (translation_unit -> translation_unit ext_decl .)
    DEFINE          reduce using rule 93 (translation_unit -> translation_unit ext_decl .)
    INCLUDE         reduce using rule 93 (translation_unit -> translation_unit ext_decl .)
    VOID            reduce using rule 93 (translation_unit -> translation_unit ext_decl .)
    STRING_T        reduce using rule 93 (translation_unit -> translation_unit ext_decl .)
    DOUBLE          reduce using rule 93 (translation_unit -> translation_unit ext_decl .)
    INT             reduce using rule 93 (translation_unit -> translation_unit ext_decl .)
    $end            reduce using rule 93 (translation_unit -> translation_unit ext_decl .)


state 17

    (105) import_decl -> IMPORT IDENTIFIER . INTEGER INTEGER STRING IDENTIFIER
    INTEGER         shift and go to state 23


state 18

    (102) define_decl -> DEFINE IDENTIFIER . STRING
    (103) define_decl -> DEFINE IDENTIFIER . literal
    (104) define_decl -> DEFINE IDENTIFIER . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    STRING          shift and go to state 25
    IDENTIFIER      shift and go to state 24
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    literal                        shift and go to state 26

state 19

    (101) include_decl -> INCLUDE STRING .
    IMPORT          reduce using rule 101 (include_decl -> INCLUDE STRING .)
    DEFINE          reduce using rule 101 (include_decl -> INCLUDE STRING .)
    INCLUDE         reduce using rule 101 (include_decl -> INCLUDE STRING .)
    VOID            reduce using rule 101 (include_decl -> INCLUDE STRING .)
    STRING_T        reduce using rule 101 (include_decl -> INCLUDE STRING .)
    DOUBLE          reduce using rule 101 (include_decl -> INCLUDE STRING .)
    INT             reduce using rule 101 (include_decl -> INCLUDE STRING .)
    $end            reduce using rule 101 (include_decl -> INCLUDE STRING .)


state 20

    (100) func_decl -> type declarator . block_stmt
    (57) declarator -> declarator . [ ]
    (58) declarator -> declarator . [ cond_expr ]
    (59) declarator -> declarator . ( )
    (60) declarator -> declarator . ( param_list )
    (51) init_declarator -> declarator . = initializer
    (52) init_declarator -> declarator .
    (76) block_stmt -> . { stmt_list }
    (77) block_stmt -> . { }
    [               shift and go to state 30
    (               shift and go to state 31
    =               shift and go to state 32
    ;               reduce using rule 52 (init_declarator -> declarator .)
    {               shift and go to state 33

    block_stmt                     shift and go to state 29

state 21

    (50) decl -> type init_declarator . ;
    ;               shift and go to state 34


state 22

    (61) declarator -> IDENTIFIER .
    [               reduce using rule 61 (declarator -> IDENTIFIER .)
    (               reduce using rule 61 (declarator -> IDENTIFIER .)
    =               reduce using rule 61 (declarator -> IDENTIFIER .)
    {               reduce using rule 61 (declarator -> IDENTIFIER .)
    ;               reduce using rule 61 (declarator -> IDENTIFIER .)
    )               reduce using rule 61 (declarator -> IDENTIFIER .)
    ,               reduce using rule 61 (declarator -> IDENTIFIER .)


state 23

    (105) import_decl -> IMPORT IDENTIFIER INTEGER . INTEGER STRING IDENTIFIER
    INTEGER         shift and go to state 35


state 24

    (104) define_decl -> DEFINE IDENTIFIER IDENTIFIER .
    IMPORT          reduce using rule 104 (define_decl -> DEFINE IDENTIFIER IDENTIFIER .)
    DEFINE          reduce using rule 104 (define_decl -> DEFINE IDENTIFIER IDENTIFIER .)
    INCLUDE         reduce using rule 104 (define_decl -> DEFINE IDENTIFIER IDENTIFIER .)
    VOID            reduce using rule 104 (define_decl -> DEFINE IDENTIFIER IDENTIFIER .)
    STRING_T        reduce using rule 104 (define_decl -> DEFINE IDENTIFIER IDENTIFIER .)
    DOUBLE          reduce using rule 104 (define_decl -> DEFINE IDENTIFIER IDENTIFIER .)
    INT             reduce using rule 104 (define_decl -> DEFINE IDENTIFIER IDENTIFIER .)
    $end            reduce using rule 104 (define_decl -> DEFINE IDENTIFIER IDENTIFIER .)


state 25

    (102) define_decl -> DEFINE IDENTIFIER STRING .
    IMPORT          reduce using rule 102 (define_decl -> DEFINE IDENTIFIER STRING .)
    DEFINE          reduce using rule 102 (define_decl -> DEFINE IDENTIFIER STRING .)
    INCLUDE         reduce using rule 102 (define_decl -> DEFINE IDENTIFIER STRING .)
    VOID            reduce using rule 102 (define_decl -> DEFINE IDENTIFIER STRING .)
    STRING_T        reduce using rule 102 (define_decl -> DEFINE IDENTIFIER STRING .)
    DOUBLE          reduce using rule 102 (define_decl -> DEFINE IDENTIFIER STRING .)
    INT             reduce using rule 102 (define_decl -> DEFINE IDENTIFIER STRING .)
    $end            reduce using rule 102 (define_decl -> DEFINE IDENTIFIER STRING .)


state 26

    (103) define_decl -> DEFINE IDENTIFIER literal .
    IMPORT          reduce using rule 103 (define_decl -> DEFINE IDENTIFIER literal .)
    DEFINE          reduce using rule 103 (define_decl -> DEFINE IDENTIFIER literal .)
    INCLUDE         reduce using rule 103 (define_decl -> DEFINE IDENTIFIER literal .)
    VOID            reduce using rule 103 (define_decl -> DEFINE IDENTIFIER literal .)
    STRING_T        reduce using rule 103 (define_decl -> DEFINE IDENTIFIER literal .)
    DOUBLE          reduce using rule 103 (define_decl -> DEFINE IDENTIFIER literal .)
    INT             reduce using rule 103 (define_decl -> DEFINE IDENTIFIER literal .)
    $end            reduce using rule 103 (define_decl -> DEFINE IDENTIFIER literal .)


state 27

    (1) literal -> FLOAT .
    IMPORT          reduce using rule 1 (literal -> FLOAT .)
    DEFINE          reduce using rule 1 (literal -> FLOAT .)
    INCLUDE         reduce using rule 1 (literal -> FLOAT .)
    VOID            reduce using rule 1 (literal -> FLOAT .)
    STRING_T        reduce using rule 1 (literal -> FLOAT .)
    DOUBLE          reduce using rule 1 (literal -> FLOAT .)
    INT             reduce using rule 1 (literal -> FLOAT .)
    $end            reduce using rule 1 (literal -> FLOAT .)
    DEC             reduce using rule 1 (literal -> FLOAT .)
    INC             reduce using rule 1 (literal -> FLOAT .)
    .               reduce using rule 1 (literal -> FLOAT .)
    (               reduce using rule 1 (literal -> FLOAT .)
    [               reduce using rule 1 (literal -> FLOAT .)
    %               reduce using rule 1 (literal -> FLOAT .)
    /               reduce using rule 1 (literal -> FLOAT .)
    *               reduce using rule 1 (literal -> FLOAT .)
    -               reduce using rule 1 (literal -> FLOAT .)
    +               reduce using rule 1 (literal -> FLOAT .)
    LE              reduce using rule 1 (literal -> FLOAT .)
    GE              reduce using rule 1 (literal -> FLOAT .)
    <               reduce using rule 1 (literal -> FLOAT .)
    >               reduce using rule 1 (literal -> FLOAT .)
    NE              reduce using rule 1 (literal -> FLOAT .)
    EQ              reduce using rule 1 (literal -> FLOAT .)
    AND             reduce using rule 1 (literal -> FLOAT .)
    ]               reduce using rule 1 (literal -> FLOAT .)
    OR              reduce using rule 1 (literal -> FLOAT .)
    =               reduce using rule 1 (literal -> FLOAT .)
    MODEQ           reduce using rule 1 (literal -> FLOAT .)
    DIVEQ           reduce using rule 1 (literal -> FLOAT .)
    MULEQ           reduce using rule 1 (literal -> FLOAT .)
    MINUSEQ         reduce using rule 1 (literal -> FLOAT .)
    PLUSEQ          reduce using rule 1 (literal -> FLOAT .)
    ;               reduce using rule 1 (literal -> FLOAT .)
    )               reduce using rule 1 (literal -> FLOAT .)
    }               reduce using rule 1 (literal -> FLOAT .)
    ,               reduce using rule 1 (literal -> FLOAT .)


state 28

    (2) literal -> INTEGER .
    IMPORT          reduce using rule 2 (literal -> INTEGER .)
    DEFINE          reduce using rule 2 (literal -> INTEGER .)
    INCLUDE         reduce using rule 2 (literal -> INTEGER .)
    VOID            reduce using rule 2 (literal -> INTEGER .)
    STRING_T        reduce using rule 2 (literal -> INTEGER .)
    DOUBLE          reduce using rule 2 (literal -> INTEGER .)
    INT             reduce using rule 2 (literal -> INTEGER .)
    $end            reduce using rule 2 (literal -> INTEGER .)
    DEC             reduce using rule 2 (literal -> INTEGER .)
    INC             reduce using rule 2 (literal -> INTEGER .)
    .               reduce using rule 2 (literal -> INTEGER .)
    (               reduce using rule 2 (literal -> INTEGER .)
    [               reduce using rule 2 (literal -> INTEGER .)
    %               reduce using rule 2 (literal -> INTEGER .)
    /               reduce using rule 2 (literal -> INTEGER .)
    *               reduce using rule 2 (literal -> INTEGER .)
    -               reduce using rule 2 (literal -> INTEGER .)
    +               reduce using rule 2 (literal -> INTEGER .)
    LE              reduce using rule 2 (literal -> INTEGER .)
    GE              reduce using rule 2 (literal -> INTEGER .)
    <               reduce using rule 2 (literal -> INTEGER .)
    >               reduce using rule 2 (literal -> INTEGER .)
    NE              reduce using rule 2 (literal -> INTEGER .)
    EQ              reduce using rule 2 (literal -> INTEGER .)
    AND             reduce using rule 2 (literal -> INTEGER .)
    ]               reduce using rule 2 (literal -> INTEGER .)
    OR              reduce using rule 2 (literal -> INTEGER .)
    =               reduce using rule 2 (literal -> INTEGER .)
    MODEQ           reduce using rule 2 (literal -> INTEGER .)
    DIVEQ           reduce using rule 2 (literal -> INTEGER .)
    MULEQ           reduce using rule 2 (literal -> INTEGER .)
    MINUSEQ         reduce using rule 2 (literal -> INTEGER .)
    PLUSEQ          reduce using rule 2 (literal -> INTEGER .)
    ;               reduce using rule 2 (literal -> INTEGER .)
    )               reduce using rule 2 (literal -> INTEGER .)
    }               reduce using rule 2 (literal -> INTEGER .)
    ,               reduce using rule 2 (literal -> INTEGER .)


state 29

    (100) func_decl -> type declarator block_stmt .
    IMPORT          reduce using rule 100 (func_decl -> type declarator block_stmt .)
    DEFINE          reduce using rule 100 (func_decl -> type declarator block_stmt .)
    INCLUDE         reduce using rule 100 (func_decl -> type declarator block_stmt .)
    VOID            reduce using rule 100 (func_decl -> type declarator block_stmt .)
    STRING_T        reduce using rule 100 (func_decl -> type declarator block_stmt .)
    DOUBLE          reduce using rule 100 (func_decl -> type declarator block_stmt .)
    INT             reduce using rule 100 (func_decl -> type declarator block_stmt .)
    $end            reduce using rule 100 (func_decl -> type declarator block_stmt .)


state 30

    (57) declarator -> declarator [ . ]
    (58) declarator -> declarator [ . cond_expr ]
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr < add_expr
    (33) rel_expr -> . rel_expr > add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    ]               shift and go to state 36
    (               shift and go to state 47
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    cond_expr                      shift and go to state 37
    and_expr                       shift and go to state 38
    eq_expr                        shift and go to state 39
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43
    cast_expr                      shift and go to state 45
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 31

    (59) declarator -> declarator ( . )
    (60) declarator -> declarator ( . param_list )
    (62) param_list -> . param_list , param_decl
    (63) param_list -> . param_decl
    (64) param_decl -> . type declarator
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    )               shift and go to state 55
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15

    param_list                     shift and go to state 56
    param_decl                     shift and go to state 57
    type                           shift and go to state 58

state 32

    (51) init_declarator -> declarator = . initializer
    (65) initializer -> . { initializer_list }
    (66) initializer -> . expr
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr < add_expr
    (33) rel_expr -> . rel_expr > add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    {               shift and go to state 60
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    (               shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    initializer                    shift and go to state 59
    expr                           shift and go to state 61
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 33

    (76) block_stmt -> { . stmt_list }
    (77) block_stmt -> { . }
    (78) stmt_list -> . stmt_list stmt
    (79) stmt_list -> . stmt
    (69) stmt -> . jump_stmt
    (70) stmt -> . loop_stmt
    (71) stmt -> . if_stmt
    (72) stmt -> . expr_stmt
    (73) stmt -> . block_stmt
    (74) stmt -> . labeled_stmt
    (88) jump_stmt -> . RETURN expr ;
    (89) jump_stmt -> . RETURN ;
    (90) jump_stmt -> . BREAK ;
    (91) jump_stmt -> . CONTINUE ;
    (92) jump_stmt -> . GOTO IDENTIFIER ;
    (85) loop_stmt -> . FOR ( expr_stmt expr_stmt expr ) stmt
    (86) loop_stmt -> . DO stmt WHILE ( expr ) ;
    (87) loop_stmt -> . WHILE ( expr ) stmt
    (83) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (84) if_stmt -> . IF ( expr ) stmt
    (80) expr_stmt -> . decl
    (81) expr_stmt -> . expr ;
    (82) expr_stmt -> . ;
    (76) block_stmt -> . { stmt_list }
    (77) block_stmt -> . { }
    (75) labeled_stmt -> . IDENTIFIER : stmt
    (50) decl -> . type init_declarator ;
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr < add_expr
    (33) rel_expr -> . rel_expr > add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    }               shift and go to state 66
    RETURN          shift and go to state 74
    BREAK           shift and go to state 77
    CONTINUE        shift and go to state 78
    GOTO            shift and go to state 79
    FOR             shift and go to state 81
    DO              shift and go to state 82
    WHILE           shift and go to state 83
    IF              shift and go to state 84
    ;               shift and go to state 76
    {               shift and go to state 33
    IDENTIFIER      shift and go to state 80
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    (               shift and go to state 64
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    stmt_list                      shift and go to state 65
    stmt                           shift and go to state 67
    jump_stmt                      shift and go to state 68
    loop_stmt                      shift and go to state 69
    if_stmt                        shift and go to state 70
    expr_stmt                      shift and go to state 71
    block_stmt                     shift and go to state 72
    labeled_stmt                   shift and go to state 73
    expr                           shift and go to state 75
    decl                           shift and go to state 85
    type                           shift and go to state 86
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 34

    (50) decl -> type init_declarator ; .
    IMPORT          reduce using rule 50 (decl -> type init_declarator ; .)
    DEFINE          reduce using rule 50 (decl -> type init_declarator ; .)
    INCLUDE         reduce using rule 50 (decl -> type init_declarator ; .)
    VOID            reduce using rule 50 (decl -> type init_declarator ; .)
    STRING_T        reduce using rule 50 (decl -> type init_declarator ; .)
    DOUBLE          reduce using rule 50 (decl -> type init_declarator ; .)
    INT             reduce using rule 50 (decl -> type init_declarator ; .)
    $end            reduce using rule 50 (decl -> type init_declarator ; .)
    }               reduce using rule 50 (decl -> type init_declarator ; .)
    RETURN          reduce using rule 50 (decl -> type init_declarator ; .)
    BREAK           reduce using rule 50 (decl -> type init_declarator ; .)
    CONTINUE        reduce using rule 50 (decl -> type init_declarator ; .)
    GOTO            reduce using rule 50 (decl -> type init_declarator ; .)
    FOR             reduce using rule 50 (decl -> type init_declarator ; .)
    DO              reduce using rule 50 (decl -> type init_declarator ; .)
    WHILE           reduce using rule 50 (decl -> type init_declarator ; .)
    IF              reduce using rule 50 (decl -> type init_declarator ; .)
    ;               reduce using rule 50 (decl -> type init_declarator ; .)
    {               reduce using rule 50 (decl -> type init_declarator ; .)
    IDENTIFIER      reduce using rule 50 (decl -> type init_declarator ; .)
    !               reduce using rule 50 (decl -> type init_declarator ; .)
    -               reduce using rule 50 (decl -> type init_declarator ; .)
    +               reduce using rule 50 (decl -> type init_declarator ; .)
    DEC             reduce using rule 50 (decl -> type init_declarator ; .)
    INC             reduce using rule 50 (decl -> type init_declarator ; .)
    (               reduce using rule 50 (decl -> type init_declarator ; .)
    FLOAT           reduce using rule 50 (decl -> type init_declarator ; .)
    INTEGER         reduce using rule 50 (decl -> type init_declarator ; .)
    ELSE            reduce using rule 50 (decl -> type init_declarator ; .)


state 35

    (105) import_decl -> IMPORT IDENTIFIER INTEGER INTEGER . STRING IDENTIFIER
    STRING          shift and go to state 87


state 36

    (57) declarator -> declarator [ ] .
    [               reduce using rule 57 (declarator -> declarator [ ] .)
    (               reduce using rule 57 (declarator -> declarator [ ] .)
    =               reduce using rule 57 (declarator -> declarator [ ] .)
    {               reduce using rule 57 (declarator -> declarator [ ] .)
    ;               reduce using rule 57 (declarator -> declarator [ ] .)
    )               reduce using rule 57 (declarator -> declarator [ ] .)
    ,               reduce using rule 57 (declarator -> declarator [ ] .)


state 37

    (58) declarator -> declarator [ cond_expr . ]
    (40) cond_expr -> cond_expr . OR and_expr
    ]               shift and go to state 88
    OR              shift and go to state 89


state 38

    (41) cond_expr -> and_expr .
    (38) and_expr -> and_expr . AND eq_expr
    ]               reduce using rule 41 (cond_expr -> and_expr .)
    OR              reduce using rule 41 (cond_expr -> and_expr .)
    ;               reduce using rule 41 (cond_expr -> and_expr .)
    )               reduce using rule 41 (cond_expr -> and_expr .)
    }               reduce using rule 41 (cond_expr -> and_expr .)
    ,               reduce using rule 41 (cond_expr -> and_expr .)
    AND             shift and go to state 90


state 39

    (39) and_expr -> eq_expr .
    (35) eq_expr -> eq_expr . NE rel_expr
    (36) eq_expr -> eq_expr . EQ rel_expr
    AND             reduce using rule 39 (and_expr -> eq_expr .)
    ]               reduce using rule 39 (and_expr -> eq_expr .)
    OR              reduce using rule 39 (and_expr -> eq_expr .)
    ;               reduce using rule 39 (and_expr -> eq_expr .)
    )               reduce using rule 39 (and_expr -> eq_expr .)
    }               reduce using rule 39 (and_expr -> eq_expr .)
    ,               reduce using rule 39 (and_expr -> eq_expr .)
    NE              shift and go to state 91
    EQ              shift and go to state 92


state 40

    (37) eq_expr -> rel_expr .
    (30) rel_expr -> rel_expr . LE add_expr
    (31) rel_expr -> rel_expr . GE add_expr
    (32) rel_expr -> rel_expr . < add_expr
    (33) rel_expr -> rel_expr . > add_expr
    NE              reduce using rule 37 (eq_expr -> rel_expr .)
    EQ              reduce using rule 37 (eq_expr -> rel_expr .)
    AND             reduce using rule 37 (eq_expr -> rel_expr .)
    ]               reduce using rule 37 (eq_expr -> rel_expr .)
    OR              reduce using rule 37 (eq_expr -> rel_expr .)
    ;               reduce using rule 37 (eq_expr -> rel_expr .)
    )               reduce using rule 37 (eq_expr -> rel_expr .)
    }               reduce using rule 37 (eq_expr -> rel_expr .)
    ,               reduce using rule 37 (eq_expr -> rel_expr .)
    LE              shift and go to state 93
    GE              shift and go to state 94
    <               shift and go to state 95
    >               shift and go to state 96


state 41

    (34) rel_expr -> add_expr .
    (27) add_expr -> add_expr . - mult_expr
    (28) add_expr -> add_expr . + mult_expr
    LE              reduce using rule 34 (rel_expr -> add_expr .)
    GE              reduce using rule 34 (rel_expr -> add_expr .)
    <               reduce using rule 34 (rel_expr -> add_expr .)
    >               reduce using rule 34 (rel_expr -> add_expr .)
    NE              reduce using rule 34 (rel_expr -> add_expr .)
    EQ              reduce using rule 34 (rel_expr -> add_expr .)
    AND             reduce using rule 34 (rel_expr -> add_expr .)
    ]               reduce using rule 34 (rel_expr -> add_expr .)
    OR              reduce using rule 34 (rel_expr -> add_expr .)
    ;               reduce using rule 34 (rel_expr -> add_expr .)
    )               reduce using rule 34 (rel_expr -> add_expr .)
    }               reduce using rule 34 (rel_expr -> add_expr .)
    ,               reduce using rule 34 (rel_expr -> add_expr .)
    -               shift and go to state 97
    +               shift and go to state 98


state 42

    (16) unary_expr -> - . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (               shift and go to state 47
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    cast_expr                      shift and go to state 99
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 43

    (29) add_expr -> mult_expr .
    (23) mult_expr -> mult_expr . % cast_expr
    (24) mult_expr -> mult_expr . / cast_expr
    (25) mult_expr -> mult_expr . * cast_expr
    -               reduce using rule 29 (add_expr -> mult_expr .)
    +               reduce using rule 29 (add_expr -> mult_expr .)
    LE              reduce using rule 29 (add_expr -> mult_expr .)
    GE              reduce using rule 29 (add_expr -> mult_expr .)
    <               reduce using rule 29 (add_expr -> mult_expr .)
    >               reduce using rule 29 (add_expr -> mult_expr .)
    NE              reduce using rule 29 (add_expr -> mult_expr .)
    EQ              reduce using rule 29 (add_expr -> mult_expr .)
    AND             reduce using rule 29 (add_expr -> mult_expr .)
    ]               reduce using rule 29 (add_expr -> mult_expr .)
    OR              reduce using rule 29 (add_expr -> mult_expr .)
    ;               reduce using rule 29 (add_expr -> mult_expr .)
    )               reduce using rule 29 (add_expr -> mult_expr .)
    }               reduce using rule 29 (add_expr -> mult_expr .)
    ,               reduce using rule 29 (add_expr -> mult_expr .)
    %               shift and go to state 100
    /               shift and go to state 101
    *               shift and go to state 102


state 44

    (17) unary_expr -> + . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (               shift and go to state 47
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    cast_expr                      shift and go to state 103
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 45

    (26) mult_expr -> cast_expr .
    %               reduce using rule 26 (mult_expr -> cast_expr .)
    /               reduce using rule 26 (mult_expr -> cast_expr .)
    *               reduce using rule 26 (mult_expr -> cast_expr .)
    -               reduce using rule 26 (mult_expr -> cast_expr .)
    +               reduce using rule 26 (mult_expr -> cast_expr .)
    LE              reduce using rule 26 (mult_expr -> cast_expr .)
    GE              reduce using rule 26 (mult_expr -> cast_expr .)
    <               reduce using rule 26 (mult_expr -> cast_expr .)
    >               reduce using rule 26 (mult_expr -> cast_expr .)
    NE              reduce using rule 26 (mult_expr -> cast_expr .)
    EQ              reduce using rule 26 (mult_expr -> cast_expr .)
    AND             reduce using rule 26 (mult_expr -> cast_expr .)
    ]               reduce using rule 26 (mult_expr -> cast_expr .)
    OR              reduce using rule 26 (mult_expr -> cast_expr .)
    ;               reduce using rule 26 (mult_expr -> cast_expr .)
    )               reduce using rule 26 (mult_expr -> cast_expr .)
    }               reduce using rule 26 (mult_expr -> cast_expr .)
    ,               reduce using rule 26 (mult_expr -> cast_expr .)


state 46

    (21) cast_expr -> unary_expr .
    %               reduce using rule 21 (cast_expr -> unary_expr .)
    /               reduce using rule 21 (cast_expr -> unary_expr .)
    *               reduce using rule 21 (cast_expr -> unary_expr .)
    -               reduce using rule 21 (cast_expr -> unary_expr .)
    +               reduce using rule 21 (cast_expr -> unary_expr .)
    LE              reduce using rule 21 (cast_expr -> unary_expr .)
    GE              reduce using rule 21 (cast_expr -> unary_expr .)
    <               reduce using rule 21 (cast_expr -> unary_expr .)
    >               reduce using rule 21 (cast_expr -> unary_expr .)
    NE              reduce using rule 21 (cast_expr -> unary_expr .)
    EQ              reduce using rule 21 (cast_expr -> unary_expr .)
    AND             reduce using rule 21 (cast_expr -> unary_expr .)
    ]               reduce using rule 21 (cast_expr -> unary_expr .)
    OR              reduce using rule 21 (cast_expr -> unary_expr .)
    =               reduce using rule 21 (cast_expr -> unary_expr .)
    MODEQ           reduce using rule 21 (cast_expr -> unary_expr .)
    DIVEQ           reduce using rule 21 (cast_expr -> unary_expr .)
    MULEQ           reduce using rule 21 (cast_expr -> unary_expr .)
    MINUSEQ         reduce using rule 21 (cast_expr -> unary_expr .)
    PLUSEQ          reduce using rule 21 (cast_expr -> unary_expr .)
    ;               reduce using rule 21 (cast_expr -> unary_expr .)
    )               reduce using rule 21 (cast_expr -> unary_expr .)
    }               reduce using rule 21 (cast_expr -> unary_expr .)
    ,               reduce using rule 21 (cast_expr -> unary_expr .)


state 47

    (22) cast_expr -> ( . type ) cast_expr
    (3) primary_expr -> ( . expr )
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr < add_expr
    (33) rel_expr -> . rel_expr > add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    (               shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    type                           shift and go to state 104
    cast_expr                      shift and go to state 45
    expr                           shift and go to state 105
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 48

    (15) unary_expr -> ! . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (               shift and go to state 47
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    cast_expr                      shift and go to state 106
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 49

    (18) unary_expr -> DEC . unary_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    (               shift and go to state 108
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    unary_expr                     shift and go to state 107
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 50

    (19) unary_expr -> INC . unary_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    (               shift and go to state 108
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    unary_expr                     shift and go to state 109
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 51

    (20) unary_expr -> postfix_expr .
    (6) postfix_expr -> postfix_expr . DEC
    (7) postfix_expr -> postfix_expr . INC
    (8) postfix_expr -> postfix_expr . . IDENTIFIER
    (9) postfix_expr -> postfix_expr . ( arg_expr_list )
    (10) postfix_expr -> postfix_expr . ( )
    (11) postfix_expr -> postfix_expr . [ expr ]
    %               reduce using rule 20 (unary_expr -> postfix_expr .)
    /               reduce using rule 20 (unary_expr -> postfix_expr .)
    *               reduce using rule 20 (unary_expr -> postfix_expr .)
    -               reduce using rule 20 (unary_expr -> postfix_expr .)
    +               reduce using rule 20 (unary_expr -> postfix_expr .)
    LE              reduce using rule 20 (unary_expr -> postfix_expr .)
    GE              reduce using rule 20 (unary_expr -> postfix_expr .)
    <               reduce using rule 20 (unary_expr -> postfix_expr .)
    >               reduce using rule 20 (unary_expr -> postfix_expr .)
    NE              reduce using rule 20 (unary_expr -> postfix_expr .)
    EQ              reduce using rule 20 (unary_expr -> postfix_expr .)
    AND             reduce using rule 20 (unary_expr -> postfix_expr .)
    ]               reduce using rule 20 (unary_expr -> postfix_expr .)
    OR              reduce using rule 20 (unary_expr -> postfix_expr .)
    =               reduce using rule 20 (unary_expr -> postfix_expr .)
    MODEQ           reduce using rule 20 (unary_expr -> postfix_expr .)
    DIVEQ           reduce using rule 20 (unary_expr -> postfix_expr .)
    MULEQ           reduce using rule 20 (unary_expr -> postfix_expr .)
    MINUSEQ         reduce using rule 20 (unary_expr -> postfix_expr .)
    PLUSEQ          reduce using rule 20 (unary_expr -> postfix_expr .)
    ;               reduce using rule 20 (unary_expr -> postfix_expr .)
    )               reduce using rule 20 (unary_expr -> postfix_expr .)
    }               reduce using rule 20 (unary_expr -> postfix_expr .)
    ,               reduce using rule 20 (unary_expr -> postfix_expr .)
    DEC             shift and go to state 110
    INC             shift and go to state 111
    .               shift and go to state 112
    (               shift and go to state 113
    [               shift and go to state 114


state 52

    (5) primary_expr -> IDENTIFIER .
    DEC             reduce using rule 5 (primary_expr -> IDENTIFIER .)
    INC             reduce using rule 5 (primary_expr -> IDENTIFIER .)
    .               reduce using rule 5 (primary_expr -> IDENTIFIER .)
    (               reduce using rule 5 (primary_expr -> IDENTIFIER .)
    [               reduce using rule 5 (primary_expr -> IDENTIFIER .)
    %               reduce using rule 5 (primary_expr -> IDENTIFIER .)
    /               reduce using rule 5 (primary_expr -> IDENTIFIER .)
    *               reduce using rule 5 (primary_expr -> IDENTIFIER .)
    -               reduce using rule 5 (primary_expr -> IDENTIFIER .)
    +               reduce using rule 5 (primary_expr -> IDENTIFIER .)
    LE              reduce using rule 5 (primary_expr -> IDENTIFIER .)
    GE              reduce using rule 5 (primary_expr -> IDENTIFIER .)
    <               reduce using rule 5 (primary_expr -> IDENTIFIER .)
    >               reduce using rule 5 (primary_expr -> IDENTIFIER .)
    NE              reduce using rule 5 (primary_expr -> IDENTIFIER .)
    EQ              reduce using rule 5 (primary_expr -> IDENTIFIER .)
    AND             reduce using rule 5 (primary_expr -> IDENTIFIER .)
    ]               reduce using rule 5 (primary_expr -> IDENTIFIER .)
    OR              reduce using rule 5 (primary_expr -> IDENTIFIER .)
    =               reduce using rule 5 (primary_expr -> IDENTIFIER .)
    MODEQ           reduce using rule 5 (primary_expr -> IDENTIFIER .)
    DIVEQ           reduce using rule 5 (primary_expr -> IDENTIFIER .)
    MULEQ           reduce using rule 5 (primary_expr -> IDENTIFIER .)
    MINUSEQ         reduce using rule 5 (primary_expr -> IDENTIFIER .)
    PLUSEQ          reduce using rule 5 (primary_expr -> IDENTIFIER .)
    ;               reduce using rule 5 (primary_expr -> IDENTIFIER .)
    )               reduce using rule 5 (primary_expr -> IDENTIFIER .)
    }               reduce using rule 5 (primary_expr -> IDENTIFIER .)
    ,               reduce using rule 5 (primary_expr -> IDENTIFIER .)


state 53

    (12) postfix_expr -> primary_expr .
    DEC             reduce using rule 12 (postfix_expr -> primary_expr .)
    INC             reduce using rule 12 (postfix_expr -> primary_expr .)
    .               reduce using rule 12 (postfix_expr -> primary_expr .)
    (               reduce using rule 12 (postfix_expr -> primary_expr .)
    [               reduce using rule 12 (postfix_expr -> primary_expr .)
    %               reduce using rule 12 (postfix_expr -> primary_expr .)
    /               reduce using rule 12 (postfix_expr -> primary_expr .)
    *               reduce using rule 12 (postfix_expr -> primary_expr .)
    -               reduce using rule 12 (postfix_expr -> primary_expr .)
    +               reduce using rule 12 (postfix_expr -> primary_expr .)
    LE              reduce using rule 12 (postfix_expr -> primary_expr .)
    GE              reduce using rule 12 (postfix_expr -> primary_expr .)
    <               reduce using rule 12 (postfix_expr -> primary_expr .)
    >               reduce using rule 12 (postfix_expr -> primary_expr .)
    NE              reduce using rule 12 (postfix_expr -> primary_expr .)
    EQ              reduce using rule 12 (postfix_expr -> primary_expr .)
    AND             reduce using rule 12 (postfix_expr -> primary_expr .)
    ]               reduce using rule 12 (postfix_expr -> primary_expr .)
    OR              reduce using rule 12 (postfix_expr -> primary_expr .)
    =               reduce using rule 12 (postfix_expr -> primary_expr .)
    MODEQ           reduce using rule 12 (postfix_expr -> primary_expr .)
    DIVEQ           reduce using rule 12 (postfix_expr -> primary_expr .)
    MULEQ           reduce using rule 12 (postfix_expr -> primary_expr .)
    MINUSEQ         reduce using rule 12 (postfix_expr -> primary_expr .)
    PLUSEQ          reduce using rule 12 (postfix_expr -> primary_expr .)
    ;               reduce using rule 12 (postfix_expr -> primary_expr .)
    )               reduce using rule 12 (postfix_expr -> primary_expr .)
    }               reduce using rule 12 (postfix_expr -> primary_expr .)
    ,               reduce using rule 12 (postfix_expr -> primary_expr .)


state 54

    (4) primary_expr -> literal .
    DEC             reduce using rule 4 (primary_expr -> literal .)
    INC             reduce using rule 4 (primary_expr -> literal .)
    .               reduce using rule 4 (primary_expr -> literal .)
    (               reduce using rule 4 (primary_expr -> literal .)
    [               reduce using rule 4 (primary_expr -> literal .)
    %               reduce using rule 4 (primary_expr -> literal .)
    /               reduce using rule 4 (primary_expr -> literal .)
    *               reduce using rule 4 (primary_expr -> literal .)
    -               reduce using rule 4 (primary_expr -> literal .)
    +               reduce using rule 4 (primary_expr -> literal .)
    LE              reduce using rule 4 (primary_expr -> literal .)
    GE              reduce using rule 4 (primary_expr -> literal .)
    <               reduce using rule 4 (primary_expr -> literal .)
    >               reduce using rule 4 (primary_expr -> literal .)
    NE              reduce using rule 4 (primary_expr -> literal .)
    EQ              reduce using rule 4 (primary_expr -> literal .)
    AND             reduce using rule 4 (primary_expr -> literal .)
    ]               reduce using rule 4 (primary_expr -> literal .)
    OR              reduce using rule 4 (primary_expr -> literal .)
    =               reduce using rule 4 (primary_expr -> literal .)
    MODEQ           reduce using rule 4 (primary_expr -> literal .)
    DIVEQ           reduce using rule 4 (primary_expr -> literal .)
    MULEQ           reduce using rule 4 (primary_expr -> literal .)
    MINUSEQ         reduce using rule 4 (primary_expr -> literal .)
    PLUSEQ          reduce using rule 4 (primary_expr -> literal .)
    ;               reduce using rule 4 (primary_expr -> literal .)
    )               reduce using rule 4 (primary_expr -> literal .)
    }               reduce using rule 4 (primary_expr -> literal .)
    ,               reduce using rule 4 (primary_expr -> literal .)


state 55

    (59) declarator -> declarator ( ) .
    [               reduce using rule 59 (declarator -> declarator ( ) .)
    (               reduce using rule 59 (declarator -> declarator ( ) .)
    =               reduce using rule 59 (declarator -> declarator ( ) .)
    {               reduce using rule 59 (declarator -> declarator ( ) .)
    ;               reduce using rule 59 (declarator -> declarator ( ) .)
    )               reduce using rule 59 (declarator -> declarator ( ) .)
    ,               reduce using rule 59 (declarator -> declarator ( ) .)


state 56

    (60) declarator -> declarator ( param_list . )
    (62) param_list -> param_list . , param_decl
    )               shift and go to state 115
    ,               shift and go to state 116


state 57

    (63) param_list -> param_decl .
    )               reduce using rule 63 (param_list -> param_decl .)
    ,               reduce using rule 63 (param_list -> param_decl .)


state 58

    (64) param_decl -> type . declarator
    (57) declarator -> . declarator [ ]
    (58) declarator -> . declarator [ cond_expr ]
    (59) declarator -> . declarator ( )
    (60) declarator -> . declarator ( param_list )
    (61) declarator -> . IDENTIFIER
    IDENTIFIER      shift and go to state 22

    declarator                     shift and go to state 117

state 59

    (51) init_declarator -> declarator = initializer .
    ;               reduce using rule 51 (init_declarator -> declarator = initializer .)


state 60

    (65) initializer -> { . initializer_list }
    (67) initializer_list -> . initializer_list , initializer
    (68) initializer_list -> . initializer
    (65) initializer -> . { initializer_list }
    (66) initializer -> . expr
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr < add_expr
    (33) rel_expr -> . rel_expr > add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    {               shift and go to state 60
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    (               shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    initializer_list               shift and go to state 118
    initializer                    shift and go to state 119
    expr                           shift and go to state 61
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 61

    (66) initializer -> expr .
    ;               reduce using rule 66 (initializer -> expr .)
    }               reduce using rule 66 (initializer -> expr .)
    ,               reduce using rule 66 (initializer -> expr .)


state 62

    (42) expr -> unary_expr . assignment_op expr
    (21) cast_expr -> unary_expr .
    (44) assignment_op -> . =
    (45) assignment_op -> . MODEQ
    (46) assignment_op -> . DIVEQ
    (47) assignment_op -> . MULEQ
    (48) assignment_op -> . MINUSEQ
    (49) assignment_op -> . PLUSEQ
    %               reduce using rule 21 (cast_expr -> unary_expr .)
    /               reduce using rule 21 (cast_expr -> unary_expr .)
    *               reduce using rule 21 (cast_expr -> unary_expr .)
    -               reduce using rule 21 (cast_expr -> unary_expr .)
    +               reduce using rule 21 (cast_expr -> unary_expr .)
    LE              reduce using rule 21 (cast_expr -> unary_expr .)
    GE              reduce using rule 21 (cast_expr -> unary_expr .)
    <               reduce using rule 21 (cast_expr -> unary_expr .)
    >               reduce using rule 21 (cast_expr -> unary_expr .)
    NE              reduce using rule 21 (cast_expr -> unary_expr .)
    EQ              reduce using rule 21 (cast_expr -> unary_expr .)
    AND             reduce using rule 21 (cast_expr -> unary_expr .)
    OR              reduce using rule 21 (cast_expr -> unary_expr .)
    ;               reduce using rule 21 (cast_expr -> unary_expr .)
    )               reduce using rule 21 (cast_expr -> unary_expr .)
    }               reduce using rule 21 (cast_expr -> unary_expr .)
    ,               reduce using rule 21 (cast_expr -> unary_expr .)
    ]               reduce using rule 21 (cast_expr -> unary_expr .)
    =               shift and go to state 121
    MODEQ           shift and go to state 122
    DIVEQ           shift and go to state 123
    MULEQ           shift and go to state 124
    MINUSEQ         shift and go to state 125
    PLUSEQ          shift and go to state 126

    assignment_op                  shift and go to state 120

state 63

    (43) expr -> cond_expr .
    (40) cond_expr -> cond_expr . OR and_expr
    ;               reduce using rule 43 (expr -> cond_expr .)
    )               reduce using rule 43 (expr -> cond_expr .)
    }               reduce using rule 43 (expr -> cond_expr .)
    ,               reduce using rule 43 (expr -> cond_expr .)
    ]               reduce using rule 43 (expr -> cond_expr .)
    OR              shift and go to state 89


state 64

    (3) primary_expr -> ( . expr )
    (22) cast_expr -> ( . type ) cast_expr
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr < add_expr
    (33) rel_expr -> . rel_expr > add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    (               shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    expr                           shift and go to state 105
    type                           shift and go to state 104
    cast_expr                      shift and go to state 45
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 65

    (76) block_stmt -> { stmt_list . }
    (78) stmt_list -> stmt_list . stmt
    (69) stmt -> . jump_stmt
    (70) stmt -> . loop_stmt
    (71) stmt -> . if_stmt
    (72) stmt -> . expr_stmt
    (73) stmt -> . block_stmt
    (74) stmt -> . labeled_stmt
    (88) jump_stmt -> . RETURN expr ;
    (89) jump_stmt -> . RETURN ;
    (90) jump_stmt -> . BREAK ;
    (91) jump_stmt -> . CONTINUE ;
    (92) jump_stmt -> . GOTO IDENTIFIER ;
    (85) loop_stmt -> . FOR ( expr_stmt expr_stmt expr ) stmt
    (86) loop_stmt -> . DO stmt WHILE ( expr ) ;
    (87) loop_stmt -> . WHILE ( expr ) stmt
    (83) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (84) if_stmt -> . IF ( expr ) stmt
    (80) expr_stmt -> . decl
    (81) expr_stmt -> . expr ;
    (82) expr_stmt -> . ;
    (76) block_stmt -> . { stmt_list }
    (77) block_stmt -> . { }
    (75) labeled_stmt -> . IDENTIFIER : stmt
    (50) decl -> . type init_declarator ;
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr < add_expr
    (33) rel_expr -> . rel_expr > add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    }               shift and go to state 127
    RETURN          shift and go to state 74
    BREAK           shift and go to state 77
    CONTINUE        shift and go to state 78
    GOTO            shift and go to state 79
    FOR             shift and go to state 81
    DO              shift and go to state 82
    WHILE           shift and go to state 83
    IF              shift and go to state 84
    ;               shift and go to state 76
    {               shift and go to state 33
    IDENTIFIER      shift and go to state 80
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    (               shift and go to state 64
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    stmt                           shift and go to state 128
    jump_stmt                      shift and go to state 68
    loop_stmt                      shift and go to state 69
    if_stmt                        shift and go to state 70
    expr_stmt                      shift and go to state 71
    block_stmt                     shift and go to state 72
    labeled_stmt                   shift and go to state 73
    expr                           shift and go to state 75
    decl                           shift and go to state 85
    type                           shift and go to state 86
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 66

    (77) block_stmt -> { } .
    IMPORT          reduce using rule 77 (block_stmt -> { } .)
    DEFINE          reduce using rule 77 (block_stmt -> { } .)
    INCLUDE         reduce using rule 77 (block_stmt -> { } .)
    VOID            reduce using rule 77 (block_stmt -> { } .)
    STRING_T        reduce using rule 77 (block_stmt -> { } .)
    DOUBLE          reduce using rule 77 (block_stmt -> { } .)
    INT             reduce using rule 77 (block_stmt -> { } .)
    $end            reduce using rule 77 (block_stmt -> { } .)
    }               reduce using rule 77 (block_stmt -> { } .)
    RETURN          reduce using rule 77 (block_stmt -> { } .)
    BREAK           reduce using rule 77 (block_stmt -> { } .)
    CONTINUE        reduce using rule 77 (block_stmt -> { } .)
    GOTO            reduce using rule 77 (block_stmt -> { } .)
    FOR             reduce using rule 77 (block_stmt -> { } .)
    DO              reduce using rule 77 (block_stmt -> { } .)
    WHILE           reduce using rule 77 (block_stmt -> { } .)
    IF              reduce using rule 77 (block_stmt -> { } .)
    ;               reduce using rule 77 (block_stmt -> { } .)
    {               reduce using rule 77 (block_stmt -> { } .)
    IDENTIFIER      reduce using rule 77 (block_stmt -> { } .)
    !               reduce using rule 77 (block_stmt -> { } .)
    -               reduce using rule 77 (block_stmt -> { } .)
    +               reduce using rule 77 (block_stmt -> { } .)
    DEC             reduce using rule 77 (block_stmt -> { } .)
    INC             reduce using rule 77 (block_stmt -> { } .)
    (               reduce using rule 77 (block_stmt -> { } .)
    FLOAT           reduce using rule 77 (block_stmt -> { } .)
    INTEGER         reduce using rule 77 (block_stmt -> { } .)
    ELSE            reduce using rule 77 (block_stmt -> { } .)


state 67

    (79) stmt_list -> stmt .
    }               reduce using rule 79 (stmt_list -> stmt .)
    RETURN          reduce using rule 79 (stmt_list -> stmt .)
    BREAK           reduce using rule 79 (stmt_list -> stmt .)
    CONTINUE        reduce using rule 79 (stmt_list -> stmt .)
    GOTO            reduce using rule 79 (stmt_list -> stmt .)
    FOR             reduce using rule 79 (stmt_list -> stmt .)
    DO              reduce using rule 79 (stmt_list -> stmt .)
    WHILE           reduce using rule 79 (stmt_list -> stmt .)
    IF              reduce using rule 79 (stmt_list -> stmt .)
    ;               reduce using rule 79 (stmt_list -> stmt .)
    {               reduce using rule 79 (stmt_list -> stmt .)
    IDENTIFIER      reduce using rule 79 (stmt_list -> stmt .)
    VOID            reduce using rule 79 (stmt_list -> stmt .)
    STRING_T        reduce using rule 79 (stmt_list -> stmt .)
    DOUBLE          reduce using rule 79 (stmt_list -> stmt .)
    INT             reduce using rule 79 (stmt_list -> stmt .)
    !               reduce using rule 79 (stmt_list -> stmt .)
    -               reduce using rule 79 (stmt_list -> stmt .)
    +               reduce using rule 79 (stmt_list -> stmt .)
    DEC             reduce using rule 79 (stmt_list -> stmt .)
    INC             reduce using rule 79 (stmt_list -> stmt .)
    (               reduce using rule 79 (stmt_list -> stmt .)
    FLOAT           reduce using rule 79 (stmt_list -> stmt .)
    INTEGER         reduce using rule 79 (stmt_list -> stmt .)


state 68

    (69) stmt -> jump_stmt .
    }               reduce using rule 69 (stmt -> jump_stmt .)
    RETURN          reduce using rule 69 (stmt -> jump_stmt .)
    BREAK           reduce using rule 69 (stmt -> jump_stmt .)
    CONTINUE        reduce using rule 69 (stmt -> jump_stmt .)
    GOTO            reduce using rule 69 (stmt -> jump_stmt .)
    FOR             reduce using rule 69 (stmt -> jump_stmt .)
    DO              reduce using rule 69 (stmt -> jump_stmt .)
    WHILE           reduce using rule 69 (stmt -> jump_stmt .)
    IF              reduce using rule 69 (stmt -> jump_stmt .)
    ;               reduce using rule 69 (stmt -> jump_stmt .)
    {               reduce using rule 69 (stmt -> jump_stmt .)
    IDENTIFIER      reduce using rule 69 (stmt -> jump_stmt .)
    VOID            reduce using rule 69 (stmt -> jump_stmt .)
    STRING_T        reduce using rule 69 (stmt -> jump_stmt .)
    DOUBLE          reduce using rule 69 (stmt -> jump_stmt .)
    INT             reduce using rule 69 (stmt -> jump_stmt .)
    !               reduce using rule 69 (stmt -> jump_stmt .)
    -               reduce using rule 69 (stmt -> jump_stmt .)
    +               reduce using rule 69 (stmt -> jump_stmt .)
    DEC             reduce using rule 69 (stmt -> jump_stmt .)
    INC             reduce using rule 69 (stmt -> jump_stmt .)
    (               reduce using rule 69 (stmt -> jump_stmt .)
    FLOAT           reduce using rule 69 (stmt -> jump_stmt .)
    INTEGER         reduce using rule 69 (stmt -> jump_stmt .)
    ELSE            reduce using rule 69 (stmt -> jump_stmt .)


state 69

    (70) stmt -> loop_stmt .
    }               reduce using rule 70 (stmt -> loop_stmt .)
    RETURN          reduce using rule 70 (stmt -> loop_stmt .)
    BREAK           reduce using rule 70 (stmt -> loop_stmt .)
    CONTINUE        reduce using rule 70 (stmt -> loop_stmt .)
    GOTO            reduce using rule 70 (stmt -> loop_stmt .)
    FOR             reduce using rule 70 (stmt -> loop_stmt .)
    DO              reduce using rule 70 (stmt -> loop_stmt .)
    WHILE           reduce using rule 70 (stmt -> loop_stmt .)
    IF              reduce using rule 70 (stmt -> loop_stmt .)
    ;               reduce using rule 70 (stmt -> loop_stmt .)
    {               reduce using rule 70 (stmt -> loop_stmt .)
    IDENTIFIER      reduce using rule 70 (stmt -> loop_stmt .)
    VOID            reduce using rule 70 (stmt -> loop_stmt .)
    STRING_T        reduce using rule 70 (stmt -> loop_stmt .)
    DOUBLE          reduce using rule 70 (stmt -> loop_stmt .)
    INT             reduce using rule 70 (stmt -> loop_stmt .)
    !               reduce using rule 70 (stmt -> loop_stmt .)
    -               reduce using rule 70 (stmt -> loop_stmt .)
    +               reduce using rule 70 (stmt -> loop_stmt .)
    DEC             reduce using rule 70 (stmt -> loop_stmt .)
    INC             reduce using rule 70 (stmt -> loop_stmt .)
    (               reduce using rule 70 (stmt -> loop_stmt .)
    FLOAT           reduce using rule 70 (stmt -> loop_stmt .)
    INTEGER         reduce using rule 70 (stmt -> loop_stmt .)
    ELSE            reduce using rule 70 (stmt -> loop_stmt .)


state 70

    (71) stmt -> if_stmt .
    }               reduce using rule 71 (stmt -> if_stmt .)
    RETURN          reduce using rule 71 (stmt -> if_stmt .)
    BREAK           reduce using rule 71 (stmt -> if_stmt .)
    CONTINUE        reduce using rule 71 (stmt -> if_stmt .)
    GOTO            reduce using rule 71 (stmt -> if_stmt .)
    FOR             reduce using rule 71 (stmt -> if_stmt .)
    DO              reduce using rule 71 (stmt -> if_stmt .)
    WHILE           reduce using rule 71 (stmt -> if_stmt .)
    IF              reduce using rule 71 (stmt -> if_stmt .)
    ;               reduce using rule 71 (stmt -> if_stmt .)
    {               reduce using rule 71 (stmt -> if_stmt .)
    IDENTIFIER      reduce using rule 71 (stmt -> if_stmt .)
    VOID            reduce using rule 71 (stmt -> if_stmt .)
    STRING_T        reduce using rule 71 (stmt -> if_stmt .)
    DOUBLE          reduce using rule 71 (stmt -> if_stmt .)
    INT             reduce using rule 71 (stmt -> if_stmt .)
    !               reduce using rule 71 (stmt -> if_stmt .)
    -               reduce using rule 71 (stmt -> if_stmt .)
    +               reduce using rule 71 (stmt -> if_stmt .)
    DEC             reduce using rule 71 (stmt -> if_stmt .)
    INC             reduce using rule 71 (stmt -> if_stmt .)
    (               reduce using rule 71 (stmt -> if_stmt .)
    FLOAT           reduce using rule 71 (stmt -> if_stmt .)
    INTEGER         reduce using rule 71 (stmt -> if_stmt .)
    ELSE            reduce using rule 71 (stmt -> if_stmt .)


state 71

    (72) stmt -> expr_stmt .
    }               reduce using rule 72 (stmt -> expr_stmt .)
    RETURN          reduce using rule 72 (stmt -> expr_stmt .)
    BREAK           reduce using rule 72 (stmt -> expr_stmt .)
    CONTINUE        reduce using rule 72 (stmt -> expr_stmt .)
    GOTO            reduce using rule 72 (stmt -> expr_stmt .)
    FOR             reduce using rule 72 (stmt -> expr_stmt .)
    DO              reduce using rule 72 (stmt -> expr_stmt .)
    WHILE           reduce using rule 72 (stmt -> expr_stmt .)
    IF              reduce using rule 72 (stmt -> expr_stmt .)
    ;               reduce using rule 72 (stmt -> expr_stmt .)
    {               reduce using rule 72 (stmt -> expr_stmt .)
    IDENTIFIER      reduce using rule 72 (stmt -> expr_stmt .)
    VOID            reduce using rule 72 (stmt -> expr_stmt .)
    STRING_T        reduce using rule 72 (stmt -> expr_stmt .)
    DOUBLE          reduce using rule 72 (stmt -> expr_stmt .)
    INT             reduce using rule 72 (stmt -> expr_stmt .)
    !               reduce using rule 72 (stmt -> expr_stmt .)
    -               reduce using rule 72 (stmt -> expr_stmt .)
    +               reduce using rule 72 (stmt -> expr_stmt .)
    DEC             reduce using rule 72 (stmt -> expr_stmt .)
    INC             reduce using rule 72 (stmt -> expr_stmt .)
    (               reduce using rule 72 (stmt -> expr_stmt .)
    FLOAT           reduce using rule 72 (stmt -> expr_stmt .)
    INTEGER         reduce using rule 72 (stmt -> expr_stmt .)
    ELSE            reduce using rule 72 (stmt -> expr_stmt .)


state 72

    (73) stmt -> block_stmt .
    }               reduce using rule 73 (stmt -> block_stmt .)
    RETURN          reduce using rule 73 (stmt -> block_stmt .)
    BREAK           reduce using rule 73 (stmt -> block_stmt .)
    CONTINUE        reduce using rule 73 (stmt -> block_stmt .)
    GOTO            reduce using rule 73 (stmt -> block_stmt .)
    FOR             reduce using rule 73 (stmt -> block_stmt .)
    DO              reduce using rule 73 (stmt -> block_stmt .)
    WHILE           reduce using rule 73 (stmt -> block_stmt .)
    IF              reduce using rule 73 (stmt -> block_stmt .)
    ;               reduce using rule 73 (stmt -> block_stmt .)
    {               reduce using rule 73 (stmt -> block_stmt .)
    IDENTIFIER      reduce using rule 73 (stmt -> block_stmt .)
    VOID            reduce using rule 73 (stmt -> block_stmt .)
    STRING_T        reduce using rule 73 (stmt -> block_stmt .)
    DOUBLE          reduce using rule 73 (stmt -> block_stmt .)
    INT             reduce using rule 73 (stmt -> block_stmt .)
    !               reduce using rule 73 (stmt -> block_stmt .)
    -               reduce using rule 73 (stmt -> block_stmt .)
    +               reduce using rule 73 (stmt -> block_stmt .)
    DEC             reduce using rule 73 (stmt -> block_stmt .)
    INC             reduce using rule 73 (stmt -> block_stmt .)
    (               reduce using rule 73 (stmt -> block_stmt .)
    FLOAT           reduce using rule 73 (stmt -> block_stmt .)
    INTEGER         reduce using rule 73 (stmt -> block_stmt .)
    ELSE            reduce using rule 73 (stmt -> block_stmt .)


state 73

    (74) stmt -> labeled_stmt .
    }               reduce using rule 74 (stmt -> labeled_stmt .)
    RETURN          reduce using rule 74 (stmt -> labeled_stmt .)
    BREAK           reduce using rule 74 (stmt -> labeled_stmt .)
    CONTINUE        reduce using rule 74 (stmt -> labeled_stmt .)
    GOTO            reduce using rule 74 (stmt -> labeled_stmt .)
    FOR             reduce using rule 74 (stmt -> labeled_stmt .)
    DO              reduce using rule 74 (stmt -> labeled_stmt .)
    WHILE           reduce using rule 74 (stmt -> labeled_stmt .)
    IF              reduce using rule 74 (stmt -> labeled_stmt .)
    ;               reduce using rule 74 (stmt -> labeled_stmt .)
    {               reduce using rule 74 (stmt -> labeled_stmt .)
    IDENTIFIER      reduce using rule 74 (stmt -> labeled_stmt .)
    VOID            reduce using rule 74 (stmt -> labeled_stmt .)
    STRING_T        reduce using rule 74 (stmt -> labeled_stmt .)
    DOUBLE          reduce using rule 74 (stmt -> labeled_stmt .)
    INT             reduce using rule 74 (stmt -> labeled_stmt .)
    !               reduce using rule 74 (stmt -> labeled_stmt .)
    -               reduce using rule 74 (stmt -> labeled_stmt .)
    +               reduce using rule 74 (stmt -> labeled_stmt .)
    DEC             reduce using rule 74 (stmt -> labeled_stmt .)
    INC             reduce using rule 74 (stmt -> labeled_stmt .)
    (               reduce using rule 74 (stmt -> labeled_stmt .)
    FLOAT           reduce using rule 74 (stmt -> labeled_stmt .)
    INTEGER         reduce using rule 74 (stmt -> labeled_stmt .)
    ELSE            reduce using rule 74 (stmt -> labeled_stmt .)


state 74

    (88) jump_stmt -> RETURN . expr ;
    (89) jump_stmt -> RETURN . ;
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr < add_expr
    (33) rel_expr -> . rel_expr > add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    ;               shift and go to state 130
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    (               shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    expr                           shift and go to state 129
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 75

    (81) expr_stmt -> expr . ;
    ;               shift and go to state 131


state 76

    (82) expr_stmt -> ; .
    }               reduce using rule 82 (expr_stmt -> ; .)
    RETURN          reduce using rule 82 (expr_stmt -> ; .)
    BREAK           reduce using rule 82 (expr_stmt -> ; .)
    CONTINUE        reduce using rule 82 (expr_stmt -> ; .)
    GOTO            reduce using rule 82 (expr_stmt -> ; .)
    FOR             reduce using rule 82 (expr_stmt -> ; .)
    DO              reduce using rule 82 (expr_stmt -> ; .)
    WHILE           reduce using rule 82 (expr_stmt -> ; .)
    IF              reduce using rule 82 (expr_stmt -> ; .)
    ;               reduce using rule 82 (expr_stmt -> ; .)
    {               reduce using rule 82 (expr_stmt -> ; .)
    IDENTIFIER      reduce using rule 82 (expr_stmt -> ; .)
    VOID            reduce using rule 82 (expr_stmt -> ; .)
    STRING_T        reduce using rule 82 (expr_stmt -> ; .)
    DOUBLE          reduce using rule 82 (expr_stmt -> ; .)
    INT             reduce using rule 82 (expr_stmt -> ; .)
    !               reduce using rule 82 (expr_stmt -> ; .)
    -               reduce using rule 82 (expr_stmt -> ; .)
    +               reduce using rule 82 (expr_stmt -> ; .)
    DEC             reduce using rule 82 (expr_stmt -> ; .)
    INC             reduce using rule 82 (expr_stmt -> ; .)
    (               reduce using rule 82 (expr_stmt -> ; .)
    FLOAT           reduce using rule 82 (expr_stmt -> ; .)
    INTEGER         reduce using rule 82 (expr_stmt -> ; .)
    ELSE            reduce using rule 82 (expr_stmt -> ; .)


state 77

    (90) jump_stmt -> BREAK . ;
    ;               shift and go to state 132


state 78

    (91) jump_stmt -> CONTINUE . ;
    ;               shift and go to state 133


state 79

    (92) jump_stmt -> GOTO . IDENTIFIER ;
    IDENTIFIER      shift and go to state 134


state 80

    (75) labeled_stmt -> IDENTIFIER . : stmt
    (5) primary_expr -> IDENTIFIER .
    :               shift and go to state 135
    DEC             reduce using rule 5 (primary_expr -> IDENTIFIER .)
    INC             reduce using rule 5 (primary_expr -> IDENTIFIER .)
    .               reduce using rule 5 (primary_expr -> IDENTIFIER .)
    (               reduce using rule 5 (primary_expr -> IDENTIFIER .)
    [               reduce using rule 5 (primary_expr -> IDENTIFIER .)
    =               reduce using rule 5 (primary_expr -> IDENTIFIER .)
    MODEQ           reduce using rule 5 (primary_expr -> IDENTIFIER .)
    DIVEQ           reduce using rule 5 (primary_expr -> IDENTIFIER .)
    MULEQ           reduce using rule 5 (primary_expr -> IDENTIFIER .)
    MINUSEQ         reduce using rule 5 (primary_expr -> IDENTIFIER .)
    PLUSEQ          reduce using rule 5 (primary_expr -> IDENTIFIER .)
    %               reduce using rule 5 (primary_expr -> IDENTIFIER .)
    /               reduce using rule 5 (primary_expr -> IDENTIFIER .)
    *               reduce using rule 5 (primary_expr -> IDENTIFIER .)
    -               reduce using rule 5 (primary_expr -> IDENTIFIER .)
    +               reduce using rule 5 (primary_expr -> IDENTIFIER .)
    LE              reduce using rule 5 (primary_expr -> IDENTIFIER .)
    GE              reduce using rule 5 (primary_expr -> IDENTIFIER .)
    <               reduce using rule 5 (primary_expr -> IDENTIFIER .)
    >               reduce using rule 5 (primary_expr -> IDENTIFIER .)
    NE              reduce using rule 5 (primary_expr -> IDENTIFIER .)
    EQ              reduce using rule 5 (primary_expr -> IDENTIFIER .)
    AND             reduce using rule 5 (primary_expr -> IDENTIFIER .)
    OR              reduce using rule 5 (primary_expr -> IDENTIFIER .)
    ;               reduce using rule 5 (primary_expr -> IDENTIFIER .)


state 81

    (85) loop_stmt -> FOR . ( expr_stmt expr_stmt expr ) stmt
    (               shift and go to state 136


state 82

    (86) loop_stmt -> DO . stmt WHILE ( expr ) ;
    (69) stmt -> . jump_stmt
    (70) stmt -> . loop_stmt
    (71) stmt -> . if_stmt
    (72) stmt -> . expr_stmt
    (73) stmt -> . block_stmt
    (74) stmt -> . labeled_stmt
    (88) jump_stmt -> . RETURN expr ;
    (89) jump_stmt -> . RETURN ;
    (90) jump_stmt -> . BREAK ;
    (91) jump_stmt -> . CONTINUE ;
    (92) jump_stmt -> . GOTO IDENTIFIER ;
    (85) loop_stmt -> . FOR ( expr_stmt expr_stmt expr ) stmt
    (86) loop_stmt -> . DO stmt WHILE ( expr ) ;
    (87) loop_stmt -> . WHILE ( expr ) stmt
    (83) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (84) if_stmt -> . IF ( expr ) stmt
    (80) expr_stmt -> . decl
    (81) expr_stmt -> . expr ;
    (82) expr_stmt -> . ;
    (76) block_stmt -> . { stmt_list }
    (77) block_stmt -> . { }
    (75) labeled_stmt -> . IDENTIFIER : stmt
    (50) decl -> . type init_declarator ;
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr < add_expr
    (33) rel_expr -> . rel_expr > add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    RETURN          shift and go to state 74
    BREAK           shift and go to state 77
    CONTINUE        shift and go to state 78
    GOTO            shift and go to state 79
    FOR             shift and go to state 81
    DO              shift and go to state 82
    WHILE           shift and go to state 83
    IF              shift and go to state 84
    ;               shift and go to state 76
    {               shift and go to state 33
    IDENTIFIER      shift and go to state 80
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    (               shift and go to state 64
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    stmt                           shift and go to state 137
    expr                           shift and go to state 75
    jump_stmt                      shift and go to state 68
    loop_stmt                      shift and go to state 69
    if_stmt                        shift and go to state 70
    expr_stmt                      shift and go to state 71
    block_stmt                     shift and go to state 72
    labeled_stmt                   shift and go to state 73
    decl                           shift and go to state 85
    type                           shift and go to state 86
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 83

    (87) loop_stmt -> WHILE . ( expr ) stmt
    (               shift and go to state 138


state 84

    (83) if_stmt -> IF . ( expr ) stmt ELSE stmt
    (84) if_stmt -> IF . ( expr ) stmt
    (               shift and go to state 139


state 85

    (80) expr_stmt -> decl .
    }               reduce using rule 80 (expr_stmt -> decl .)
    RETURN          reduce using rule 80 (expr_stmt -> decl .)
    BREAK           reduce using rule 80 (expr_stmt -> decl .)
    CONTINUE        reduce using rule 80 (expr_stmt -> decl .)
    GOTO            reduce using rule 80 (expr_stmt -> decl .)
    FOR             reduce using rule 80 (expr_stmt -> decl .)
    DO              reduce using rule 80 (expr_stmt -> decl .)
    WHILE           reduce using rule 80 (expr_stmt -> decl .)
    IF              reduce using rule 80 (expr_stmt -> decl .)
    ;               reduce using rule 80 (expr_stmt -> decl .)
    {               reduce using rule 80 (expr_stmt -> decl .)
    IDENTIFIER      reduce using rule 80 (expr_stmt -> decl .)
    VOID            reduce using rule 80 (expr_stmt -> decl .)
    STRING_T        reduce using rule 80 (expr_stmt -> decl .)
    DOUBLE          reduce using rule 80 (expr_stmt -> decl .)
    INT             reduce using rule 80 (expr_stmt -> decl .)
    !               reduce using rule 80 (expr_stmt -> decl .)
    -               reduce using rule 80 (expr_stmt -> decl .)
    +               reduce using rule 80 (expr_stmt -> decl .)
    DEC             reduce using rule 80 (expr_stmt -> decl .)
    INC             reduce using rule 80 (expr_stmt -> decl .)
    (               reduce using rule 80 (expr_stmt -> decl .)
    FLOAT           reduce using rule 80 (expr_stmt -> decl .)
    INTEGER         reduce using rule 80 (expr_stmt -> decl .)
    ELSE            reduce using rule 80 (expr_stmt -> decl .)


state 86

    (50) decl -> type . init_declarator ;
    (51) init_declarator -> . declarator = initializer
    (52) init_declarator -> . declarator
    (57) declarator -> . declarator [ ]
    (58) declarator -> . declarator [ cond_expr ]
    (59) declarator -> . declarator ( )
    (60) declarator -> . declarator ( param_list )
    (61) declarator -> . IDENTIFIER
    IDENTIFIER      shift and go to state 22

    init_declarator                shift and go to state 21
    declarator                     shift and go to state 140

state 87

    (105) import_decl -> IMPORT IDENTIFIER INTEGER INTEGER STRING . IDENTIFIER
    IDENTIFIER      shift and go to state 141


state 88

    (58) declarator -> declarator [ cond_expr ] .
    [               reduce using rule 58 (declarator -> declarator [ cond_expr ] .)
    (               reduce using rule 58 (declarator -> declarator [ cond_expr ] .)
    =               reduce using rule 58 (declarator -> declarator [ cond_expr ] .)
    {               reduce using rule 58 (declarator -> declarator [ cond_expr ] .)
    ;               reduce using rule 58 (declarator -> declarator [ cond_expr ] .)
    )               reduce using rule 58 (declarator -> declarator [ cond_expr ] .)
    ,               reduce using rule 58 (declarator -> declarator [ cond_expr ] .)


state 89

    (40) cond_expr -> cond_expr OR . and_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr < add_expr
    (33) rel_expr -> . rel_expr > add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (               shift and go to state 47
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    and_expr                       shift and go to state 142
    eq_expr                        shift and go to state 39
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43
    cast_expr                      shift and go to state 45
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 90

    (38) and_expr -> and_expr AND . eq_expr
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr < add_expr
    (33) rel_expr -> . rel_expr > add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (               shift and go to state 47
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    eq_expr                        shift and go to state 143
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43
    cast_expr                      shift and go to state 45
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 91

    (35) eq_expr -> eq_expr NE . rel_expr
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr < add_expr
    (33) rel_expr -> . rel_expr > add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (               shift and go to state 47
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    rel_expr                       shift and go to state 144
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43
    cast_expr                      shift and go to state 45
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 92

    (36) eq_expr -> eq_expr EQ . rel_expr
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr < add_expr
    (33) rel_expr -> . rel_expr > add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (               shift and go to state 47
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    rel_expr                       shift and go to state 145
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43
    cast_expr                      shift and go to state 45
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 93

    (30) rel_expr -> rel_expr LE . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (               shift and go to state 47
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    add_expr                       shift and go to state 146
    mult_expr                      shift and go to state 43
    cast_expr                      shift and go to state 45
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 94

    (31) rel_expr -> rel_expr GE . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (               shift and go to state 47
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    add_expr                       shift and go to state 147
    mult_expr                      shift and go to state 43
    cast_expr                      shift and go to state 45
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 95

    (32) rel_expr -> rel_expr < . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (               shift and go to state 47
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    add_expr                       shift and go to state 148
    mult_expr                      shift and go to state 43
    cast_expr                      shift and go to state 45
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 96

    (33) rel_expr -> rel_expr > . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (               shift and go to state 47
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    add_expr                       shift and go to state 149
    mult_expr                      shift and go to state 43
    cast_expr                      shift and go to state 45
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 97

    (27) add_expr -> add_expr - . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (               shift and go to state 47
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    mult_expr                      shift and go to state 150
    cast_expr                      shift and go to state 45
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 98

    (28) add_expr -> add_expr + . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (               shift and go to state 47
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    mult_expr                      shift and go to state 151
    cast_expr                      shift and go to state 45
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 99

    (16) unary_expr -> - cast_expr .
    %               reduce using rule 16 (unary_expr -> - cast_expr .)
    /               reduce using rule 16 (unary_expr -> - cast_expr .)
    *               reduce using rule 16 (unary_expr -> - cast_expr .)
    -               reduce using rule 16 (unary_expr -> - cast_expr .)
    +               reduce using rule 16 (unary_expr -> - cast_expr .)
    LE              reduce using rule 16 (unary_expr -> - cast_expr .)
    GE              reduce using rule 16 (unary_expr -> - cast_expr .)
    <               reduce using rule 16 (unary_expr -> - cast_expr .)
    >               reduce using rule 16 (unary_expr -> - cast_expr .)
    NE              reduce using rule 16 (unary_expr -> - cast_expr .)
    EQ              reduce using rule 16 (unary_expr -> - cast_expr .)
    AND             reduce using rule 16 (unary_expr -> - cast_expr .)
    ]               reduce using rule 16 (unary_expr -> - cast_expr .)
    OR              reduce using rule 16 (unary_expr -> - cast_expr .)
    =               reduce using rule 16 (unary_expr -> - cast_expr .)
    MODEQ           reduce using rule 16 (unary_expr -> - cast_expr .)
    DIVEQ           reduce using rule 16 (unary_expr -> - cast_expr .)
    MULEQ           reduce using rule 16 (unary_expr -> - cast_expr .)
    MINUSEQ         reduce using rule 16 (unary_expr -> - cast_expr .)
    PLUSEQ          reduce using rule 16 (unary_expr -> - cast_expr .)
    ;               reduce using rule 16 (unary_expr -> - cast_expr .)
    )               reduce using rule 16 (unary_expr -> - cast_expr .)
    }               reduce using rule 16 (unary_expr -> - cast_expr .)
    ,               reduce using rule 16 (unary_expr -> - cast_expr .)


state 100

    (23) mult_expr -> mult_expr % . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (               shift and go to state 47
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    cast_expr                      shift and go to state 152
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 101

    (24) mult_expr -> mult_expr / . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (               shift and go to state 47
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    cast_expr                      shift and go to state 153
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 102

    (25) mult_expr -> mult_expr * . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (               shift and go to state 47
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    cast_expr                      shift and go to state 154
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 103

    (17) unary_expr -> + cast_expr .
    %               reduce using rule 17 (unary_expr -> + cast_expr .)
    /               reduce using rule 17 (unary_expr -> + cast_expr .)
    *               reduce using rule 17 (unary_expr -> + cast_expr .)
    -               reduce using rule 17 (unary_expr -> + cast_expr .)
    +               reduce using rule 17 (unary_expr -> + cast_expr .)
    LE              reduce using rule 17 (unary_expr -> + cast_expr .)
    GE              reduce using rule 17 (unary_expr -> + cast_expr .)
    <               reduce using rule 17 (unary_expr -> + cast_expr .)
    >               reduce using rule 17 (unary_expr -> + cast_expr .)
    NE              reduce using rule 17 (unary_expr -> + cast_expr .)
    EQ              reduce using rule 17 (unary_expr -> + cast_expr .)
    AND             reduce using rule 17 (unary_expr -> + cast_expr .)
    ]               reduce using rule 17 (unary_expr -> + cast_expr .)
    OR              reduce using rule 17 (unary_expr -> + cast_expr .)
    =               reduce using rule 17 (unary_expr -> + cast_expr .)
    MODEQ           reduce using rule 17 (unary_expr -> + cast_expr .)
    DIVEQ           reduce using rule 17 (unary_expr -> + cast_expr .)
    MULEQ           reduce using rule 17 (unary_expr -> + cast_expr .)
    MINUSEQ         reduce using rule 17 (unary_expr -> + cast_expr .)
    PLUSEQ          reduce using rule 17 (unary_expr -> + cast_expr .)
    ;               reduce using rule 17 (unary_expr -> + cast_expr .)
    )               reduce using rule 17 (unary_expr -> + cast_expr .)
    }               reduce using rule 17 (unary_expr -> + cast_expr .)
    ,               reduce using rule 17 (unary_expr -> + cast_expr .)


state 104

    (22) cast_expr -> ( type . ) cast_expr
    )               shift and go to state 155


state 105

    (3) primary_expr -> ( expr . )
    )               shift and go to state 156


state 106

    (15) unary_expr -> ! cast_expr .
    %               reduce using rule 15 (unary_expr -> ! cast_expr .)
    /               reduce using rule 15 (unary_expr -> ! cast_expr .)
    *               reduce using rule 15 (unary_expr -> ! cast_expr .)
    -               reduce using rule 15 (unary_expr -> ! cast_expr .)
    +               reduce using rule 15 (unary_expr -> ! cast_expr .)
    LE              reduce using rule 15 (unary_expr -> ! cast_expr .)
    GE              reduce using rule 15 (unary_expr -> ! cast_expr .)
    <               reduce using rule 15 (unary_expr -> ! cast_expr .)
    >               reduce using rule 15 (unary_expr -> ! cast_expr .)
    NE              reduce using rule 15 (unary_expr -> ! cast_expr .)
    EQ              reduce using rule 15 (unary_expr -> ! cast_expr .)
    AND             reduce using rule 15 (unary_expr -> ! cast_expr .)
    ]               reduce using rule 15 (unary_expr -> ! cast_expr .)
    OR              reduce using rule 15 (unary_expr -> ! cast_expr .)
    =               reduce using rule 15 (unary_expr -> ! cast_expr .)
    MODEQ           reduce using rule 15 (unary_expr -> ! cast_expr .)
    DIVEQ           reduce using rule 15 (unary_expr -> ! cast_expr .)
    MULEQ           reduce using rule 15 (unary_expr -> ! cast_expr .)
    MINUSEQ         reduce using rule 15 (unary_expr -> ! cast_expr .)
    PLUSEQ          reduce using rule 15 (unary_expr -> ! cast_expr .)
    ;               reduce using rule 15 (unary_expr -> ! cast_expr .)
    )               reduce using rule 15 (unary_expr -> ! cast_expr .)
    }               reduce using rule 15 (unary_expr -> ! cast_expr .)
    ,               reduce using rule 15 (unary_expr -> ! cast_expr .)


state 107

    (18) unary_expr -> DEC unary_expr .
    %               reduce using rule 18 (unary_expr -> DEC unary_expr .)
    /               reduce using rule 18 (unary_expr -> DEC unary_expr .)
    *               reduce using rule 18 (unary_expr -> DEC unary_expr .)
    -               reduce using rule 18 (unary_expr -> DEC unary_expr .)
    +               reduce using rule 18 (unary_expr -> DEC unary_expr .)
    LE              reduce using rule 18 (unary_expr -> DEC unary_expr .)
    GE              reduce using rule 18 (unary_expr -> DEC unary_expr .)
    <               reduce using rule 18 (unary_expr -> DEC unary_expr .)
    >               reduce using rule 18 (unary_expr -> DEC unary_expr .)
    NE              reduce using rule 18 (unary_expr -> DEC unary_expr .)
    EQ              reduce using rule 18 (unary_expr -> DEC unary_expr .)
    AND             reduce using rule 18 (unary_expr -> DEC unary_expr .)
    ]               reduce using rule 18 (unary_expr -> DEC unary_expr .)
    OR              reduce using rule 18 (unary_expr -> DEC unary_expr .)
    =               reduce using rule 18 (unary_expr -> DEC unary_expr .)
    MODEQ           reduce using rule 18 (unary_expr -> DEC unary_expr .)
    DIVEQ           reduce using rule 18 (unary_expr -> DEC unary_expr .)
    MULEQ           reduce using rule 18 (unary_expr -> DEC unary_expr .)
    MINUSEQ         reduce using rule 18 (unary_expr -> DEC unary_expr .)
    PLUSEQ          reduce using rule 18 (unary_expr -> DEC unary_expr .)
    ;               reduce using rule 18 (unary_expr -> DEC unary_expr .)
    )               reduce using rule 18 (unary_expr -> DEC unary_expr .)
    }               reduce using rule 18 (unary_expr -> DEC unary_expr .)
    ,               reduce using rule 18 (unary_expr -> DEC unary_expr .)


state 108

    (3) primary_expr -> ( . expr )
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr < add_expr
    (33) rel_expr -> . rel_expr > add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    (               shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    expr                           shift and go to state 105
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 109

    (19) unary_expr -> INC unary_expr .
    %               reduce using rule 19 (unary_expr -> INC unary_expr .)
    /               reduce using rule 19 (unary_expr -> INC unary_expr .)
    *               reduce using rule 19 (unary_expr -> INC unary_expr .)
    -               reduce using rule 19 (unary_expr -> INC unary_expr .)
    +               reduce using rule 19 (unary_expr -> INC unary_expr .)
    LE              reduce using rule 19 (unary_expr -> INC unary_expr .)
    GE              reduce using rule 19 (unary_expr -> INC unary_expr .)
    <               reduce using rule 19 (unary_expr -> INC unary_expr .)
    >               reduce using rule 19 (unary_expr -> INC unary_expr .)
    NE              reduce using rule 19 (unary_expr -> INC unary_expr .)
    EQ              reduce using rule 19 (unary_expr -> INC unary_expr .)
    AND             reduce using rule 19 (unary_expr -> INC unary_expr .)
    ]               reduce using rule 19 (unary_expr -> INC unary_expr .)
    OR              reduce using rule 19 (unary_expr -> INC unary_expr .)
    =               reduce using rule 19 (unary_expr -> INC unary_expr .)
    MODEQ           reduce using rule 19 (unary_expr -> INC unary_expr .)
    DIVEQ           reduce using rule 19 (unary_expr -> INC unary_expr .)
    MULEQ           reduce using rule 19 (unary_expr -> INC unary_expr .)
    MINUSEQ         reduce using rule 19 (unary_expr -> INC unary_expr .)
    PLUSEQ          reduce using rule 19 (unary_expr -> INC unary_expr .)
    ;               reduce using rule 19 (unary_expr -> INC unary_expr .)
    )               reduce using rule 19 (unary_expr -> INC unary_expr .)
    }               reduce using rule 19 (unary_expr -> INC unary_expr .)
    ,               reduce using rule 19 (unary_expr -> INC unary_expr .)


state 110

    (6) postfix_expr -> postfix_expr DEC .
    DEC             reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    INC             reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    .               reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    (               reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    [               reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    %               reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    /               reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    *               reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    -               reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    +               reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    LE              reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    GE              reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    <               reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    >               reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    NE              reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    EQ              reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    AND             reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    ]               reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    OR              reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    =               reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    MODEQ           reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    DIVEQ           reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    MULEQ           reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    MINUSEQ         reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    PLUSEQ          reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    ;               reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    )               reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    }               reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    ,               reduce using rule 6 (postfix_expr -> postfix_expr DEC .)


state 111

    (7) postfix_expr -> postfix_expr INC .
    DEC             reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    INC             reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    .               reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    (               reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    [               reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    %               reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    /               reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    *               reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    -               reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    +               reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    LE              reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    GE              reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    <               reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    >               reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    NE              reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    EQ              reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    AND             reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    ]               reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    OR              reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    =               reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    MODEQ           reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    DIVEQ           reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    MULEQ           reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    MINUSEQ         reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    PLUSEQ          reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    ;               reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    )               reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    }               reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    ,               reduce using rule 7 (postfix_expr -> postfix_expr INC .)


state 112

    (8) postfix_expr -> postfix_expr . . IDENTIFIER
    IDENTIFIER      shift and go to state 157


state 113

    (9) postfix_expr -> postfix_expr ( . arg_expr_list )
    (10) postfix_expr -> postfix_expr ( . )
    (13) arg_expr_list -> . arg_expr_list , expr
    (14) arg_expr_list -> . expr
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr < add_expr
    (33) rel_expr -> . rel_expr > add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    )               shift and go to state 159
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    (               shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    postfix_expr                   shift and go to state 51
    arg_expr_list                  shift and go to state 158
    expr                           shift and go to state 160
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 114

    (11) postfix_expr -> postfix_expr [ . expr ]
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr < add_expr
    (33) rel_expr -> . rel_expr > add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    (               shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    postfix_expr                   shift and go to state 51
    expr                           shift and go to state 161
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 115

    (60) declarator -> declarator ( param_list ) .
    [               reduce using rule 60 (declarator -> declarator ( param_list ) .)
    (               reduce using rule 60 (declarator -> declarator ( param_list ) .)
    =               reduce using rule 60 (declarator -> declarator ( param_list ) .)
    {               reduce using rule 60 (declarator -> declarator ( param_list ) .)
    ;               reduce using rule 60 (declarator -> declarator ( param_list ) .)
    )               reduce using rule 60 (declarator -> declarator ( param_list ) .)
    ,               reduce using rule 60 (declarator -> declarator ( param_list ) .)


state 116

    (62) param_list -> param_list , . param_decl
    (64) param_decl -> . type declarator
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15

    param_decl                     shift and go to state 162
    type                           shift and go to state 58

state 117

    (64) param_decl -> type declarator .
    (57) declarator -> declarator . [ ]
    (58) declarator -> declarator . [ cond_expr ]
    (59) declarator -> declarator . ( )
    (60) declarator -> declarator . ( param_list )
    )               reduce using rule 64 (param_decl -> type declarator .)
    ,               reduce using rule 64 (param_decl -> type declarator .)
    [               shift and go to state 30
    (               shift and go to state 31


state 118

    (65) initializer -> { initializer_list . }
    (67) initializer_list -> initializer_list . , initializer
    }               shift and go to state 163
    ,               shift and go to state 164


state 119

    (68) initializer_list -> initializer .
    }               reduce using rule 68 (initializer_list -> initializer .)
    ,               reduce using rule 68 (initializer_list -> initializer .)


state 120

    (42) expr -> unary_expr assignment_op . expr
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr < add_expr
    (33) rel_expr -> . rel_expr > add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    (               shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    unary_expr                     shift and go to state 62
    expr                           shift and go to state 165
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 121

    (44) assignment_op -> = .
    !               reduce using rule 44 (assignment_op -> = .)
    -               reduce using rule 44 (assignment_op -> = .)
    +               reduce using rule 44 (assignment_op -> = .)
    DEC             reduce using rule 44 (assignment_op -> = .)
    INC             reduce using rule 44 (assignment_op -> = .)
    (               reduce using rule 44 (assignment_op -> = .)
    IDENTIFIER      reduce using rule 44 (assignment_op -> = .)
    FLOAT           reduce using rule 44 (assignment_op -> = .)
    INTEGER         reduce using rule 44 (assignment_op -> = .)


state 122

    (45) assignment_op -> MODEQ .
    !               reduce using rule 45 (assignment_op -> MODEQ .)
    -               reduce using rule 45 (assignment_op -> MODEQ .)
    +               reduce using rule 45 (assignment_op -> MODEQ .)
    DEC             reduce using rule 45 (assignment_op -> MODEQ .)
    INC             reduce using rule 45 (assignment_op -> MODEQ .)
    (               reduce using rule 45 (assignment_op -> MODEQ .)
    IDENTIFIER      reduce using rule 45 (assignment_op -> MODEQ .)
    FLOAT           reduce using rule 45 (assignment_op -> MODEQ .)
    INTEGER         reduce using rule 45 (assignment_op -> MODEQ .)


state 123

    (46) assignment_op -> DIVEQ .
    !               reduce using rule 46 (assignment_op -> DIVEQ .)
    -               reduce using rule 46 (assignment_op -> DIVEQ .)
    +               reduce using rule 46 (assignment_op -> DIVEQ .)
    DEC             reduce using rule 46 (assignment_op -> DIVEQ .)
    INC             reduce using rule 46 (assignment_op -> DIVEQ .)
    (               reduce using rule 46 (assignment_op -> DIVEQ .)
    IDENTIFIER      reduce using rule 46 (assignment_op -> DIVEQ .)
    FLOAT           reduce using rule 46 (assignment_op -> DIVEQ .)
    INTEGER         reduce using rule 46 (assignment_op -> DIVEQ .)


state 124

    (47) assignment_op -> MULEQ .
    !               reduce using rule 47 (assignment_op -> MULEQ .)
    -               reduce using rule 47 (assignment_op -> MULEQ .)
    +               reduce using rule 47 (assignment_op -> MULEQ .)
    DEC             reduce using rule 47 (assignment_op -> MULEQ .)
    INC             reduce using rule 47 (assignment_op -> MULEQ .)
    (               reduce using rule 47 (assignment_op -> MULEQ .)
    IDENTIFIER      reduce using rule 47 (assignment_op -> MULEQ .)
    FLOAT           reduce using rule 47 (assignment_op -> MULEQ .)
    INTEGER         reduce using rule 47 (assignment_op -> MULEQ .)


state 125

    (48) assignment_op -> MINUSEQ .
    !               reduce using rule 48 (assignment_op -> MINUSEQ .)
    -               reduce using rule 48 (assignment_op -> MINUSEQ .)
    +               reduce using rule 48 (assignment_op -> MINUSEQ .)
    DEC             reduce using rule 48 (assignment_op -> MINUSEQ .)
    INC             reduce using rule 48 (assignment_op -> MINUSEQ .)
    (               reduce using rule 48 (assignment_op -> MINUSEQ .)
    IDENTIFIER      reduce using rule 48 (assignment_op -> MINUSEQ .)
    FLOAT           reduce using rule 48 (assignment_op -> MINUSEQ .)
    INTEGER         reduce using rule 48 (assignment_op -> MINUSEQ .)


state 126

    (49) assignment_op -> PLUSEQ .
    !               reduce using rule 49 (assignment_op -> PLUSEQ .)
    -               reduce using rule 49 (assignment_op -> PLUSEQ .)
    +               reduce using rule 49 (assignment_op -> PLUSEQ .)
    DEC             reduce using rule 49 (assignment_op -> PLUSEQ .)
    INC             reduce using rule 49 (assignment_op -> PLUSEQ .)
    (               reduce using rule 49 (assignment_op -> PLUSEQ .)
    IDENTIFIER      reduce using rule 49 (assignment_op -> PLUSEQ .)
    FLOAT           reduce using rule 49 (assignment_op -> PLUSEQ .)
    INTEGER         reduce using rule 49 (assignment_op -> PLUSEQ .)


state 127

    (76) block_stmt -> { stmt_list } .
    IMPORT          reduce using rule 76 (block_stmt -> { stmt_list } .)
    DEFINE          reduce using rule 76 (block_stmt -> { stmt_list } .)
    INCLUDE         reduce using rule 76 (block_stmt -> { stmt_list } .)
    VOID            reduce using rule 76 (block_stmt -> { stmt_list } .)
    STRING_T        reduce using rule 76 (block_stmt -> { stmt_list } .)
    DOUBLE          reduce using rule 76 (block_stmt -> { stmt_list } .)
    INT             reduce using rule 76 (block_stmt -> { stmt_list } .)
    $end            reduce using rule 76 (block_stmt -> { stmt_list } .)
    }               reduce using rule 76 (block_stmt -> { stmt_list } .)
    RETURN          reduce using rule 76 (block_stmt -> { stmt_list } .)
    BREAK           reduce using rule 76 (block_stmt -> { stmt_list } .)
    CONTINUE        reduce using rule 76 (block_stmt -> { stmt_list } .)
    GOTO            reduce using rule 76 (block_stmt -> { stmt_list } .)
    FOR             reduce using rule 76 (block_stmt -> { stmt_list } .)
    DO              reduce using rule 76 (block_stmt -> { stmt_list } .)
    WHILE           reduce using rule 76 (block_stmt -> { stmt_list } .)
    IF              reduce using rule 76 (block_stmt -> { stmt_list } .)
    ;               reduce using rule 76 (block_stmt -> { stmt_list } .)
    {               reduce using rule 76 (block_stmt -> { stmt_list } .)
    IDENTIFIER      reduce using rule 76 (block_stmt -> { stmt_list } .)
    !               reduce using rule 76 (block_stmt -> { stmt_list } .)
    -               reduce using rule 76 (block_stmt -> { stmt_list } .)
    +               reduce using rule 76 (block_stmt -> { stmt_list } .)
    DEC             reduce using rule 76 (block_stmt -> { stmt_list } .)
    INC             reduce using rule 76 (block_stmt -> { stmt_list } .)
    (               reduce using rule 76 (block_stmt -> { stmt_list } .)
    FLOAT           reduce using rule 76 (block_stmt -> { stmt_list } .)
    INTEGER         reduce using rule 76 (block_stmt -> { stmt_list } .)
    ELSE            reduce using rule 76 (block_stmt -> { stmt_list } .)


state 128

    (78) stmt_list -> stmt_list stmt .
    }               reduce using rule 78 (stmt_list -> stmt_list stmt .)
    RETURN          reduce using rule 78 (stmt_list -> stmt_list stmt .)
    BREAK           reduce using rule 78 (stmt_list -> stmt_list stmt .)
    CONTINUE        reduce using rule 78 (stmt_list -> stmt_list stmt .)
    GOTO            reduce using rule 78 (stmt_list -> stmt_list stmt .)
    FOR             reduce using rule 78 (stmt_list -> stmt_list stmt .)
    DO              reduce using rule 78 (stmt_list -> stmt_list stmt .)
    WHILE           reduce using rule 78 (stmt_list -> stmt_list stmt .)
    IF              reduce using rule 78 (stmt_list -> stmt_list stmt .)
    ;               reduce using rule 78 (stmt_list -> stmt_list stmt .)
    {               reduce using rule 78 (stmt_list -> stmt_list stmt .)
    IDENTIFIER      reduce using rule 78 (stmt_list -> stmt_list stmt .)
    VOID            reduce using rule 78 (stmt_list -> stmt_list stmt .)
    STRING_T        reduce using rule 78 (stmt_list -> stmt_list stmt .)
    DOUBLE          reduce using rule 78 (stmt_list -> stmt_list stmt .)
    INT             reduce using rule 78 (stmt_list -> stmt_list stmt .)
    !               reduce using rule 78 (stmt_list -> stmt_list stmt .)
    -               reduce using rule 78 (stmt_list -> stmt_list stmt .)
    +               reduce using rule 78 (stmt_list -> stmt_list stmt .)
    DEC             reduce using rule 78 (stmt_list -> stmt_list stmt .)
    INC             reduce using rule 78 (stmt_list -> stmt_list stmt .)
    (               reduce using rule 78 (stmt_list -> stmt_list stmt .)
    FLOAT           reduce using rule 78 (stmt_list -> stmt_list stmt .)
    INTEGER         reduce using rule 78 (stmt_list -> stmt_list stmt .)


state 129

    (88) jump_stmt -> RETURN expr . ;
    ;               shift and go to state 166


state 130

    (89) jump_stmt -> RETURN ; .
    }               reduce using rule 89 (jump_stmt -> RETURN ; .)
    RETURN          reduce using rule 89 (jump_stmt -> RETURN ; .)
    BREAK           reduce using rule 89 (jump_stmt -> RETURN ; .)
    CONTINUE        reduce using rule 89 (jump_stmt -> RETURN ; .)
    GOTO            reduce using rule 89 (jump_stmt -> RETURN ; .)
    FOR             reduce using rule 89 (jump_stmt -> RETURN ; .)
    DO              reduce using rule 89 (jump_stmt -> RETURN ; .)
    WHILE           reduce using rule 89 (jump_stmt -> RETURN ; .)
    IF              reduce using rule 89 (jump_stmt -> RETURN ; .)
    ;               reduce using rule 89 (jump_stmt -> RETURN ; .)
    {               reduce using rule 89 (jump_stmt -> RETURN ; .)
    IDENTIFIER      reduce using rule 89 (jump_stmt -> RETURN ; .)
    VOID            reduce using rule 89 (jump_stmt -> RETURN ; .)
    STRING_T        reduce using rule 89 (jump_stmt -> RETURN ; .)
    DOUBLE          reduce using rule 89 (jump_stmt -> RETURN ; .)
    INT             reduce using rule 89 (jump_stmt -> RETURN ; .)
    !               reduce using rule 89 (jump_stmt -> RETURN ; .)
    -               reduce using rule 89 (jump_stmt -> RETURN ; .)
    +               reduce using rule 89 (jump_stmt -> RETURN ; .)
    DEC             reduce using rule 89 (jump_stmt -> RETURN ; .)
    INC             reduce using rule 89 (jump_stmt -> RETURN ; .)
    (               reduce using rule 89 (jump_stmt -> RETURN ; .)
    FLOAT           reduce using rule 89 (jump_stmt -> RETURN ; .)
    INTEGER         reduce using rule 89 (jump_stmt -> RETURN ; .)
    ELSE            reduce using rule 89 (jump_stmt -> RETURN ; .)


state 131

    (81) expr_stmt -> expr ; .
    }               reduce using rule 81 (expr_stmt -> expr ; .)
    RETURN          reduce using rule 81 (expr_stmt -> expr ; .)
    BREAK           reduce using rule 81 (expr_stmt -> expr ; .)
    CONTINUE        reduce using rule 81 (expr_stmt -> expr ; .)
    GOTO            reduce using rule 81 (expr_stmt -> expr ; .)
    FOR             reduce using rule 81 (expr_stmt -> expr ; .)
    DO              reduce using rule 81 (expr_stmt -> expr ; .)
    WHILE           reduce using rule 81 (expr_stmt -> expr ; .)
    IF              reduce using rule 81 (expr_stmt -> expr ; .)
    ;               reduce using rule 81 (expr_stmt -> expr ; .)
    {               reduce using rule 81 (expr_stmt -> expr ; .)
    IDENTIFIER      reduce using rule 81 (expr_stmt -> expr ; .)
    VOID            reduce using rule 81 (expr_stmt -> expr ; .)
    STRING_T        reduce using rule 81 (expr_stmt -> expr ; .)
    DOUBLE          reduce using rule 81 (expr_stmt -> expr ; .)
    INT             reduce using rule 81 (expr_stmt -> expr ; .)
    !               reduce using rule 81 (expr_stmt -> expr ; .)
    -               reduce using rule 81 (expr_stmt -> expr ; .)
    +               reduce using rule 81 (expr_stmt -> expr ; .)
    DEC             reduce using rule 81 (expr_stmt -> expr ; .)
    INC             reduce using rule 81 (expr_stmt -> expr ; .)
    (               reduce using rule 81 (expr_stmt -> expr ; .)
    FLOAT           reduce using rule 81 (expr_stmt -> expr ; .)
    INTEGER         reduce using rule 81 (expr_stmt -> expr ; .)
    ELSE            reduce using rule 81 (expr_stmt -> expr ; .)


state 132

    (90) jump_stmt -> BREAK ; .
    }               reduce using rule 90 (jump_stmt -> BREAK ; .)
    RETURN          reduce using rule 90 (jump_stmt -> BREAK ; .)
    BREAK           reduce using rule 90 (jump_stmt -> BREAK ; .)
    CONTINUE        reduce using rule 90 (jump_stmt -> BREAK ; .)
    GOTO            reduce using rule 90 (jump_stmt -> BREAK ; .)
    FOR             reduce using rule 90 (jump_stmt -> BREAK ; .)
    DO              reduce using rule 90 (jump_stmt -> BREAK ; .)
    WHILE           reduce using rule 90 (jump_stmt -> BREAK ; .)
    IF              reduce using rule 90 (jump_stmt -> BREAK ; .)
    ;               reduce using rule 90 (jump_stmt -> BREAK ; .)
    {               reduce using rule 90 (jump_stmt -> BREAK ; .)
    IDENTIFIER      reduce using rule 90 (jump_stmt -> BREAK ; .)
    VOID            reduce using rule 90 (jump_stmt -> BREAK ; .)
    STRING_T        reduce using rule 90 (jump_stmt -> BREAK ; .)
    DOUBLE          reduce using rule 90 (jump_stmt -> BREAK ; .)
    INT             reduce using rule 90 (jump_stmt -> BREAK ; .)
    !               reduce using rule 90 (jump_stmt -> BREAK ; .)
    -               reduce using rule 90 (jump_stmt -> BREAK ; .)
    +               reduce using rule 90 (jump_stmt -> BREAK ; .)
    DEC             reduce using rule 90 (jump_stmt -> BREAK ; .)
    INC             reduce using rule 90 (jump_stmt -> BREAK ; .)
    (               reduce using rule 90 (jump_stmt -> BREAK ; .)
    FLOAT           reduce using rule 90 (jump_stmt -> BREAK ; .)
    INTEGER         reduce using rule 90 (jump_stmt -> BREAK ; .)
    ELSE            reduce using rule 90 (jump_stmt -> BREAK ; .)


state 133

    (91) jump_stmt -> CONTINUE ; .
    }               reduce using rule 91 (jump_stmt -> CONTINUE ; .)
    RETURN          reduce using rule 91 (jump_stmt -> CONTINUE ; .)
    BREAK           reduce using rule 91 (jump_stmt -> CONTINUE ; .)
    CONTINUE        reduce using rule 91 (jump_stmt -> CONTINUE ; .)
    GOTO            reduce using rule 91 (jump_stmt -> CONTINUE ; .)
    FOR             reduce using rule 91 (jump_stmt -> CONTINUE ; .)
    DO              reduce using rule 91 (jump_stmt -> CONTINUE ; .)
    WHILE           reduce using rule 91 (jump_stmt -> CONTINUE ; .)
    IF              reduce using rule 91 (jump_stmt -> CONTINUE ; .)
    ;               reduce using rule 91 (jump_stmt -> CONTINUE ; .)
    {               reduce using rule 91 (jump_stmt -> CONTINUE ; .)
    IDENTIFIER      reduce using rule 91 (jump_stmt -> CONTINUE ; .)
    VOID            reduce using rule 91 (jump_stmt -> CONTINUE ; .)
    STRING_T        reduce using rule 91 (jump_stmt -> CONTINUE ; .)
    DOUBLE          reduce using rule 91 (jump_stmt -> CONTINUE ; .)
    INT             reduce using rule 91 (jump_stmt -> CONTINUE ; .)
    !               reduce using rule 91 (jump_stmt -> CONTINUE ; .)
    -               reduce using rule 91 (jump_stmt -> CONTINUE ; .)
    +               reduce using rule 91 (jump_stmt -> CONTINUE ; .)
    DEC             reduce using rule 91 (jump_stmt -> CONTINUE ; .)
    INC             reduce using rule 91 (jump_stmt -> CONTINUE ; .)
    (               reduce using rule 91 (jump_stmt -> CONTINUE ; .)
    FLOAT           reduce using rule 91 (jump_stmt -> CONTINUE ; .)
    INTEGER         reduce using rule 91 (jump_stmt -> CONTINUE ; .)
    ELSE            reduce using rule 91 (jump_stmt -> CONTINUE ; .)


state 134

    (92) jump_stmt -> GOTO IDENTIFIER . ;
    ;               shift and go to state 167


state 135

    (75) labeled_stmt -> IDENTIFIER : . stmt
    (69) stmt -> . jump_stmt
    (70) stmt -> . loop_stmt
    (71) stmt -> . if_stmt
    (72) stmt -> . expr_stmt
    (73) stmt -> . block_stmt
    (74) stmt -> . labeled_stmt
    (88) jump_stmt -> . RETURN expr ;
    (89) jump_stmt -> . RETURN ;
    (90) jump_stmt -> . BREAK ;
    (91) jump_stmt -> . CONTINUE ;
    (92) jump_stmt -> . GOTO IDENTIFIER ;
    (85) loop_stmt -> . FOR ( expr_stmt expr_stmt expr ) stmt
    (86) loop_stmt -> . DO stmt WHILE ( expr ) ;
    (87) loop_stmt -> . WHILE ( expr ) stmt
    (83) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (84) if_stmt -> . IF ( expr ) stmt
    (80) expr_stmt -> . decl
    (81) expr_stmt -> . expr ;
    (82) expr_stmt -> . ;
    (76) block_stmt -> . { stmt_list }
    (77) block_stmt -> . { }
    (75) labeled_stmt -> . IDENTIFIER : stmt
    (50) decl -> . type init_declarator ;
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr < add_expr
    (33) rel_expr -> . rel_expr > add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    RETURN          shift and go to state 74
    BREAK           shift and go to state 77
    CONTINUE        shift and go to state 78
    GOTO            shift and go to state 79
    FOR             shift and go to state 81
    DO              shift and go to state 82
    WHILE           shift and go to state 83
    IF              shift and go to state 84
    ;               shift and go to state 76
    {               shift and go to state 33
    IDENTIFIER      shift and go to state 80
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    (               shift and go to state 64
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    stmt                           shift and go to state 168
    jump_stmt                      shift and go to state 68
    loop_stmt                      shift and go to state 69
    if_stmt                        shift and go to state 70
    expr_stmt                      shift and go to state 71
    block_stmt                     shift and go to state 72
    labeled_stmt                   shift and go to state 73
    expr                           shift and go to state 75
    decl                           shift and go to state 85
    type                           shift and go to state 86
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 136

    (85) loop_stmt -> FOR ( . expr_stmt expr_stmt expr ) stmt
    (80) expr_stmt -> . decl
    (81) expr_stmt -> . expr ;
    (82) expr_stmt -> . ;
    (50) decl -> . type init_declarator ;
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr < add_expr
    (33) rel_expr -> . rel_expr > add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    ;               shift and go to state 76
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    (               shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    expr_stmt                      shift and go to state 169
    expr                           shift and go to state 75
    decl                           shift and go to state 85
    type                           shift and go to state 86
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 137

    (86) loop_stmt -> DO stmt . WHILE ( expr ) ;
    WHILE           shift and go to state 170


state 138

    (87) loop_stmt -> WHILE ( . expr ) stmt
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr < add_expr
    (33) rel_expr -> . rel_expr > add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    (               shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    expr                           shift and go to state 171
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 139

    (83) if_stmt -> IF ( . expr ) stmt ELSE stmt
    (84) if_stmt -> IF ( . expr ) stmt
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr < add_expr
    (33) rel_expr -> . rel_expr > add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    (               shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    expr                           shift and go to state 172
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 140

    (51) init_declarator -> declarator . = initializer
    (52) init_declarator -> declarator .
    (57) declarator -> declarator . [ ]
    (58) declarator -> declarator . [ cond_expr ]
    (59) declarator -> declarator . ( )
    (60) declarator -> declarator . ( param_list )
    =               shift and go to state 32
    ;               reduce using rule 52 (init_declarator -> declarator .)
    [               shift and go to state 30
    (               shift and go to state 31


state 141

    (105) import_decl -> IMPORT IDENTIFIER INTEGER INTEGER STRING IDENTIFIER .
    IMPORT          reduce using rule 105 (import_decl -> IMPORT IDENTIFIER INTEGER INTEGER STRING IDENTIFIER .)
    DEFINE          reduce using rule 105 (import_decl -> IMPORT IDENTIFIER INTEGER INTEGER STRING IDENTIFIER .)
    INCLUDE         reduce using rule 105 (import_decl -> IMPORT IDENTIFIER INTEGER INTEGER STRING IDENTIFIER .)
    VOID            reduce using rule 105 (import_decl -> IMPORT IDENTIFIER INTEGER INTEGER STRING IDENTIFIER .)
    STRING_T        reduce using rule 105 (import_decl -> IMPORT IDENTIFIER INTEGER INTEGER STRING IDENTIFIER .)
    DOUBLE          reduce using rule 105 (import_decl -> IMPORT IDENTIFIER INTEGER INTEGER STRING IDENTIFIER .)
    INT             reduce using rule 105 (import_decl -> IMPORT IDENTIFIER INTEGER INTEGER STRING IDENTIFIER .)
    $end            reduce using rule 105 (import_decl -> IMPORT IDENTIFIER INTEGER INTEGER STRING IDENTIFIER .)


state 142

    (40) cond_expr -> cond_expr OR and_expr .
    (38) and_expr -> and_expr . AND eq_expr
    ]               reduce using rule 40 (cond_expr -> cond_expr OR and_expr .)
    OR              reduce using rule 40 (cond_expr -> cond_expr OR and_expr .)
    ;               reduce using rule 40 (cond_expr -> cond_expr OR and_expr .)
    )               reduce using rule 40 (cond_expr -> cond_expr OR and_expr .)
    }               reduce using rule 40 (cond_expr -> cond_expr OR and_expr .)
    ,               reduce using rule 40 (cond_expr -> cond_expr OR and_expr .)
    AND             shift and go to state 90


state 143

    (38) and_expr -> and_expr AND eq_expr .
    (35) eq_expr -> eq_expr . NE rel_expr
    (36) eq_expr -> eq_expr . EQ rel_expr
    AND             reduce using rule 38 (and_expr -> and_expr AND eq_expr .)
    ]               reduce using rule 38 (and_expr -> and_expr AND eq_expr .)
    OR              reduce using rule 38 (and_expr -> and_expr AND eq_expr .)
    ;               reduce using rule 38 (and_expr -> and_expr AND eq_expr .)
    )               reduce using rule 38 (and_expr -> and_expr AND eq_expr .)
    }               reduce using rule 38 (and_expr -> and_expr AND eq_expr .)
    ,               reduce using rule 38 (and_expr -> and_expr AND eq_expr .)
    NE              shift and go to state 91
    EQ              shift and go to state 92


state 144

    (35) eq_expr -> eq_expr NE rel_expr .
    (30) rel_expr -> rel_expr . LE add_expr
    (31) rel_expr -> rel_expr . GE add_expr
    (32) rel_expr -> rel_expr . < add_expr
    (33) rel_expr -> rel_expr . > add_expr
    NE              reduce using rule 35 (eq_expr -> eq_expr NE rel_expr .)
    EQ              reduce using rule 35 (eq_expr -> eq_expr NE rel_expr .)
    AND             reduce using rule 35 (eq_expr -> eq_expr NE rel_expr .)
    ]               reduce using rule 35 (eq_expr -> eq_expr NE rel_expr .)
    OR              reduce using rule 35 (eq_expr -> eq_expr NE rel_expr .)
    ;               reduce using rule 35 (eq_expr -> eq_expr NE rel_expr .)
    )               reduce using rule 35 (eq_expr -> eq_expr NE rel_expr .)
    }               reduce using rule 35 (eq_expr -> eq_expr NE rel_expr .)
    ,               reduce using rule 35 (eq_expr -> eq_expr NE rel_expr .)
    LE              shift and go to state 93
    GE              shift and go to state 94
    <               shift and go to state 95
    >               shift and go to state 96


state 145

    (36) eq_expr -> eq_expr EQ rel_expr .
    (30) rel_expr -> rel_expr . LE add_expr
    (31) rel_expr -> rel_expr . GE add_expr
    (32) rel_expr -> rel_expr . < add_expr
    (33) rel_expr -> rel_expr . > add_expr
    NE              reduce using rule 36 (eq_expr -> eq_expr EQ rel_expr .)
    EQ              reduce using rule 36 (eq_expr -> eq_expr EQ rel_expr .)
    AND             reduce using rule 36 (eq_expr -> eq_expr EQ rel_expr .)
    ]               reduce using rule 36 (eq_expr -> eq_expr EQ rel_expr .)
    OR              reduce using rule 36 (eq_expr -> eq_expr EQ rel_expr .)
    ;               reduce using rule 36 (eq_expr -> eq_expr EQ rel_expr .)
    )               reduce using rule 36 (eq_expr -> eq_expr EQ rel_expr .)
    }               reduce using rule 36 (eq_expr -> eq_expr EQ rel_expr .)
    ,               reduce using rule 36 (eq_expr -> eq_expr EQ rel_expr .)
    LE              shift and go to state 93
    GE              shift and go to state 94
    <               shift and go to state 95
    >               shift and go to state 96


state 146

    (30) rel_expr -> rel_expr LE add_expr .
    (27) add_expr -> add_expr . - mult_expr
    (28) add_expr -> add_expr . + mult_expr
    LE              reduce using rule 30 (rel_expr -> rel_expr LE add_expr .)
    GE              reduce using rule 30 (rel_expr -> rel_expr LE add_expr .)
    <               reduce using rule 30 (rel_expr -> rel_expr LE add_expr .)
    >               reduce using rule 30 (rel_expr -> rel_expr LE add_expr .)
    NE              reduce using rule 30 (rel_expr -> rel_expr LE add_expr .)
    EQ              reduce using rule 30 (rel_expr -> rel_expr LE add_expr .)
    AND             reduce using rule 30 (rel_expr -> rel_expr LE add_expr .)
    ]               reduce using rule 30 (rel_expr -> rel_expr LE add_expr .)
    OR              reduce using rule 30 (rel_expr -> rel_expr LE add_expr .)
    ;               reduce using rule 30 (rel_expr -> rel_expr LE add_expr .)
    )               reduce using rule 30 (rel_expr -> rel_expr LE add_expr .)
    }               reduce using rule 30 (rel_expr -> rel_expr LE add_expr .)
    ,               reduce using rule 30 (rel_expr -> rel_expr LE add_expr .)
    -               shift and go to state 97
    +               shift and go to state 98


state 147

    (31) rel_expr -> rel_expr GE add_expr .
    (27) add_expr -> add_expr . - mult_expr
    (28) add_expr -> add_expr . + mult_expr
    LE              reduce using rule 31 (rel_expr -> rel_expr GE add_expr .)
    GE              reduce using rule 31 (rel_expr -> rel_expr GE add_expr .)
    <               reduce using rule 31 (rel_expr -> rel_expr GE add_expr .)
    >               reduce using rule 31 (rel_expr -> rel_expr GE add_expr .)
    NE              reduce using rule 31 (rel_expr -> rel_expr GE add_expr .)
    EQ              reduce using rule 31 (rel_expr -> rel_expr GE add_expr .)
    AND             reduce using rule 31 (rel_expr -> rel_expr GE add_expr .)
    ]               reduce using rule 31 (rel_expr -> rel_expr GE add_expr .)
    OR              reduce using rule 31 (rel_expr -> rel_expr GE add_expr .)
    ;               reduce using rule 31 (rel_expr -> rel_expr GE add_expr .)
    )               reduce using rule 31 (rel_expr -> rel_expr GE add_expr .)
    }               reduce using rule 31 (rel_expr -> rel_expr GE add_expr .)
    ,               reduce using rule 31 (rel_expr -> rel_expr GE add_expr .)
    -               shift and go to state 97
    +               shift and go to state 98


state 148

    (32) rel_expr -> rel_expr < add_expr .
    (27) add_expr -> add_expr . - mult_expr
    (28) add_expr -> add_expr . + mult_expr
    LE              reduce using rule 32 (rel_expr -> rel_expr < add_expr .)
    GE              reduce using rule 32 (rel_expr -> rel_expr < add_expr .)
    <               reduce using rule 32 (rel_expr -> rel_expr < add_expr .)
    >               reduce using rule 32 (rel_expr -> rel_expr < add_expr .)
    NE              reduce using rule 32 (rel_expr -> rel_expr < add_expr .)
    EQ              reduce using rule 32 (rel_expr -> rel_expr < add_expr .)
    AND             reduce using rule 32 (rel_expr -> rel_expr < add_expr .)
    ]               reduce using rule 32 (rel_expr -> rel_expr < add_expr .)
    OR              reduce using rule 32 (rel_expr -> rel_expr < add_expr .)
    ;               reduce using rule 32 (rel_expr -> rel_expr < add_expr .)
    )               reduce using rule 32 (rel_expr -> rel_expr < add_expr .)
    }               reduce using rule 32 (rel_expr -> rel_expr < add_expr .)
    ,               reduce using rule 32 (rel_expr -> rel_expr < add_expr .)
    -               shift and go to state 97
    +               shift and go to state 98


state 149

    (33) rel_expr -> rel_expr > add_expr .
    (27) add_expr -> add_expr . - mult_expr
    (28) add_expr -> add_expr . + mult_expr
    LE              reduce using rule 33 (rel_expr -> rel_expr > add_expr .)
    GE              reduce using rule 33 (rel_expr -> rel_expr > add_expr .)
    <               reduce using rule 33 (rel_expr -> rel_expr > add_expr .)
    >               reduce using rule 33 (rel_expr -> rel_expr > add_expr .)
    NE              reduce using rule 33 (rel_expr -> rel_expr > add_expr .)
    EQ              reduce using rule 33 (rel_expr -> rel_expr > add_expr .)
    AND             reduce using rule 33 (rel_expr -> rel_expr > add_expr .)
    ]               reduce using rule 33 (rel_expr -> rel_expr > add_expr .)
    OR              reduce using rule 33 (rel_expr -> rel_expr > add_expr .)
    ;               reduce using rule 33 (rel_expr -> rel_expr > add_expr .)
    )               reduce using rule 33 (rel_expr -> rel_expr > add_expr .)
    }               reduce using rule 33 (rel_expr -> rel_expr > add_expr .)
    ,               reduce using rule 33 (rel_expr -> rel_expr > add_expr .)
    -               shift and go to state 97
    +               shift and go to state 98


state 150

    (27) add_expr -> add_expr - mult_expr .
    (23) mult_expr -> mult_expr . % cast_expr
    (24) mult_expr -> mult_expr . / cast_expr
    (25) mult_expr -> mult_expr . * cast_expr
    -               reduce using rule 27 (add_expr -> add_expr - mult_expr .)
    +               reduce using rule 27 (add_expr -> add_expr - mult_expr .)
    LE              reduce using rule 27 (add_expr -> add_expr - mult_expr .)
    GE              reduce using rule 27 (add_expr -> add_expr - mult_expr .)
    <               reduce using rule 27 (add_expr -> add_expr - mult_expr .)
    >               reduce using rule 27 (add_expr -> add_expr - mult_expr .)
    NE              reduce using rule 27 (add_expr -> add_expr - mult_expr .)
    EQ              reduce using rule 27 (add_expr -> add_expr - mult_expr .)
    AND             reduce using rule 27 (add_expr -> add_expr - mult_expr .)
    ]               reduce using rule 27 (add_expr -> add_expr - mult_expr .)
    OR              reduce using rule 27 (add_expr -> add_expr - mult_expr .)
    ;               reduce using rule 27 (add_expr -> add_expr - mult_expr .)
    )               reduce using rule 27 (add_expr -> add_expr - mult_expr .)
    }               reduce using rule 27 (add_expr -> add_expr - mult_expr .)
    ,               reduce using rule 27 (add_expr -> add_expr - mult_expr .)
    %               shift and go to state 100
    /               shift and go to state 101
    *               shift and go to state 102


state 151

    (28) add_expr -> add_expr + mult_expr .
    (23) mult_expr -> mult_expr . % cast_expr
    (24) mult_expr -> mult_expr . / cast_expr
    (25) mult_expr -> mult_expr . * cast_expr
    -               reduce using rule 28 (add_expr -> add_expr + mult_expr .)
    +               reduce using rule 28 (add_expr -> add_expr + mult_expr .)
    LE              reduce using rule 28 (add_expr -> add_expr + mult_expr .)
    GE              reduce using rule 28 (add_expr -> add_expr + mult_expr .)
    <               reduce using rule 28 (add_expr -> add_expr + mult_expr .)
    >               reduce using rule 28 (add_expr -> add_expr + mult_expr .)
    NE              reduce using rule 28 (add_expr -> add_expr + mult_expr .)
    EQ              reduce using rule 28 (add_expr -> add_expr + mult_expr .)
    AND             reduce using rule 28 (add_expr -> add_expr + mult_expr .)
    ]               reduce using rule 28 (add_expr -> add_expr + mult_expr .)
    OR              reduce using rule 28 (add_expr -> add_expr + mult_expr .)
    ;               reduce using rule 28 (add_expr -> add_expr + mult_expr .)
    )               reduce using rule 28 (add_expr -> add_expr + mult_expr .)
    }               reduce using rule 28 (add_expr -> add_expr + mult_expr .)
    ,               reduce using rule 28 (add_expr -> add_expr + mult_expr .)
    %               shift and go to state 100
    /               shift and go to state 101
    *               shift and go to state 102


state 152

    (23) mult_expr -> mult_expr % cast_expr .
    %               reduce using rule 23 (mult_expr -> mult_expr % cast_expr .)
    /               reduce using rule 23 (mult_expr -> mult_expr % cast_expr .)
    *               reduce using rule 23 (mult_expr -> mult_expr % cast_expr .)
    -               reduce using rule 23 (mult_expr -> mult_expr % cast_expr .)
    +               reduce using rule 23 (mult_expr -> mult_expr % cast_expr .)
    LE              reduce using rule 23 (mult_expr -> mult_expr % cast_expr .)
    GE              reduce using rule 23 (mult_expr -> mult_expr % cast_expr .)
    <               reduce using rule 23 (mult_expr -> mult_expr % cast_expr .)
    >               reduce using rule 23 (mult_expr -> mult_expr % cast_expr .)
    NE              reduce using rule 23 (mult_expr -> mult_expr % cast_expr .)
    EQ              reduce using rule 23 (mult_expr -> mult_expr % cast_expr .)
    AND             reduce using rule 23 (mult_expr -> mult_expr % cast_expr .)
    ]               reduce using rule 23 (mult_expr -> mult_expr % cast_expr .)
    OR              reduce using rule 23 (mult_expr -> mult_expr % cast_expr .)
    ;               reduce using rule 23 (mult_expr -> mult_expr % cast_expr .)
    )               reduce using rule 23 (mult_expr -> mult_expr % cast_expr .)
    }               reduce using rule 23 (mult_expr -> mult_expr % cast_expr .)
    ,               reduce using rule 23 (mult_expr -> mult_expr % cast_expr .)


state 153

    (24) mult_expr -> mult_expr / cast_expr .
    %               reduce using rule 24 (mult_expr -> mult_expr / cast_expr .)
    /               reduce using rule 24 (mult_expr -> mult_expr / cast_expr .)
    *               reduce using rule 24 (mult_expr -> mult_expr / cast_expr .)
    -               reduce using rule 24 (mult_expr -> mult_expr / cast_expr .)
    +               reduce using rule 24 (mult_expr -> mult_expr / cast_expr .)
    LE              reduce using rule 24 (mult_expr -> mult_expr / cast_expr .)
    GE              reduce using rule 24 (mult_expr -> mult_expr / cast_expr .)
    <               reduce using rule 24 (mult_expr -> mult_expr / cast_expr .)
    >               reduce using rule 24 (mult_expr -> mult_expr / cast_expr .)
    NE              reduce using rule 24 (mult_expr -> mult_expr / cast_expr .)
    EQ              reduce using rule 24 (mult_expr -> mult_expr / cast_expr .)
    AND             reduce using rule 24 (mult_expr -> mult_expr / cast_expr .)
    ]               reduce using rule 24 (mult_expr -> mult_expr / cast_expr .)
    OR              reduce using rule 24 (mult_expr -> mult_expr / cast_expr .)
    ;               reduce using rule 24 (mult_expr -> mult_expr / cast_expr .)
    )               reduce using rule 24 (mult_expr -> mult_expr / cast_expr .)
    }               reduce using rule 24 (mult_expr -> mult_expr / cast_expr .)
    ,               reduce using rule 24 (mult_expr -> mult_expr / cast_expr .)


state 154

    (25) mult_expr -> mult_expr * cast_expr .
    %               reduce using rule 25 (mult_expr -> mult_expr * cast_expr .)
    /               reduce using rule 25 (mult_expr -> mult_expr * cast_expr .)
    *               reduce using rule 25 (mult_expr -> mult_expr * cast_expr .)
    -               reduce using rule 25 (mult_expr -> mult_expr * cast_expr .)
    +               reduce using rule 25 (mult_expr -> mult_expr * cast_expr .)
    LE              reduce using rule 25 (mult_expr -> mult_expr * cast_expr .)
    GE              reduce using rule 25 (mult_expr -> mult_expr * cast_expr .)
    <               reduce using rule 25 (mult_expr -> mult_expr * cast_expr .)
    >               reduce using rule 25 (mult_expr -> mult_expr * cast_expr .)
    NE              reduce using rule 25 (mult_expr -> mult_expr * cast_expr .)
    EQ              reduce using rule 25 (mult_expr -> mult_expr * cast_expr .)
    AND             reduce using rule 25 (mult_expr -> mult_expr * cast_expr .)
    ]               reduce using rule 25 (mult_expr -> mult_expr * cast_expr .)
    OR              reduce using rule 25 (mult_expr -> mult_expr * cast_expr .)
    ;               reduce using rule 25 (mult_expr -> mult_expr * cast_expr .)
    )               reduce using rule 25 (mult_expr -> mult_expr * cast_expr .)
    }               reduce using rule 25 (mult_expr -> mult_expr * cast_expr .)
    ,               reduce using rule 25 (mult_expr -> mult_expr * cast_expr .)


state 155

    (22) cast_expr -> ( type ) . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (               shift and go to state 47
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    cast_expr                      shift and go to state 173
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 156

    (3) primary_expr -> ( expr ) .
    DEC             reduce using rule 3 (primary_expr -> ( expr ) .)
    INC             reduce using rule 3 (primary_expr -> ( expr ) .)
    .               reduce using rule 3 (primary_expr -> ( expr ) .)
    (               reduce using rule 3 (primary_expr -> ( expr ) .)
    [               reduce using rule 3 (primary_expr -> ( expr ) .)
    %               reduce using rule 3 (primary_expr -> ( expr ) .)
    /               reduce using rule 3 (primary_expr -> ( expr ) .)
    *               reduce using rule 3 (primary_expr -> ( expr ) .)
    -               reduce using rule 3 (primary_expr -> ( expr ) .)
    +               reduce using rule 3 (primary_expr -> ( expr ) .)
    LE              reduce using rule 3 (primary_expr -> ( expr ) .)
    GE              reduce using rule 3 (primary_expr -> ( expr ) .)
    <               reduce using rule 3 (primary_expr -> ( expr ) .)
    >               reduce using rule 3 (primary_expr -> ( expr ) .)
    NE              reduce using rule 3 (primary_expr -> ( expr ) .)
    EQ              reduce using rule 3 (primary_expr -> ( expr ) .)
    AND             reduce using rule 3 (primary_expr -> ( expr ) .)
    ]               reduce using rule 3 (primary_expr -> ( expr ) .)
    OR              reduce using rule 3 (primary_expr -> ( expr ) .)
    =               reduce using rule 3 (primary_expr -> ( expr ) .)
    MODEQ           reduce using rule 3 (primary_expr -> ( expr ) .)
    DIVEQ           reduce using rule 3 (primary_expr -> ( expr ) .)
    MULEQ           reduce using rule 3 (primary_expr -> ( expr ) .)
    MINUSEQ         reduce using rule 3 (primary_expr -> ( expr ) .)
    PLUSEQ          reduce using rule 3 (primary_expr -> ( expr ) .)
    ;               reduce using rule 3 (primary_expr -> ( expr ) .)
    )               reduce using rule 3 (primary_expr -> ( expr ) .)
    }               reduce using rule 3 (primary_expr -> ( expr ) .)
    ,               reduce using rule 3 (primary_expr -> ( expr ) .)


state 157

    (8) postfix_expr -> postfix_expr . IDENTIFIER .
    DEC             reduce using rule 8 (postfix_expr -> postfix_expr . IDENTIFIER .)
    INC             reduce using rule 8 (postfix_expr -> postfix_expr . IDENTIFIER .)
    .               reduce using rule 8 (postfix_expr -> postfix_expr . IDENTIFIER .)
    (               reduce using rule 8 (postfix_expr -> postfix_expr . IDENTIFIER .)
    [               reduce using rule 8 (postfix_expr -> postfix_expr . IDENTIFIER .)
    %               reduce using rule 8 (postfix_expr -> postfix_expr . IDENTIFIER .)
    /               reduce using rule 8 (postfix_expr -> postfix_expr . IDENTIFIER .)
    *               reduce using rule 8 (postfix_expr -> postfix_expr . IDENTIFIER .)
    -               reduce using rule 8 (postfix_expr -> postfix_expr . IDENTIFIER .)
    +               reduce using rule 8 (postfix_expr -> postfix_expr . IDENTIFIER .)
    LE              reduce using rule 8 (postfix_expr -> postfix_expr . IDENTIFIER .)
    GE              reduce using rule 8 (postfix_expr -> postfix_expr . IDENTIFIER .)
    <               reduce using rule 8 (postfix_expr -> postfix_expr . IDENTIFIER .)
    >               reduce using rule 8 (postfix_expr -> postfix_expr . IDENTIFIER .)
    NE              reduce using rule 8 (postfix_expr -> postfix_expr . IDENTIFIER .)
    EQ              reduce using rule 8 (postfix_expr -> postfix_expr . IDENTIFIER .)
    AND             reduce using rule 8 (postfix_expr -> postfix_expr . IDENTIFIER .)
    ]               reduce using rule 8 (postfix_expr -> postfix_expr . IDENTIFIER .)
    OR              reduce using rule 8 (postfix_expr -> postfix_expr . IDENTIFIER .)
    =               reduce using rule 8 (postfix_expr -> postfix_expr . IDENTIFIER .)
    MODEQ           reduce using rule 8 (postfix_expr -> postfix_expr . IDENTIFIER .)
    DIVEQ           reduce using rule 8 (postfix_expr -> postfix_expr . IDENTIFIER .)
    MULEQ           reduce using rule 8 (postfix_expr -> postfix_expr . IDENTIFIER .)
    MINUSEQ         reduce using rule 8 (postfix_expr -> postfix_expr . IDENTIFIER .)
    PLUSEQ          reduce using rule 8 (postfix_expr -> postfix_expr . IDENTIFIER .)
    ;               reduce using rule 8 (postfix_expr -> postfix_expr . IDENTIFIER .)
    )               reduce using rule 8 (postfix_expr -> postfix_expr . IDENTIFIER .)
    }               reduce using rule 8 (postfix_expr -> postfix_expr . IDENTIFIER .)
    ,               reduce using rule 8 (postfix_expr -> postfix_expr . IDENTIFIER .)


state 158

    (9) postfix_expr -> postfix_expr ( arg_expr_list . )
    (13) arg_expr_list -> arg_expr_list . , expr
    )               shift and go to state 174
    ,               shift and go to state 175


state 159

    (10) postfix_expr -> postfix_expr ( ) .
    DEC             reduce using rule 10 (postfix_expr -> postfix_expr ( ) .)
    INC             reduce using rule 10 (postfix_expr -> postfix_expr ( ) .)
    .               reduce using rule 10 (postfix_expr -> postfix_expr ( ) .)
    (               reduce using rule 10 (postfix_expr -> postfix_expr ( ) .)
    [               reduce using rule 10 (postfix_expr -> postfix_expr ( ) .)
    %               reduce using rule 10 (postfix_expr -> postfix_expr ( ) .)
    /               reduce using rule 10 (postfix_expr -> postfix_expr ( ) .)
    *               reduce using rule 10 (postfix_expr -> postfix_expr ( ) .)
    -               reduce using rule 10 (postfix_expr -> postfix_expr ( ) .)
    +               reduce using rule 10 (postfix_expr -> postfix_expr ( ) .)
    LE              reduce using rule 10 (postfix_expr -> postfix_expr ( ) .)
    GE              reduce using rule 10 (postfix_expr -> postfix_expr ( ) .)
    <               reduce using rule 10 (postfix_expr -> postfix_expr ( ) .)
    >               reduce using rule 10 (postfix_expr -> postfix_expr ( ) .)
    NE              reduce using rule 10 (postfix_expr -> postfix_expr ( ) .)
    EQ              reduce using rule 10 (postfix_expr -> postfix_expr ( ) .)
    AND             reduce using rule 10 (postfix_expr -> postfix_expr ( ) .)
    ]               reduce using rule 10 (postfix_expr -> postfix_expr ( ) .)
    OR              reduce using rule 10 (postfix_expr -> postfix_expr ( ) .)
    =               reduce using rule 10 (postfix_expr -> postfix_expr ( ) .)
    MODEQ           reduce using rule 10 (postfix_expr -> postfix_expr ( ) .)
    DIVEQ           reduce using rule 10 (postfix_expr -> postfix_expr ( ) .)
    MULEQ           reduce using rule 10 (postfix_expr -> postfix_expr ( ) .)
    MINUSEQ         reduce using rule 10 (postfix_expr -> postfix_expr ( ) .)
    PLUSEQ          reduce using rule 10 (postfix_expr -> postfix_expr ( ) .)
    ;               reduce using rule 10 (postfix_expr -> postfix_expr ( ) .)
    )               reduce using rule 10 (postfix_expr -> postfix_expr ( ) .)
    }               reduce using rule 10 (postfix_expr -> postfix_expr ( ) .)
    ,               reduce using rule 10 (postfix_expr -> postfix_expr ( ) .)


state 160

    (14) arg_expr_list -> expr .
    )               reduce using rule 14 (arg_expr_list -> expr .)
    ,               reduce using rule 14 (arg_expr_list -> expr .)


state 161

    (11) postfix_expr -> postfix_expr [ expr . ]
    ]               shift and go to state 176


state 162

    (62) param_list -> param_list , param_decl .
    )               reduce using rule 62 (param_list -> param_list , param_decl .)
    ,               reduce using rule 62 (param_list -> param_list , param_decl .)


state 163

    (65) initializer -> { initializer_list } .
    ;               reduce using rule 65 (initializer -> { initializer_list } .)
    }               reduce using rule 65 (initializer -> { initializer_list } .)
    ,               reduce using rule 65 (initializer -> { initializer_list } .)


state 164

    (67) initializer_list -> initializer_list , . initializer
    (65) initializer -> . { initializer_list }
    (66) initializer -> . expr
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr < add_expr
    (33) rel_expr -> . rel_expr > add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    {               shift and go to state 60
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    (               shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    initializer                    shift and go to state 177
    expr                           shift and go to state 61
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 165

    (42) expr -> unary_expr assignment_op expr .
    ;               reduce using rule 42 (expr -> unary_expr assignment_op expr .)
    )               reduce using rule 42 (expr -> unary_expr assignment_op expr .)
    }               reduce using rule 42 (expr -> unary_expr assignment_op expr .)
    ,               reduce using rule 42 (expr -> unary_expr assignment_op expr .)
    ]               reduce using rule 42 (expr -> unary_expr assignment_op expr .)


state 166

    (88) jump_stmt -> RETURN expr ; .
    }               reduce using rule 88 (jump_stmt -> RETURN expr ; .)
    RETURN          reduce using rule 88 (jump_stmt -> RETURN expr ; .)
    BREAK           reduce using rule 88 (jump_stmt -> RETURN expr ; .)
    CONTINUE        reduce using rule 88 (jump_stmt -> RETURN expr ; .)
    GOTO            reduce using rule 88 (jump_stmt -> RETURN expr ; .)
    FOR             reduce using rule 88 (jump_stmt -> RETURN expr ; .)
    DO              reduce using rule 88 (jump_stmt -> RETURN expr ; .)
    WHILE           reduce using rule 88 (jump_stmt -> RETURN expr ; .)
    IF              reduce using rule 88 (jump_stmt -> RETURN expr ; .)
    ;               reduce using rule 88 (jump_stmt -> RETURN expr ; .)
    {               reduce using rule 88 (jump_stmt -> RETURN expr ; .)
    IDENTIFIER      reduce using rule 88 (jump_stmt -> RETURN expr ; .)
    VOID            reduce using rule 88 (jump_stmt -> RETURN expr ; .)
    STRING_T        reduce using rule 88 (jump_stmt -> RETURN expr ; .)
    DOUBLE          reduce using rule 88 (jump_stmt -> RETURN expr ; .)
    INT             reduce using rule 88 (jump_stmt -> RETURN expr ; .)
    !               reduce using rule 88 (jump_stmt -> RETURN expr ; .)
    -               reduce using rule 88 (jump_stmt -> RETURN expr ; .)
    +               reduce using rule 88 (jump_stmt -> RETURN expr ; .)
    DEC             reduce using rule 88 (jump_stmt -> RETURN expr ; .)
    INC             reduce using rule 88 (jump_stmt -> RETURN expr ; .)
    (               reduce using rule 88 (jump_stmt -> RETURN expr ; .)
    FLOAT           reduce using rule 88 (jump_stmt -> RETURN expr ; .)
    INTEGER         reduce using rule 88 (jump_stmt -> RETURN expr ; .)
    ELSE            reduce using rule 88 (jump_stmt -> RETURN expr ; .)


state 167

    (92) jump_stmt -> GOTO IDENTIFIER ; .
    }               reduce using rule 92 (jump_stmt -> GOTO IDENTIFIER ; .)
    RETURN          reduce using rule 92 (jump_stmt -> GOTO IDENTIFIER ; .)
    BREAK           reduce using rule 92 (jump_stmt -> GOTO IDENTIFIER ; .)
    CONTINUE        reduce using rule 92 (jump_stmt -> GOTO IDENTIFIER ; .)
    GOTO            reduce using rule 92 (jump_stmt -> GOTO IDENTIFIER ; .)
    FOR             reduce using rule 92 (jump_stmt -> GOTO IDENTIFIER ; .)
    DO              reduce using rule 92 (jump_stmt -> GOTO IDENTIFIER ; .)
    WHILE           reduce using rule 92 (jump_stmt -> GOTO IDENTIFIER ; .)
    IF              reduce using rule 92 (jump_stmt -> GOTO IDENTIFIER ; .)
    ;               reduce using rule 92 (jump_stmt -> GOTO IDENTIFIER ; .)
    {               reduce using rule 92 (jump_stmt -> GOTO IDENTIFIER ; .)
    IDENTIFIER      reduce using rule 92 (jump_stmt -> GOTO IDENTIFIER ; .)
    VOID            reduce using rule 92 (jump_stmt -> GOTO IDENTIFIER ; .)
    STRING_T        reduce using rule 92 (jump_stmt -> GOTO IDENTIFIER ; .)
    DOUBLE          reduce using rule 92 (jump_stmt -> GOTO IDENTIFIER ; .)
    INT             reduce using rule 92 (jump_stmt -> GOTO IDENTIFIER ; .)
    !               reduce using rule 92 (jump_stmt -> GOTO IDENTIFIER ; .)
    -               reduce using rule 92 (jump_stmt -> GOTO IDENTIFIER ; .)
    +               reduce using rule 92 (jump_stmt -> GOTO IDENTIFIER ; .)
    DEC             reduce using rule 92 (jump_stmt -> GOTO IDENTIFIER ; .)
    INC             reduce using rule 92 (jump_stmt -> GOTO IDENTIFIER ; .)
    (               reduce using rule 92 (jump_stmt -> GOTO IDENTIFIER ; .)
    FLOAT           reduce using rule 92 (jump_stmt -> GOTO IDENTIFIER ; .)
    INTEGER         reduce using rule 92 (jump_stmt -> GOTO IDENTIFIER ; .)
    ELSE            reduce using rule 92 (jump_stmt -> GOTO IDENTIFIER ; .)


state 168

    (75) labeled_stmt -> IDENTIFIER : stmt .
    }               reduce using rule 75 (labeled_stmt -> IDENTIFIER : stmt .)
    RETURN          reduce using rule 75 (labeled_stmt -> IDENTIFIER : stmt .)
    BREAK           reduce using rule 75 (labeled_stmt -> IDENTIFIER : stmt .)
    CONTINUE        reduce using rule 75 (labeled_stmt -> IDENTIFIER : stmt .)
    GOTO            reduce using rule 75 (labeled_stmt -> IDENTIFIER : stmt .)
    FOR             reduce using rule 75 (labeled_stmt -> IDENTIFIER : stmt .)
    DO              reduce using rule 75 (labeled_stmt -> IDENTIFIER : stmt .)
    WHILE           reduce using rule 75 (labeled_stmt -> IDENTIFIER : stmt .)
    IF              reduce using rule 75 (labeled_stmt -> IDENTIFIER : stmt .)
    ;               reduce using rule 75 (labeled_stmt -> IDENTIFIER : stmt .)
    {               reduce using rule 75 (labeled_stmt -> IDENTIFIER : stmt .)
    IDENTIFIER      reduce using rule 75 (labeled_stmt -> IDENTIFIER : stmt .)
    VOID            reduce using rule 75 (labeled_stmt -> IDENTIFIER : stmt .)
    STRING_T        reduce using rule 75 (labeled_stmt -> IDENTIFIER : stmt .)
    DOUBLE          reduce using rule 75 (labeled_stmt -> IDENTIFIER : stmt .)
    INT             reduce using rule 75 (labeled_stmt -> IDENTIFIER : stmt .)
    !               reduce using rule 75 (labeled_stmt -> IDENTIFIER : stmt .)
    -               reduce using rule 75 (labeled_stmt -> IDENTIFIER : stmt .)
    +               reduce using rule 75 (labeled_stmt -> IDENTIFIER : stmt .)
    DEC             reduce using rule 75 (labeled_stmt -> IDENTIFIER : stmt .)
    INC             reduce using rule 75 (labeled_stmt -> IDENTIFIER : stmt .)
    (               reduce using rule 75 (labeled_stmt -> IDENTIFIER : stmt .)
    FLOAT           reduce using rule 75 (labeled_stmt -> IDENTIFIER : stmt .)
    INTEGER         reduce using rule 75 (labeled_stmt -> IDENTIFIER : stmt .)
    ELSE            reduce using rule 75 (labeled_stmt -> IDENTIFIER : stmt .)


state 169

    (85) loop_stmt -> FOR ( expr_stmt . expr_stmt expr ) stmt
    (80) expr_stmt -> . decl
    (81) expr_stmt -> . expr ;
    (82) expr_stmt -> . ;
    (50) decl -> . type init_declarator ;
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr < add_expr
    (33) rel_expr -> . rel_expr > add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    ;               shift and go to state 76
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    (               shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    expr_stmt                      shift and go to state 178
    expr                           shift and go to state 75
    decl                           shift and go to state 85
    type                           shift and go to state 86
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 170

    (86) loop_stmt -> DO stmt WHILE . ( expr ) ;
    (               shift and go to state 179


state 171

    (87) loop_stmt -> WHILE ( expr . ) stmt
    )               shift and go to state 180


state 172

    (83) if_stmt -> IF ( expr . ) stmt ELSE stmt
    (84) if_stmt -> IF ( expr . ) stmt
    )               shift and go to state 181


state 173

    (22) cast_expr -> ( type ) cast_expr .
    %               reduce using rule 22 (cast_expr -> ( type ) cast_expr .)
    /               reduce using rule 22 (cast_expr -> ( type ) cast_expr .)
    *               reduce using rule 22 (cast_expr -> ( type ) cast_expr .)
    -               reduce using rule 22 (cast_expr -> ( type ) cast_expr .)
    +               reduce using rule 22 (cast_expr -> ( type ) cast_expr .)
    LE              reduce using rule 22 (cast_expr -> ( type ) cast_expr .)
    GE              reduce using rule 22 (cast_expr -> ( type ) cast_expr .)
    <               reduce using rule 22 (cast_expr -> ( type ) cast_expr .)
    >               reduce using rule 22 (cast_expr -> ( type ) cast_expr .)
    NE              reduce using rule 22 (cast_expr -> ( type ) cast_expr .)
    EQ              reduce using rule 22 (cast_expr -> ( type ) cast_expr .)
    AND             reduce using rule 22 (cast_expr -> ( type ) cast_expr .)
    ]               reduce using rule 22 (cast_expr -> ( type ) cast_expr .)
    OR              reduce using rule 22 (cast_expr -> ( type ) cast_expr .)
    ;               reduce using rule 22 (cast_expr -> ( type ) cast_expr .)
    =               reduce using rule 22 (cast_expr -> ( type ) cast_expr .)
    MODEQ           reduce using rule 22 (cast_expr -> ( type ) cast_expr .)
    DIVEQ           reduce using rule 22 (cast_expr -> ( type ) cast_expr .)
    MULEQ           reduce using rule 22 (cast_expr -> ( type ) cast_expr .)
    MINUSEQ         reduce using rule 22 (cast_expr -> ( type ) cast_expr .)
    PLUSEQ          reduce using rule 22 (cast_expr -> ( type ) cast_expr .)
    )               reduce using rule 22 (cast_expr -> ( type ) cast_expr .)
    }               reduce using rule 22 (cast_expr -> ( type ) cast_expr .)
    ,               reduce using rule 22 (cast_expr -> ( type ) cast_expr .)


state 174

    (9) postfix_expr -> postfix_expr ( arg_expr_list ) .
    DEC             reduce using rule 9 (postfix_expr -> postfix_expr ( arg_expr_list ) .)
    INC             reduce using rule 9 (postfix_expr -> postfix_expr ( arg_expr_list ) .)
    .               reduce using rule 9 (postfix_expr -> postfix_expr ( arg_expr_list ) .)
    (               reduce using rule 9 (postfix_expr -> postfix_expr ( arg_expr_list ) .)
    [               reduce using rule 9 (postfix_expr -> postfix_expr ( arg_expr_list ) .)
    %               reduce using rule 9 (postfix_expr -> postfix_expr ( arg_expr_list ) .)
    /               reduce using rule 9 (postfix_expr -> postfix_expr ( arg_expr_list ) .)
    *               reduce using rule 9 (postfix_expr -> postfix_expr ( arg_expr_list ) .)
    -               reduce using rule 9 (postfix_expr -> postfix_expr ( arg_expr_list ) .)
    +               reduce using rule 9 (postfix_expr -> postfix_expr ( arg_expr_list ) .)
    LE              reduce using rule 9 (postfix_expr -> postfix_expr ( arg_expr_list ) .)
    GE              reduce using rule 9 (postfix_expr -> postfix_expr ( arg_expr_list ) .)
    <               reduce using rule 9 (postfix_expr -> postfix_expr ( arg_expr_list ) .)
    >               reduce using rule 9 (postfix_expr -> postfix_expr ( arg_expr_list ) .)
    NE              reduce using rule 9 (postfix_expr -> postfix_expr ( arg_expr_list ) .)
    EQ              reduce using rule 9 (postfix_expr -> postfix_expr ( arg_expr_list ) .)
    AND             reduce using rule 9 (postfix_expr -> postfix_expr ( arg_expr_list ) .)
    ]               reduce using rule 9 (postfix_expr -> postfix_expr ( arg_expr_list ) .)
    OR              reduce using rule 9 (postfix_expr -> postfix_expr ( arg_expr_list ) .)
    =               reduce using rule 9 (postfix_expr -> postfix_expr ( arg_expr_list ) .)
    MODEQ           reduce using rule 9 (postfix_expr -> postfix_expr ( arg_expr_list ) .)
    DIVEQ           reduce using rule 9 (postfix_expr -> postfix_expr ( arg_expr_list ) .)
    MULEQ           reduce using rule 9 (postfix_expr -> postfix_expr ( arg_expr_list ) .)
    MINUSEQ         reduce using rule 9 (postfix_expr -> postfix_expr ( arg_expr_list ) .)
    PLUSEQ          reduce using rule 9 (postfix_expr -> postfix_expr ( arg_expr_list ) .)
    ;               reduce using rule 9 (postfix_expr -> postfix_expr ( arg_expr_list ) .)
    )               reduce using rule 9 (postfix_expr -> postfix_expr ( arg_expr_list ) .)
    }               reduce using rule 9 (postfix_expr -> postfix_expr ( arg_expr_list ) .)
    ,               reduce using rule 9 (postfix_expr -> postfix_expr ( arg_expr_list ) .)


state 175

    (13) arg_expr_list -> arg_expr_list , . expr
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr < add_expr
    (33) rel_expr -> . rel_expr > add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    (               shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    expr                           shift and go to state 182
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 176

    (11) postfix_expr -> postfix_expr [ expr ] .
    DEC             reduce using rule 11 (postfix_expr -> postfix_expr [ expr ] .)
    INC             reduce using rule 11 (postfix_expr -> postfix_expr [ expr ] .)
    .               reduce using rule 11 (postfix_expr -> postfix_expr [ expr ] .)
    (               reduce using rule 11 (postfix_expr -> postfix_expr [ expr ] .)
    [               reduce using rule 11 (postfix_expr -> postfix_expr [ expr ] .)
    %               reduce using rule 11 (postfix_expr -> postfix_expr [ expr ] .)
    /               reduce using rule 11 (postfix_expr -> postfix_expr [ expr ] .)
    *               reduce using rule 11 (postfix_expr -> postfix_expr [ expr ] .)
    -               reduce using rule 11 (postfix_expr -> postfix_expr [ expr ] .)
    +               reduce using rule 11 (postfix_expr -> postfix_expr [ expr ] .)
    LE              reduce using rule 11 (postfix_expr -> postfix_expr [ expr ] .)
    GE              reduce using rule 11 (postfix_expr -> postfix_expr [ expr ] .)
    <               reduce using rule 11 (postfix_expr -> postfix_expr [ expr ] .)
    >               reduce using rule 11 (postfix_expr -> postfix_expr [ expr ] .)
    NE              reduce using rule 11 (postfix_expr -> postfix_expr [ expr ] .)
    EQ              reduce using rule 11 (postfix_expr -> postfix_expr [ expr ] .)
    AND             reduce using rule 11 (postfix_expr -> postfix_expr [ expr ] .)
    ]               reduce using rule 11 (postfix_expr -> postfix_expr [ expr ] .)
    OR              reduce using rule 11 (postfix_expr -> postfix_expr [ expr ] .)
    =               reduce using rule 11 (postfix_expr -> postfix_expr [ expr ] .)
    MODEQ           reduce using rule 11 (postfix_expr -> postfix_expr [ expr ] .)
    DIVEQ           reduce using rule 11 (postfix_expr -> postfix_expr [ expr ] .)
    MULEQ           reduce using rule 11 (postfix_expr -> postfix_expr [ expr ] .)
    MINUSEQ         reduce using rule 11 (postfix_expr -> postfix_expr [ expr ] .)
    PLUSEQ          reduce using rule 11 (postfix_expr -> postfix_expr [ expr ] .)
    ;               reduce using rule 11 (postfix_expr -> postfix_expr [ expr ] .)
    )               reduce using rule 11 (postfix_expr -> postfix_expr [ expr ] .)
    }               reduce using rule 11 (postfix_expr -> postfix_expr [ expr ] .)
    ,               reduce using rule 11 (postfix_expr -> postfix_expr [ expr ] .)


state 177

    (67) initializer_list -> initializer_list , initializer .
    }               reduce using rule 67 (initializer_list -> initializer_list , initializer .)
    ,               reduce using rule 67 (initializer_list -> initializer_list , initializer .)


state 178

    (85) loop_stmt -> FOR ( expr_stmt expr_stmt . expr ) stmt
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr < add_expr
    (33) rel_expr -> . rel_expr > add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    (               shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    expr                           shift and go to state 183
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 179

    (86) loop_stmt -> DO stmt WHILE ( . expr ) ;
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr < add_expr
    (33) rel_expr -> . rel_expr > add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    (               shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    expr                           shift and go to state 184
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 180

    (87) loop_stmt -> WHILE ( expr ) . stmt
    (69) stmt -> . jump_stmt
    (70) stmt -> . loop_stmt
    (71) stmt -> . if_stmt
    (72) stmt -> . expr_stmt
    (73) stmt -> . block_stmt
    (74) stmt -> . labeled_stmt
    (88) jump_stmt -> . RETURN expr ;
    (89) jump_stmt -> . RETURN ;
    (90) jump_stmt -> . BREAK ;
    (91) jump_stmt -> . CONTINUE ;
    (92) jump_stmt -> . GOTO IDENTIFIER ;
    (85) loop_stmt -> . FOR ( expr_stmt expr_stmt expr ) stmt
    (86) loop_stmt -> . DO stmt WHILE ( expr ) ;
    (87) loop_stmt -> . WHILE ( expr ) stmt
    (83) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (84) if_stmt -> . IF ( expr ) stmt
    (80) expr_stmt -> . decl
    (81) expr_stmt -> . expr ;
    (82) expr_stmt -> . ;
    (76) block_stmt -> . { stmt_list }
    (77) block_stmt -> . { }
    (75) labeled_stmt -> . IDENTIFIER : stmt
    (50) decl -> . type init_declarator ;
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr < add_expr
    (33) rel_expr -> . rel_expr > add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    RETURN          shift and go to state 74
    BREAK           shift and go to state 77
    CONTINUE        shift and go to state 78
    GOTO            shift and go to state 79
    FOR             shift and go to state 81
    DO              shift and go to state 82
    WHILE           shift and go to state 83
    IF              shift and go to state 84
    ;               shift and go to state 76
    {               shift and go to state 33
    IDENTIFIER      shift and go to state 80
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    (               shift and go to state 64
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    expr                           shift and go to state 75
    stmt                           shift and go to state 185
    jump_stmt                      shift and go to state 68
    loop_stmt                      shift and go to state 69
    if_stmt                        shift and go to state 70
    expr_stmt                      shift and go to state 71
    block_stmt                     shift and go to state 72
    labeled_stmt                   shift and go to state 73
    decl                           shift and go to state 85
    type                           shift and go to state 86
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 181

    (83) if_stmt -> IF ( expr ) . stmt ELSE stmt
    (84) if_stmt -> IF ( expr ) . stmt
    (69) stmt -> . jump_stmt
    (70) stmt -> . loop_stmt
    (71) stmt -> . if_stmt
    (72) stmt -> . expr_stmt
    (73) stmt -> . block_stmt
    (74) stmt -> . labeled_stmt
    (88) jump_stmt -> . RETURN expr ;
    (89) jump_stmt -> . RETURN ;
    (90) jump_stmt -> . BREAK ;
    (91) jump_stmt -> . CONTINUE ;
    (92) jump_stmt -> . GOTO IDENTIFIER ;
    (85) loop_stmt -> . FOR ( expr_stmt expr_stmt expr ) stmt
    (86) loop_stmt -> . DO stmt WHILE ( expr ) ;
    (87) loop_stmt -> . WHILE ( expr ) stmt
    (83) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (84) if_stmt -> . IF ( expr ) stmt
    (80) expr_stmt -> . decl
    (81) expr_stmt -> . expr ;
    (82) expr_stmt -> . ;
    (76) block_stmt -> . { stmt_list }
    (77) block_stmt -> . { }
    (75) labeled_stmt -> . IDENTIFIER : stmt
    (50) decl -> . type init_declarator ;
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr < add_expr
    (33) rel_expr -> . rel_expr > add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    RETURN          shift and go to state 74
    BREAK           shift and go to state 77
    CONTINUE        shift and go to state 78
    GOTO            shift and go to state 79
    FOR             shift and go to state 81
    DO              shift and go to state 82
    WHILE           shift and go to state 83
    IF              shift and go to state 84
    ;               shift and go to state 76
    {               shift and go to state 33
    IDENTIFIER      shift and go to state 80
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    (               shift and go to state 64
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    expr                           shift and go to state 75
    stmt                           shift and go to state 186
    jump_stmt                      shift and go to state 68
    loop_stmt                      shift and go to state 69
    if_stmt                        shift and go to state 70
    expr_stmt                      shift and go to state 71
    block_stmt                     shift and go to state 72
    labeled_stmt                   shift and go to state 73
    decl                           shift and go to state 85
    type                           shift and go to state 86
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 182

    (13) arg_expr_list -> arg_expr_list , expr .
    )               reduce using rule 13 (arg_expr_list -> arg_expr_list , expr .)
    ,               reduce using rule 13 (arg_expr_list -> arg_expr_list , expr .)


state 183

    (85) loop_stmt -> FOR ( expr_stmt expr_stmt expr . ) stmt
    )               shift and go to state 187


state 184

    (86) loop_stmt -> DO stmt WHILE ( expr . ) ;
    )               shift and go to state 188


state 185

    (87) loop_stmt -> WHILE ( expr ) stmt .
    }               reduce using rule 87 (loop_stmt -> WHILE ( expr ) stmt .)
    RETURN          reduce using rule 87 (loop_stmt -> WHILE ( expr ) stmt .)
    BREAK           reduce using rule 87 (loop_stmt -> WHILE ( expr ) stmt .)
    CONTINUE        reduce using rule 87 (loop_stmt -> WHILE ( expr ) stmt .)
    GOTO            reduce using rule 87 (loop_stmt -> WHILE ( expr ) stmt .)
    FOR             reduce using rule 87 (loop_stmt -> WHILE ( expr ) stmt .)
    DO              reduce using rule 87 (loop_stmt -> WHILE ( expr ) stmt .)
    WHILE           reduce using rule 87 (loop_stmt -> WHILE ( expr ) stmt .)
    IF              reduce using rule 87 (loop_stmt -> WHILE ( expr ) stmt .)
    ;               reduce using rule 87 (loop_stmt -> WHILE ( expr ) stmt .)
    {               reduce using rule 87 (loop_stmt -> WHILE ( expr ) stmt .)
    IDENTIFIER      reduce using rule 87 (loop_stmt -> WHILE ( expr ) stmt .)
    VOID            reduce using rule 87 (loop_stmt -> WHILE ( expr ) stmt .)
    STRING_T        reduce using rule 87 (loop_stmt -> WHILE ( expr ) stmt .)
    DOUBLE          reduce using rule 87 (loop_stmt -> WHILE ( expr ) stmt .)
    INT             reduce using rule 87 (loop_stmt -> WHILE ( expr ) stmt .)
    !               reduce using rule 87 (loop_stmt -> WHILE ( expr ) stmt .)
    -               reduce using rule 87 (loop_stmt -> WHILE ( expr ) stmt .)
    +               reduce using rule 87 (loop_stmt -> WHILE ( expr ) stmt .)
    DEC             reduce using rule 87 (loop_stmt -> WHILE ( expr ) stmt .)
    INC             reduce using rule 87 (loop_stmt -> WHILE ( expr ) stmt .)
    (               reduce using rule 87 (loop_stmt -> WHILE ( expr ) stmt .)
    FLOAT           reduce using rule 87 (loop_stmt -> WHILE ( expr ) stmt .)
    INTEGER         reduce using rule 87 (loop_stmt -> WHILE ( expr ) stmt .)
    ELSE            reduce using rule 87 (loop_stmt -> WHILE ( expr ) stmt .)


state 186

    (83) if_stmt -> IF ( expr ) stmt . ELSE stmt
    (84) if_stmt -> IF ( expr ) stmt .
  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 189
    }               reduce using rule 84 (if_stmt -> IF ( expr ) stmt .)
    RETURN          reduce using rule 84 (if_stmt -> IF ( expr ) stmt .)
    BREAK           reduce using rule 84 (if_stmt -> IF ( expr ) stmt .)
    CONTINUE        reduce using rule 84 (if_stmt -> IF ( expr ) stmt .)
    GOTO            reduce using rule 84 (if_stmt -> IF ( expr ) stmt .)
    FOR             reduce using rule 84 (if_stmt -> IF ( expr ) stmt .)
    DO              reduce using rule 84 (if_stmt -> IF ( expr ) stmt .)
    WHILE           reduce using rule 84 (if_stmt -> IF ( expr ) stmt .)
    IF              reduce using rule 84 (if_stmt -> IF ( expr ) stmt .)
    ;               reduce using rule 84 (if_stmt -> IF ( expr ) stmt .)
    {               reduce using rule 84 (if_stmt -> IF ( expr ) stmt .)
    IDENTIFIER      reduce using rule 84 (if_stmt -> IF ( expr ) stmt .)
    VOID            reduce using rule 84 (if_stmt -> IF ( expr ) stmt .)
    STRING_T        reduce using rule 84 (if_stmt -> IF ( expr ) stmt .)
    DOUBLE          reduce using rule 84 (if_stmt -> IF ( expr ) stmt .)
    INT             reduce using rule 84 (if_stmt -> IF ( expr ) stmt .)
    !               reduce using rule 84 (if_stmt -> IF ( expr ) stmt .)
    -               reduce using rule 84 (if_stmt -> IF ( expr ) stmt .)
    +               reduce using rule 84 (if_stmt -> IF ( expr ) stmt .)
    DEC             reduce using rule 84 (if_stmt -> IF ( expr ) stmt .)
    INC             reduce using rule 84 (if_stmt -> IF ( expr ) stmt .)
    (               reduce using rule 84 (if_stmt -> IF ( expr ) stmt .)
    FLOAT           reduce using rule 84 (if_stmt -> IF ( expr ) stmt .)
    INTEGER         reduce using rule 84 (if_stmt -> IF ( expr ) stmt .)


state 187

    (85) loop_stmt -> FOR ( expr_stmt expr_stmt expr ) . stmt
    (69) stmt -> . jump_stmt
    (70) stmt -> . loop_stmt
    (71) stmt -> . if_stmt
    (72) stmt -> . expr_stmt
    (73) stmt -> . block_stmt
    (74) stmt -> . labeled_stmt
    (88) jump_stmt -> . RETURN expr ;
    (89) jump_stmt -> . RETURN ;
    (90) jump_stmt -> . BREAK ;
    (91) jump_stmt -> . CONTINUE ;
    (92) jump_stmt -> . GOTO IDENTIFIER ;
    (85) loop_stmt -> . FOR ( expr_stmt expr_stmt expr ) stmt
    (86) loop_stmt -> . DO stmt WHILE ( expr ) ;
    (87) loop_stmt -> . WHILE ( expr ) stmt
    (83) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (84) if_stmt -> . IF ( expr ) stmt
    (80) expr_stmt -> . decl
    (81) expr_stmt -> . expr ;
    (82) expr_stmt -> . ;
    (76) block_stmt -> . { stmt_list }
    (77) block_stmt -> . { }
    (75) labeled_stmt -> . IDENTIFIER : stmt
    (50) decl -> . type init_declarator ;
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr < add_expr
    (33) rel_expr -> . rel_expr > add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    RETURN          shift and go to state 74
    BREAK           shift and go to state 77
    CONTINUE        shift and go to state 78
    GOTO            shift and go to state 79
    FOR             shift and go to state 81
    DO              shift and go to state 82
    WHILE           shift and go to state 83
    IF              shift and go to state 84
    ;               shift and go to state 76
    {               shift and go to state 33
    IDENTIFIER      shift and go to state 80
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    (               shift and go to state 64
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    expr_stmt                      shift and go to state 71
    expr                           shift and go to state 75
    stmt                           shift and go to state 190
    jump_stmt                      shift and go to state 68
    loop_stmt                      shift and go to state 69
    if_stmt                        shift and go to state 70
    block_stmt                     shift and go to state 72
    labeled_stmt                   shift and go to state 73
    decl                           shift and go to state 85
    type                           shift and go to state 86
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 188

    (86) loop_stmt -> DO stmt WHILE ( expr ) . ;
    ;               shift and go to state 191


state 189

    (83) if_stmt -> IF ( expr ) stmt ELSE . stmt
    (69) stmt -> . jump_stmt
    (70) stmt -> . loop_stmt
    (71) stmt -> . if_stmt
    (72) stmt -> . expr_stmt
    (73) stmt -> . block_stmt
    (74) stmt -> . labeled_stmt
    (88) jump_stmt -> . RETURN expr ;
    (89) jump_stmt -> . RETURN ;
    (90) jump_stmt -> . BREAK ;
    (91) jump_stmt -> . CONTINUE ;
    (92) jump_stmt -> . GOTO IDENTIFIER ;
    (85) loop_stmt -> . FOR ( expr_stmt expr_stmt expr ) stmt
    (86) loop_stmt -> . DO stmt WHILE ( expr ) ;
    (87) loop_stmt -> . WHILE ( expr ) stmt
    (83) if_stmt -> . IF ( expr ) stmt ELSE stmt
    (84) if_stmt -> . IF ( expr ) stmt
    (80) expr_stmt -> . decl
    (81) expr_stmt -> . expr ;
    (82) expr_stmt -> . ;
    (76) block_stmt -> . { stmt_list }
    (77) block_stmt -> . { }
    (75) labeled_stmt -> . IDENTIFIER : stmt
    (50) decl -> . type init_declarator ;
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    (15) unary_expr -> . ! cast_expr
    (16) unary_expr -> . - cast_expr
    (17) unary_expr -> . + cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr . IDENTIFIER
    (9) postfix_expr -> . postfix_expr ( arg_expr_list )
    (10) postfix_expr -> . postfix_expr ( )
    (11) postfix_expr -> . postfix_expr [ expr ]
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . ( expr )
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr < add_expr
    (33) rel_expr -> . rel_expr > add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr - mult_expr
    (28) add_expr -> . add_expr + mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr % cast_expr
    (24) mult_expr -> . mult_expr / cast_expr
    (25) mult_expr -> . mult_expr * cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . ( type ) cast_expr
    RETURN          shift and go to state 74
    BREAK           shift and go to state 77
    CONTINUE        shift and go to state 78
    GOTO            shift and go to state 79
    FOR             shift and go to state 81
    DO              shift and go to state 82
    WHILE           shift and go to state 83
    IF              shift and go to state 84
    ;               shift and go to state 76
    {               shift and go to state 33
    IDENTIFIER      shift and go to state 80
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15
    !               shift and go to state 48
    -               shift and go to state 42
    +               shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    (               shift and go to state 64
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    expr                           shift and go to state 75
    stmt                           shift and go to state 192
    jump_stmt                      shift and go to state 68
    loop_stmt                      shift and go to state 69
    if_stmt                        shift and go to state 70
    expr_stmt                      shift and go to state 71
    block_stmt                     shift and go to state 72
    labeled_stmt                   shift and go to state 73
    decl                           shift and go to state 85
    type                           shift and go to state 86
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 190

    (85) loop_stmt -> FOR ( expr_stmt expr_stmt expr ) stmt .
    }               reduce using rule 85 (loop_stmt -> FOR ( expr_stmt expr_stmt expr ) stmt .)
    RETURN          reduce using rule 85 (loop_stmt -> FOR ( expr_stmt expr_stmt expr ) stmt .)
    BREAK           reduce using rule 85 (loop_stmt -> FOR ( expr_stmt expr_stmt expr ) stmt .)
    CONTINUE        reduce using rule 85 (loop_stmt -> FOR ( expr_stmt expr_stmt expr ) stmt .)
    GOTO            reduce using rule 85 (loop_stmt -> FOR ( expr_stmt expr_stmt expr ) stmt .)
    FOR             reduce using rule 85 (loop_stmt -> FOR ( expr_stmt expr_stmt expr ) stmt .)
    DO              reduce using rule 85 (loop_stmt -> FOR ( expr_stmt expr_stmt expr ) stmt .)
    WHILE           reduce using rule 85 (loop_stmt -> FOR ( expr_stmt expr_stmt expr ) stmt .)
    IF              reduce using rule 85 (loop_stmt -> FOR ( expr_stmt expr_stmt expr ) stmt .)
    ;               reduce using rule 85 (loop_stmt -> FOR ( expr_stmt expr_stmt expr ) stmt .)
    {               reduce using rule 85 (loop_stmt -> FOR ( expr_stmt expr_stmt expr ) stmt .)
    IDENTIFIER      reduce using rule 85 (loop_stmt -> FOR ( expr_stmt expr_stmt expr ) stmt .)
    VOID            reduce using rule 85 (loop_stmt -> FOR ( expr_stmt expr_stmt expr ) stmt .)
    STRING_T        reduce using rule 85 (loop_stmt -> FOR ( expr_stmt expr_stmt expr ) stmt .)
    DOUBLE          reduce using rule 85 (loop_stmt -> FOR ( expr_stmt expr_stmt expr ) stmt .)
    INT             reduce using rule 85 (loop_stmt -> FOR ( expr_stmt expr_stmt expr ) stmt .)
    !               reduce using rule 85 (loop_stmt -> FOR ( expr_stmt expr_stmt expr ) stmt .)
    -               reduce using rule 85 (loop_stmt -> FOR ( expr_stmt expr_stmt expr ) stmt .)
    +               reduce using rule 85 (loop_stmt -> FOR ( expr_stmt expr_stmt expr ) stmt .)
    DEC             reduce using rule 85 (loop_stmt -> FOR ( expr_stmt expr_stmt expr ) stmt .)
    INC             reduce using rule 85 (loop_stmt -> FOR ( expr_stmt expr_stmt expr ) stmt .)
    (               reduce using rule 85 (loop_stmt -> FOR ( expr_stmt expr_stmt expr ) stmt .)
    FLOAT           reduce using rule 85 (loop_stmt -> FOR ( expr_stmt expr_stmt expr ) stmt .)
    INTEGER         reduce using rule 85 (loop_stmt -> FOR ( expr_stmt expr_stmt expr ) stmt .)
    ELSE            reduce using rule 85 (loop_stmt -> FOR ( expr_stmt expr_stmt expr ) stmt .)


state 191

    (86) loop_stmt -> DO stmt WHILE ( expr ) ; .
    }               reduce using rule 86 (loop_stmt -> DO stmt WHILE ( expr ) ; .)
    RETURN          reduce using rule 86 (loop_stmt -> DO stmt WHILE ( expr ) ; .)
    BREAK           reduce using rule 86 (loop_stmt -> DO stmt WHILE ( expr ) ; .)
    CONTINUE        reduce using rule 86 (loop_stmt -> DO stmt WHILE ( expr ) ; .)
    GOTO            reduce using rule 86 (loop_stmt -> DO stmt WHILE ( expr ) ; .)
    FOR             reduce using rule 86 (loop_stmt -> DO stmt WHILE ( expr ) ; .)
    DO              reduce using rule 86 (loop_stmt -> DO stmt WHILE ( expr ) ; .)
    WHILE           reduce using rule 86 (loop_stmt -> DO stmt WHILE ( expr ) ; .)
    IF              reduce using rule 86 (loop_stmt -> DO stmt WHILE ( expr ) ; .)
    ;               reduce using rule 86 (loop_stmt -> DO stmt WHILE ( expr ) ; .)
    {               reduce using rule 86 (loop_stmt -> DO stmt WHILE ( expr ) ; .)
    IDENTIFIER      reduce using rule 86 (loop_stmt -> DO stmt WHILE ( expr ) ; .)
    VOID            reduce using rule 86 (loop_stmt -> DO stmt WHILE ( expr ) ; .)
    STRING_T        reduce using rule 86 (loop_stmt -> DO stmt WHILE ( expr ) ; .)
    DOUBLE          reduce using rule 86 (loop_stmt -> DO stmt WHILE ( expr ) ; .)
    INT             reduce using rule 86 (loop_stmt -> DO stmt WHILE ( expr ) ; .)
    !               reduce using rule 86 (loop_stmt -> DO stmt WHILE ( expr ) ; .)
    -               reduce using rule 86 (loop_stmt -> DO stmt WHILE ( expr ) ; .)
    +               reduce using rule 86 (loop_stmt -> DO stmt WHILE ( expr ) ; .)
    DEC             reduce using rule 86 (loop_stmt -> DO stmt WHILE ( expr ) ; .)
    INC             reduce using rule 86 (loop_stmt -> DO stmt WHILE ( expr ) ; .)
    (               reduce using rule 86 (loop_stmt -> DO stmt WHILE ( expr ) ; .)
    FLOAT           reduce using rule 86 (loop_stmt -> DO stmt WHILE ( expr ) ; .)
    INTEGER         reduce using rule 86 (loop_stmt -> DO stmt WHILE ( expr ) ; .)
    ELSE            reduce using rule 86 (loop_stmt -> DO stmt WHILE ( expr ) ; .)


state 192

    (83) if_stmt -> IF ( expr ) stmt ELSE stmt .
    }               reduce using rule 83 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    RETURN          reduce using rule 83 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    BREAK           reduce using rule 83 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    CONTINUE        reduce using rule 83 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    GOTO            reduce using rule 83 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FOR             reduce using rule 83 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    DO              reduce using rule 83 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    WHILE           reduce using rule 83 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IF              reduce using rule 83 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ;               reduce using rule 83 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    {               reduce using rule 83 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    IDENTIFIER      reduce using rule 83 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    VOID            reduce using rule 83 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    STRING_T        reduce using rule 83 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    DOUBLE          reduce using rule 83 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    INT             reduce using rule 83 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    !               reduce using rule 83 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    -               reduce using rule 83 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    +               reduce using rule 83 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    DEC             reduce using rule 83 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    INC             reduce using rule 83 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    (               reduce using rule 83 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    FLOAT           reduce using rule 83 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    INTEGER         reduce using rule 83 (if_stmt -> IF ( expr ) stmt ELSE stmt .)
    ELSE            reduce using rule 83 (if_stmt -> IF ( expr ) stmt ELSE stmt .)


Conflicts:

shift/reduce conflict for ELSE in state 186 resolved as shift