Grammar:

Rule 0     S' -> translation_unit
Rule 1     literal -> FLOAT
Rule 2     literal -> INTEGER
Rule 3     primary_expr -> LPARENT expr RPARENT
Rule 4     primary_expr -> literal
Rule 5     primary_expr -> IDENTIFIER
Rule 6     postfix_expr -> postfix_expr DEC
Rule 7     postfix_expr -> postfix_expr INC
Rule 8     postfix_expr -> postfix_expr DOT IDENTIFIER
Rule 9     postfix_expr -> postfix_expr LPARENT arg_expr_list RPARENT
Rule 10    postfix_expr -> postfix_expr LPARENT RPARENT
Rule 11    postfix_expr -> postfix_expr LBRACKET expr RBRACKET
Rule 12    postfix_expr -> primary_expr
Rule 13    arg_expr_list -> arg_expr_list COMMA expr
Rule 14    arg_expr_list -> expr
Rule 15    unary_expr -> NOT cast_expr
Rule 16    unary_expr -> MINUS cast_expr
Rule 17    unary_expr -> PLUS cast_expr
Rule 18    unary_expr -> DEC unary_expr
Rule 19    unary_expr -> INC unary_expr
Rule 20    unary_expr -> postfix_expr
Rule 21    cast_expr -> unary_expr
Rule 22    cast_expr -> LPARENT type RPARENT cast_expr
Rule 23    mult_expr -> mult_expr MOD cast_expr
Rule 24    mult_expr -> mult_expr DIV cast_expr
Rule 25    mult_expr -> mult_expr MUL cast_expr
Rule 26    mult_expr -> cast_expr
Rule 27    add_expr -> add_expr MINUS mult_expr
Rule 28    add_expr -> add_expr PLUS mult_expr
Rule 29    add_expr -> mult_expr
Rule 30    rel_expr -> rel_expr LE add_expr
Rule 31    rel_expr -> rel_expr GE add_expr
Rule 32    rel_expr -> rel_expr LT add_expr
Rule 33    rel_expr -> rel_expr GT add_expr
Rule 34    rel_expr -> add_expr
Rule 35    eq_expr -> eq_expr NE rel_expr
Rule 36    eq_expr -> eq_expr EQ rel_expr
Rule 37    eq_expr -> rel_expr
Rule 38    and_expr -> and_expr AND eq_expr
Rule 39    and_expr -> eq_expr
Rule 40    cond_expr -> cond_expr OR and_expr
Rule 41    cond_expr -> and_expr
Rule 42    expr -> unary_expr assignment_op expr
Rule 43    expr -> cond_expr
Rule 44    assignment_op -> ASSIGN
Rule 45    assignment_op -> MODEQ
Rule 46    assignment_op -> DIVEQ
Rule 47    assignment_op -> MULEQ
Rule 48    assignment_op -> MINUSEQ
Rule 49    assignment_op -> PLUSEQ
Rule 50    decl -> type init_declarator SEMICOLON
Rule 51    init_declarator -> declarator ASSIGN initializer
Rule 52    init_declarator -> declarator
Rule 53    type -> VOID
Rule 54    type -> STRING_T
Rule 55    type -> DOUBLE
Rule 56    type -> INT
Rule 57    declarator -> declarator LBRACKET RBRACKET
Rule 58    declarator -> declarator LBRACKET cond_expr RBRACKET
Rule 59    declarator -> declarator LPARENT RPARENT
Rule 60    declarator -> declarator LPARENT param_list RPARENT
Rule 61    declarator -> IDENTIFIER
Rule 62    param_list -> param_list COMMA param_decl
Rule 63    param_list -> param_decl
Rule 64    param_decl -> type declarator
Rule 65    initializer -> LBRACE initializer_list RBRACE
Rule 66    initializer -> expr
Rule 67    initializer_list -> initializer_list COMMA initializer
Rule 68    initializer_list -> initializer
Rule 69    stmt -> jump_stmt
Rule 70    stmt -> loop_stmt
Rule 71    stmt -> if_stmt
Rule 72    stmt -> expr_stmt
Rule 73    stmt -> block_stmt
Rule 74    stmt -> labeled_stmt
Rule 75    labeled_stmt -> IDENTIFIER COLON stmt
Rule 76    block_stmt -> LBRACE stmt_list RBRACE
Rule 77    block_stmt -> LBRACE RBRACE
Rule 78    decl_list -> decl_list decl
Rule 79    decl_list -> decl
Rule 80    stmt_list -> stmt_list stmt
Rule 81    stmt_list -> stmt
Rule 82    expr_stmt -> decl
Rule 83    expr_stmt -> expr SEMICOLON
Rule 84    expr_stmt -> SEMICOLON
Rule 85    if_stmt -> IF LPARENT expr RPARENT stmt ELSE stmt
Rule 86    if_stmt -> IF LPARENT expr RPARENT stmt
Rule 87    loop_stmt -> FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt
Rule 88    loop_stmt -> DO stmt WHILE LPARENT expr RPARENT SEMICOLON
Rule 89    loop_stmt -> WHILE LPARENT expr RPARENT stmt
Rule 90    jump_stmt -> RETURN expr SEMICOLON
Rule 91    jump_stmt -> RETURN SEMICOLON
Rule 92    jump_stmt -> BREAK SEMICOLON
Rule 93    jump_stmt -> CONTINUE SEMICOLON
Rule 94    jump_stmt -> GOTO IDENTIFIER SEMICOLON
Rule 95    translation_unit -> translation_unit ext_decl
Rule 96    translation_unit -> ext_decl
Rule 97    ext_decl -> import_decl
Rule 98    ext_decl -> define_decl
Rule 99    ext_decl -> include_decl
Rule 100   ext_decl -> func_decl
Rule 101   ext_decl -> decl
Rule 102   func_decl -> type declarator block_stmt
Rule 103   include_decl -> INCLUDE STRING
Rule 104   define_decl -> DEFINE IDENTIFIER STRING
Rule 105   define_decl -> DEFINE IDENTIFIER literal
Rule 106   define_decl -> DEFINE IDENTIFIER IDENTIFIER
Rule 107   import_decl -> IMPORT IDENTIFIER INTEGER INTEGER STRING IDENTIFIER

Terminals, with rules where they appear:

AND                  : 38
ASSIGN               : 44 51
BREAK                : 92
COLON                : 75
COMMA                : 13 62 67
CONTINUE             : 93
DEC                  : 6 18
DEFINE               : 104 105 106
DIV                  : 24
DIVEQ                : 46
DO                   : 88
DOT                  : 8
DOUBLE               : 55
ELSE                 : 85
EQ                   : 36
FLOAT                : 1
FOR                  : 87
GE                   : 31
GOTO                 : 94
GT                   : 33
IDENTIFIER           : 5 8 61 75 94 104 105 106 106 107 107
IF                   : 85 86
IMPORT               : 107
INC                  : 7 19
INCLUDE              : 103
INT                  : 56
INTEGER              : 2 107 107
LBRACE               : 65 76 77
LBRACKET             : 11 57 58
LE                   : 30
LPARENT              : 3 9 10 22 59 60 85 86 87 88 89
LT                   : 32
MINUS                : 16 27
MINUSEQ              : 48
MOD                  : 23
MODEQ                : 45
MUL                  : 25
MULEQ                : 47
NE                   : 35
NOT                  : 15
OR                   : 40
PLUS                 : 17 28
PLUSEQ               : 49
RBRACE               : 65 76 77
RBRACKET             : 11 57 58
RETURN               : 90 91
RPARENT              : 3 9 10 22 59 60 85 86 87 88 89
SEMICOLON            : 50 83 84 88 90 91 92 93 94
STRING               : 103 104 107
STRING_T             : 54
VOID                 : 53
WHILE                : 88 89
error                : 

Nonterminals, with rules where they appear:

add_expr             : 27 28 30 31 32 33 34
and_expr             : 38 40 41
arg_expr_list        : 9 13
assignment_op        : 42
block_stmt           : 73 102
cast_expr            : 15 16 17 22 23 24 25 26
cond_expr            : 40 43 58
decl                 : 78 79 82 101
decl_list            : 78
declarator           : 51 52 57 58 59 60 64 102
define_decl          : 98
eq_expr              : 35 36 38 39
expr                 : 3 11 13 14 42 66 83 85 86 87 88 89 90
expr_stmt            : 72 87 87
ext_decl             : 95 96
func_decl            : 100
if_stmt              : 71
import_decl          : 97
include_decl         : 99
init_declarator      : 50
initializer          : 51 67 68
initializer_list     : 65 67
jump_stmt            : 69
labeled_stmt         : 74
literal              : 4 105
loop_stmt            : 70
mult_expr            : 23 24 25 27 28 29
param_decl           : 62 63
param_list           : 60 62
postfix_expr         : 6 7 8 9 10 11 20
primary_expr         : 12
rel_expr             : 30 31 32 33 35 36 37
stmt                 : 75 80 81 85 85 86 87 88 89
stmt_list            : 76 80
translation_unit     : 95 0
type                 : 22 50 64 102
unary_expr           : 18 19 21 42


state 0

    (0) S' -> . translation_unit
    (95) translation_unit -> . translation_unit ext_decl
    (96) translation_unit -> . ext_decl
    (97) ext_decl -> . import_decl
    (98) ext_decl -> . define_decl
    (99) ext_decl -> . include_decl
    (100) ext_decl -> . func_decl
    (101) ext_decl -> . decl
    (107) import_decl -> . IMPORT IDENTIFIER INTEGER INTEGER STRING IDENTIFIER
    (104) define_decl -> . DEFINE IDENTIFIER STRING
    (105) define_decl -> . DEFINE IDENTIFIER literal
    (106) define_decl -> . DEFINE IDENTIFIER IDENTIFIER
    (103) include_decl -> . INCLUDE STRING
    (102) func_decl -> . type declarator block_stmt
    (50) decl -> . type init_declarator SEMICOLON
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    IMPORT          shift and go to state 8
    DEFINE          shift and go to state 9
    INCLUDE         shift and go to state 10
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15

    translation_unit               shift and go to state 1
    ext_decl                       shift and go to state 2
    import_decl                    shift and go to state 3
    define_decl                    shift and go to state 4
    include_decl                   shift and go to state 5
    func_decl                      shift and go to state 6
    decl                           shift and go to state 7
    type                           shift and go to state 11

state 1

    (0) S' -> translation_unit .
    (95) translation_unit -> translation_unit . ext_decl
    (97) ext_decl -> . import_decl
    (98) ext_decl -> . define_decl
    (99) ext_decl -> . include_decl
    (100) ext_decl -> . func_decl
    (101) ext_decl -> . decl
    (107) import_decl -> . IMPORT IDENTIFIER INTEGER INTEGER STRING IDENTIFIER
    (104) define_decl -> . DEFINE IDENTIFIER STRING
    (105) define_decl -> . DEFINE IDENTIFIER literal
    (106) define_decl -> . DEFINE IDENTIFIER IDENTIFIER
    (103) include_decl -> . INCLUDE STRING
    (102) func_decl -> . type declarator block_stmt
    (50) decl -> . type init_declarator SEMICOLON
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    IMPORT          shift and go to state 8
    DEFINE          shift and go to state 9
    INCLUDE         shift and go to state 10
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15

    ext_decl                       shift and go to state 16
    import_decl                    shift and go to state 3
    define_decl                    shift and go to state 4
    include_decl                   shift and go to state 5
    func_decl                      shift and go to state 6
    decl                           shift and go to state 7
    type                           shift and go to state 11

state 2

    (96) translation_unit -> ext_decl .
    IMPORT          reduce using rule 96 (translation_unit -> ext_decl .)
    DEFINE          reduce using rule 96 (translation_unit -> ext_decl .)
    INCLUDE         reduce using rule 96 (translation_unit -> ext_decl .)
    VOID            reduce using rule 96 (translation_unit -> ext_decl .)
    STRING_T        reduce using rule 96 (translation_unit -> ext_decl .)
    DOUBLE          reduce using rule 96 (translation_unit -> ext_decl .)
    INT             reduce using rule 96 (translation_unit -> ext_decl .)
    $end            reduce using rule 96 (translation_unit -> ext_decl .)


state 3

    (97) ext_decl -> import_decl .
    IMPORT          reduce using rule 97 (ext_decl -> import_decl .)
    DEFINE          reduce using rule 97 (ext_decl -> import_decl .)
    INCLUDE         reduce using rule 97 (ext_decl -> import_decl .)
    VOID            reduce using rule 97 (ext_decl -> import_decl .)
    STRING_T        reduce using rule 97 (ext_decl -> import_decl .)
    DOUBLE          reduce using rule 97 (ext_decl -> import_decl .)
    INT             reduce using rule 97 (ext_decl -> import_decl .)
    $end            reduce using rule 97 (ext_decl -> import_decl .)


state 4

    (98) ext_decl -> define_decl .
    IMPORT          reduce using rule 98 (ext_decl -> define_decl .)
    DEFINE          reduce using rule 98 (ext_decl -> define_decl .)
    INCLUDE         reduce using rule 98 (ext_decl -> define_decl .)
    VOID            reduce using rule 98 (ext_decl -> define_decl .)
    STRING_T        reduce using rule 98 (ext_decl -> define_decl .)
    DOUBLE          reduce using rule 98 (ext_decl -> define_decl .)
    INT             reduce using rule 98 (ext_decl -> define_decl .)
    $end            reduce using rule 98 (ext_decl -> define_decl .)


state 5

    (99) ext_decl -> include_decl .
    IMPORT          reduce using rule 99 (ext_decl -> include_decl .)
    DEFINE          reduce using rule 99 (ext_decl -> include_decl .)
    INCLUDE         reduce using rule 99 (ext_decl -> include_decl .)
    VOID            reduce using rule 99 (ext_decl -> include_decl .)
    STRING_T        reduce using rule 99 (ext_decl -> include_decl .)
    DOUBLE          reduce using rule 99 (ext_decl -> include_decl .)
    INT             reduce using rule 99 (ext_decl -> include_decl .)
    $end            reduce using rule 99 (ext_decl -> include_decl .)


state 6

    (100) ext_decl -> func_decl .
    IMPORT          reduce using rule 100 (ext_decl -> func_decl .)
    DEFINE          reduce using rule 100 (ext_decl -> func_decl .)
    INCLUDE         reduce using rule 100 (ext_decl -> func_decl .)
    VOID            reduce using rule 100 (ext_decl -> func_decl .)
    STRING_T        reduce using rule 100 (ext_decl -> func_decl .)
    DOUBLE          reduce using rule 100 (ext_decl -> func_decl .)
    INT             reduce using rule 100 (ext_decl -> func_decl .)
    $end            reduce using rule 100 (ext_decl -> func_decl .)


state 7

    (101) ext_decl -> decl .
    IMPORT          reduce using rule 101 (ext_decl -> decl .)
    DEFINE          reduce using rule 101 (ext_decl -> decl .)
    INCLUDE         reduce using rule 101 (ext_decl -> decl .)
    VOID            reduce using rule 101 (ext_decl -> decl .)
    STRING_T        reduce using rule 101 (ext_decl -> decl .)
    DOUBLE          reduce using rule 101 (ext_decl -> decl .)
    INT             reduce using rule 101 (ext_decl -> decl .)
    $end            reduce using rule 101 (ext_decl -> decl .)


state 8

    (107) import_decl -> IMPORT . IDENTIFIER INTEGER INTEGER STRING IDENTIFIER
    IDENTIFIER      shift and go to state 17


state 9

    (104) define_decl -> DEFINE . IDENTIFIER STRING
    (105) define_decl -> DEFINE . IDENTIFIER literal
    (106) define_decl -> DEFINE . IDENTIFIER IDENTIFIER
    IDENTIFIER      shift and go to state 18


state 10

    (103) include_decl -> INCLUDE . STRING
    STRING          shift and go to state 19


state 11

    (102) func_decl -> type . declarator block_stmt
    (50) decl -> type . init_declarator SEMICOLON
    (57) declarator -> . declarator LBRACKET RBRACKET
    (58) declarator -> . declarator LBRACKET cond_expr RBRACKET
    (59) declarator -> . declarator LPARENT RPARENT
    (60) declarator -> . declarator LPARENT param_list RPARENT
    (61) declarator -> . IDENTIFIER
    (51) init_declarator -> . declarator ASSIGN initializer
    (52) init_declarator -> . declarator
    IDENTIFIER      shift and go to state 22

    declarator                     shift and go to state 20
    init_declarator                shift and go to state 21

state 12

    (53) type -> VOID .
    IDENTIFIER      reduce using rule 53 (type -> VOID .)
    RPARENT         reduce using rule 53 (type -> VOID .)


state 13

    (54) type -> STRING_T .
    IDENTIFIER      reduce using rule 54 (type -> STRING_T .)
    RPARENT         reduce using rule 54 (type -> STRING_T .)


state 14

    (55) type -> DOUBLE .
    IDENTIFIER      reduce using rule 55 (type -> DOUBLE .)
    RPARENT         reduce using rule 55 (type -> DOUBLE .)


state 15

    (56) type -> INT .
    IDENTIFIER      reduce using rule 56 (type -> INT .)
    RPARENT         reduce using rule 56 (type -> INT .)


state 16

    (95) translation_unit -> translation_unit ext_decl .
    IMPORT          reduce using rule 95 (translation_unit -> translation_unit ext_decl .)
    DEFINE          reduce using rule 95 (translation_unit -> translation_unit ext_decl .)
    INCLUDE         reduce using rule 95 (translation_unit -> translation_unit ext_decl .)
    VOID            reduce using rule 95 (translation_unit -> translation_unit ext_decl .)
    STRING_T        reduce using rule 95 (translation_unit -> translation_unit ext_decl .)
    DOUBLE          reduce using rule 95 (translation_unit -> translation_unit ext_decl .)
    INT             reduce using rule 95 (translation_unit -> translation_unit ext_decl .)
    $end            reduce using rule 95 (translation_unit -> translation_unit ext_decl .)


state 17

    (107) import_decl -> IMPORT IDENTIFIER . INTEGER INTEGER STRING IDENTIFIER
    INTEGER         shift and go to state 23


state 18

    (104) define_decl -> DEFINE IDENTIFIER . STRING
    (105) define_decl -> DEFINE IDENTIFIER . literal
    (106) define_decl -> DEFINE IDENTIFIER . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    STRING          shift and go to state 25
    IDENTIFIER      shift and go to state 24
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    literal                        shift and go to state 26

state 19

    (103) include_decl -> INCLUDE STRING .
    IMPORT          reduce using rule 103 (include_decl -> INCLUDE STRING .)
    DEFINE          reduce using rule 103 (include_decl -> INCLUDE STRING .)
    INCLUDE         reduce using rule 103 (include_decl -> INCLUDE STRING .)
    VOID            reduce using rule 103 (include_decl -> INCLUDE STRING .)
    STRING_T        reduce using rule 103 (include_decl -> INCLUDE STRING .)
    DOUBLE          reduce using rule 103 (include_decl -> INCLUDE STRING .)
    INT             reduce using rule 103 (include_decl -> INCLUDE STRING .)
    $end            reduce using rule 103 (include_decl -> INCLUDE STRING .)


state 20

    (102) func_decl -> type declarator . block_stmt
    (57) declarator -> declarator . LBRACKET RBRACKET
    (58) declarator -> declarator . LBRACKET cond_expr RBRACKET
    (59) declarator -> declarator . LPARENT RPARENT
    (60) declarator -> declarator . LPARENT param_list RPARENT
    (51) init_declarator -> declarator . ASSIGN initializer
    (52) init_declarator -> declarator .
    (76) block_stmt -> . LBRACE stmt_list RBRACE
    (77) block_stmt -> . LBRACE RBRACE
    LBRACKET        shift and go to state 30
    LPARENT         shift and go to state 31
    ASSIGN          shift and go to state 32
    SEMICOLON       reduce using rule 52 (init_declarator -> declarator .)
    LBRACE          shift and go to state 33

    block_stmt                     shift and go to state 29

state 21

    (50) decl -> type init_declarator . SEMICOLON
    SEMICOLON       shift and go to state 34


state 22

    (61) declarator -> IDENTIFIER .
    LBRACKET        reduce using rule 61 (declarator -> IDENTIFIER .)
    LPARENT         reduce using rule 61 (declarator -> IDENTIFIER .)
    ASSIGN          reduce using rule 61 (declarator -> IDENTIFIER .)
    LBRACE          reduce using rule 61 (declarator -> IDENTIFIER .)
    SEMICOLON       reduce using rule 61 (declarator -> IDENTIFIER .)
    RPARENT         reduce using rule 61 (declarator -> IDENTIFIER .)
    COMMA           reduce using rule 61 (declarator -> IDENTIFIER .)


state 23

    (107) import_decl -> IMPORT IDENTIFIER INTEGER . INTEGER STRING IDENTIFIER
    INTEGER         shift and go to state 35


state 24

    (106) define_decl -> DEFINE IDENTIFIER IDENTIFIER .
    IMPORT          reduce using rule 106 (define_decl -> DEFINE IDENTIFIER IDENTIFIER .)
    DEFINE          reduce using rule 106 (define_decl -> DEFINE IDENTIFIER IDENTIFIER .)
    INCLUDE         reduce using rule 106 (define_decl -> DEFINE IDENTIFIER IDENTIFIER .)
    VOID            reduce using rule 106 (define_decl -> DEFINE IDENTIFIER IDENTIFIER .)
    STRING_T        reduce using rule 106 (define_decl -> DEFINE IDENTIFIER IDENTIFIER .)
    DOUBLE          reduce using rule 106 (define_decl -> DEFINE IDENTIFIER IDENTIFIER .)
    INT             reduce using rule 106 (define_decl -> DEFINE IDENTIFIER IDENTIFIER .)
    $end            reduce using rule 106 (define_decl -> DEFINE IDENTIFIER IDENTIFIER .)


state 25

    (104) define_decl -> DEFINE IDENTIFIER STRING .
    IMPORT          reduce using rule 104 (define_decl -> DEFINE IDENTIFIER STRING .)
    DEFINE          reduce using rule 104 (define_decl -> DEFINE IDENTIFIER STRING .)
    INCLUDE         reduce using rule 104 (define_decl -> DEFINE IDENTIFIER STRING .)
    VOID            reduce using rule 104 (define_decl -> DEFINE IDENTIFIER STRING .)
    STRING_T        reduce using rule 104 (define_decl -> DEFINE IDENTIFIER STRING .)
    DOUBLE          reduce using rule 104 (define_decl -> DEFINE IDENTIFIER STRING .)
    INT             reduce using rule 104 (define_decl -> DEFINE IDENTIFIER STRING .)
    $end            reduce using rule 104 (define_decl -> DEFINE IDENTIFIER STRING .)


state 26

    (105) define_decl -> DEFINE IDENTIFIER literal .
    IMPORT          reduce using rule 105 (define_decl -> DEFINE IDENTIFIER literal .)
    DEFINE          reduce using rule 105 (define_decl -> DEFINE IDENTIFIER literal .)
    INCLUDE         reduce using rule 105 (define_decl -> DEFINE IDENTIFIER literal .)
    VOID            reduce using rule 105 (define_decl -> DEFINE IDENTIFIER literal .)
    STRING_T        reduce using rule 105 (define_decl -> DEFINE IDENTIFIER literal .)
    DOUBLE          reduce using rule 105 (define_decl -> DEFINE IDENTIFIER literal .)
    INT             reduce using rule 105 (define_decl -> DEFINE IDENTIFIER literal .)
    $end            reduce using rule 105 (define_decl -> DEFINE IDENTIFIER literal .)


state 27

    (1) literal -> FLOAT .
    IMPORT          reduce using rule 1 (literal -> FLOAT .)
    DEFINE          reduce using rule 1 (literal -> FLOAT .)
    INCLUDE         reduce using rule 1 (literal -> FLOAT .)
    VOID            reduce using rule 1 (literal -> FLOAT .)
    STRING_T        reduce using rule 1 (literal -> FLOAT .)
    DOUBLE          reduce using rule 1 (literal -> FLOAT .)
    INT             reduce using rule 1 (literal -> FLOAT .)
    $end            reduce using rule 1 (literal -> FLOAT .)
    DEC             reduce using rule 1 (literal -> FLOAT .)
    INC             reduce using rule 1 (literal -> FLOAT .)
    DOT             reduce using rule 1 (literal -> FLOAT .)
    LPARENT         reduce using rule 1 (literal -> FLOAT .)
    LBRACKET        reduce using rule 1 (literal -> FLOAT .)
    MOD             reduce using rule 1 (literal -> FLOAT .)
    DIV             reduce using rule 1 (literal -> FLOAT .)
    MUL             reduce using rule 1 (literal -> FLOAT .)
    MINUS           reduce using rule 1 (literal -> FLOAT .)
    PLUS            reduce using rule 1 (literal -> FLOAT .)
    LE              reduce using rule 1 (literal -> FLOAT .)
    GE              reduce using rule 1 (literal -> FLOAT .)
    LT              reduce using rule 1 (literal -> FLOAT .)
    GT              reduce using rule 1 (literal -> FLOAT .)
    NE              reduce using rule 1 (literal -> FLOAT .)
    EQ              reduce using rule 1 (literal -> FLOAT .)
    AND             reduce using rule 1 (literal -> FLOAT .)
    RBRACKET        reduce using rule 1 (literal -> FLOAT .)
    OR              reduce using rule 1 (literal -> FLOAT .)
    ASSIGN          reduce using rule 1 (literal -> FLOAT .)
    MODEQ           reduce using rule 1 (literal -> FLOAT .)
    DIVEQ           reduce using rule 1 (literal -> FLOAT .)
    MULEQ           reduce using rule 1 (literal -> FLOAT .)
    MINUSEQ         reduce using rule 1 (literal -> FLOAT .)
    PLUSEQ          reduce using rule 1 (literal -> FLOAT .)
    SEMICOLON       reduce using rule 1 (literal -> FLOAT .)
    RPARENT         reduce using rule 1 (literal -> FLOAT .)
    RBRACE          reduce using rule 1 (literal -> FLOAT .)
    COMMA           reduce using rule 1 (literal -> FLOAT .)


state 28

    (2) literal -> INTEGER .
    IMPORT          reduce using rule 2 (literal -> INTEGER .)
    DEFINE          reduce using rule 2 (literal -> INTEGER .)
    INCLUDE         reduce using rule 2 (literal -> INTEGER .)
    VOID            reduce using rule 2 (literal -> INTEGER .)
    STRING_T        reduce using rule 2 (literal -> INTEGER .)
    DOUBLE          reduce using rule 2 (literal -> INTEGER .)
    INT             reduce using rule 2 (literal -> INTEGER .)
    $end            reduce using rule 2 (literal -> INTEGER .)
    DEC             reduce using rule 2 (literal -> INTEGER .)
    INC             reduce using rule 2 (literal -> INTEGER .)
    DOT             reduce using rule 2 (literal -> INTEGER .)
    LPARENT         reduce using rule 2 (literal -> INTEGER .)
    LBRACKET        reduce using rule 2 (literal -> INTEGER .)
    MOD             reduce using rule 2 (literal -> INTEGER .)
    DIV             reduce using rule 2 (literal -> INTEGER .)
    MUL             reduce using rule 2 (literal -> INTEGER .)
    MINUS           reduce using rule 2 (literal -> INTEGER .)
    PLUS            reduce using rule 2 (literal -> INTEGER .)
    LE              reduce using rule 2 (literal -> INTEGER .)
    GE              reduce using rule 2 (literal -> INTEGER .)
    LT              reduce using rule 2 (literal -> INTEGER .)
    GT              reduce using rule 2 (literal -> INTEGER .)
    NE              reduce using rule 2 (literal -> INTEGER .)
    EQ              reduce using rule 2 (literal -> INTEGER .)
    AND             reduce using rule 2 (literal -> INTEGER .)
    RBRACKET        reduce using rule 2 (literal -> INTEGER .)
    OR              reduce using rule 2 (literal -> INTEGER .)
    ASSIGN          reduce using rule 2 (literal -> INTEGER .)
    MODEQ           reduce using rule 2 (literal -> INTEGER .)
    DIVEQ           reduce using rule 2 (literal -> INTEGER .)
    MULEQ           reduce using rule 2 (literal -> INTEGER .)
    MINUSEQ         reduce using rule 2 (literal -> INTEGER .)
    PLUSEQ          reduce using rule 2 (literal -> INTEGER .)
    SEMICOLON       reduce using rule 2 (literal -> INTEGER .)
    RPARENT         reduce using rule 2 (literal -> INTEGER .)
    RBRACE          reduce using rule 2 (literal -> INTEGER .)
    COMMA           reduce using rule 2 (literal -> INTEGER .)


state 29

    (102) func_decl -> type declarator block_stmt .
    IMPORT          reduce using rule 102 (func_decl -> type declarator block_stmt .)
    DEFINE          reduce using rule 102 (func_decl -> type declarator block_stmt .)
    INCLUDE         reduce using rule 102 (func_decl -> type declarator block_stmt .)
    VOID            reduce using rule 102 (func_decl -> type declarator block_stmt .)
    STRING_T        reduce using rule 102 (func_decl -> type declarator block_stmt .)
    DOUBLE          reduce using rule 102 (func_decl -> type declarator block_stmt .)
    INT             reduce using rule 102 (func_decl -> type declarator block_stmt .)
    $end            reduce using rule 102 (func_decl -> type declarator block_stmt .)


state 30

    (57) declarator -> declarator LBRACKET . RBRACKET
    (58) declarator -> declarator LBRACKET . cond_expr RBRACKET
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr LT add_expr
    (33) rel_expr -> . rel_expr GT add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    RBRACKET        shift and go to state 36
    LPARENT         shift and go to state 47
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    cond_expr                      shift and go to state 37
    and_expr                       shift and go to state 38
    eq_expr                        shift and go to state 39
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43
    cast_expr                      shift and go to state 45
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 31

    (59) declarator -> declarator LPARENT . RPARENT
    (60) declarator -> declarator LPARENT . param_list RPARENT
    (62) param_list -> . param_list COMMA param_decl
    (63) param_list -> . param_decl
    (64) param_decl -> . type declarator
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    RPARENT         shift and go to state 55
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15

    param_list                     shift and go to state 56
    param_decl                     shift and go to state 57
    type                           shift and go to state 58

state 32

    (51) init_declarator -> declarator ASSIGN . initializer
    (65) initializer -> . LBRACE initializer_list RBRACE
    (66) initializer -> . expr
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr LT add_expr
    (33) rel_expr -> . rel_expr GT add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    LBRACE          shift and go to state 60
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    LPARENT         shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    initializer                    shift and go to state 59
    expr                           shift and go to state 61
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 33

    (76) block_stmt -> LBRACE . stmt_list RBRACE
    (77) block_stmt -> LBRACE . RBRACE
    (80) stmt_list -> . stmt_list stmt
    (81) stmt_list -> . stmt
    (69) stmt -> . jump_stmt
    (70) stmt -> . loop_stmt
    (71) stmt -> . if_stmt
    (72) stmt -> . expr_stmt
    (73) stmt -> . block_stmt
    (74) stmt -> . labeled_stmt
    (90) jump_stmt -> . RETURN expr SEMICOLON
    (91) jump_stmt -> . RETURN SEMICOLON
    (92) jump_stmt -> . BREAK SEMICOLON
    (93) jump_stmt -> . CONTINUE SEMICOLON
    (94) jump_stmt -> . GOTO IDENTIFIER SEMICOLON
    (87) loop_stmt -> . FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt
    (88) loop_stmt -> . DO stmt WHILE LPARENT expr RPARENT SEMICOLON
    (89) loop_stmt -> . WHILE LPARENT expr RPARENT stmt
    (85) if_stmt -> . IF LPARENT expr RPARENT stmt ELSE stmt
    (86) if_stmt -> . IF LPARENT expr RPARENT stmt
    (82) expr_stmt -> . decl
    (83) expr_stmt -> . expr SEMICOLON
    (84) expr_stmt -> . SEMICOLON
    (76) block_stmt -> . LBRACE stmt_list RBRACE
    (77) block_stmt -> . LBRACE RBRACE
    (75) labeled_stmt -> . IDENTIFIER COLON stmt
    (50) decl -> . type init_declarator SEMICOLON
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr LT add_expr
    (33) rel_expr -> . rel_expr GT add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    RBRACE          shift and go to state 66
    RETURN          shift and go to state 74
    BREAK           shift and go to state 77
    CONTINUE        shift and go to state 78
    GOTO            shift and go to state 79
    FOR             shift and go to state 81
    DO              shift and go to state 82
    WHILE           shift and go to state 83
    IF              shift and go to state 84
    SEMICOLON       shift and go to state 76
    LBRACE          shift and go to state 33
    IDENTIFIER      shift and go to state 80
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    LPARENT         shift and go to state 64
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    stmt_list                      shift and go to state 65
    stmt                           shift and go to state 67
    jump_stmt                      shift and go to state 68
    loop_stmt                      shift and go to state 69
    if_stmt                        shift and go to state 70
    expr_stmt                      shift and go to state 71
    block_stmt                     shift and go to state 72
    labeled_stmt                   shift and go to state 73
    expr                           shift and go to state 75
    decl                           shift and go to state 85
    type                           shift and go to state 86
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 34

    (50) decl -> type init_declarator SEMICOLON .
    IMPORT          reduce using rule 50 (decl -> type init_declarator SEMICOLON .)
    DEFINE          reduce using rule 50 (decl -> type init_declarator SEMICOLON .)
    INCLUDE         reduce using rule 50 (decl -> type init_declarator SEMICOLON .)
    VOID            reduce using rule 50 (decl -> type init_declarator SEMICOLON .)
    STRING_T        reduce using rule 50 (decl -> type init_declarator SEMICOLON .)
    DOUBLE          reduce using rule 50 (decl -> type init_declarator SEMICOLON .)
    INT             reduce using rule 50 (decl -> type init_declarator SEMICOLON .)
    $end            reduce using rule 50 (decl -> type init_declarator SEMICOLON .)
    RBRACE          reduce using rule 50 (decl -> type init_declarator SEMICOLON .)
    RETURN          reduce using rule 50 (decl -> type init_declarator SEMICOLON .)
    BREAK           reduce using rule 50 (decl -> type init_declarator SEMICOLON .)
    CONTINUE        reduce using rule 50 (decl -> type init_declarator SEMICOLON .)
    GOTO            reduce using rule 50 (decl -> type init_declarator SEMICOLON .)
    FOR             reduce using rule 50 (decl -> type init_declarator SEMICOLON .)
    DO              reduce using rule 50 (decl -> type init_declarator SEMICOLON .)
    WHILE           reduce using rule 50 (decl -> type init_declarator SEMICOLON .)
    IF              reduce using rule 50 (decl -> type init_declarator SEMICOLON .)
    SEMICOLON       reduce using rule 50 (decl -> type init_declarator SEMICOLON .)
    LBRACE          reduce using rule 50 (decl -> type init_declarator SEMICOLON .)
    IDENTIFIER      reduce using rule 50 (decl -> type init_declarator SEMICOLON .)
    NOT             reduce using rule 50 (decl -> type init_declarator SEMICOLON .)
    MINUS           reduce using rule 50 (decl -> type init_declarator SEMICOLON .)
    PLUS            reduce using rule 50 (decl -> type init_declarator SEMICOLON .)
    DEC             reduce using rule 50 (decl -> type init_declarator SEMICOLON .)
    INC             reduce using rule 50 (decl -> type init_declarator SEMICOLON .)
    LPARENT         reduce using rule 50 (decl -> type init_declarator SEMICOLON .)
    FLOAT           reduce using rule 50 (decl -> type init_declarator SEMICOLON .)
    INTEGER         reduce using rule 50 (decl -> type init_declarator SEMICOLON .)
    ELSE            reduce using rule 50 (decl -> type init_declarator SEMICOLON .)


state 35

    (107) import_decl -> IMPORT IDENTIFIER INTEGER INTEGER . STRING IDENTIFIER
    STRING          shift and go to state 87


state 36

    (57) declarator -> declarator LBRACKET RBRACKET .
    LBRACKET        reduce using rule 57 (declarator -> declarator LBRACKET RBRACKET .)
    LPARENT         reduce using rule 57 (declarator -> declarator LBRACKET RBRACKET .)
    ASSIGN          reduce using rule 57 (declarator -> declarator LBRACKET RBRACKET .)
    LBRACE          reduce using rule 57 (declarator -> declarator LBRACKET RBRACKET .)
    SEMICOLON       reduce using rule 57 (declarator -> declarator LBRACKET RBRACKET .)
    RPARENT         reduce using rule 57 (declarator -> declarator LBRACKET RBRACKET .)
    COMMA           reduce using rule 57 (declarator -> declarator LBRACKET RBRACKET .)


state 37

    (58) declarator -> declarator LBRACKET cond_expr . RBRACKET
    (40) cond_expr -> cond_expr . OR and_expr
    RBRACKET        shift and go to state 88
    OR              shift and go to state 89


state 38

    (41) cond_expr -> and_expr .
    (38) and_expr -> and_expr . AND eq_expr
    RBRACKET        reduce using rule 41 (cond_expr -> and_expr .)
    OR              reduce using rule 41 (cond_expr -> and_expr .)
    SEMICOLON       reduce using rule 41 (cond_expr -> and_expr .)
    RPARENT         reduce using rule 41 (cond_expr -> and_expr .)
    RBRACE          reduce using rule 41 (cond_expr -> and_expr .)
    COMMA           reduce using rule 41 (cond_expr -> and_expr .)
    AND             shift and go to state 90


state 39

    (39) and_expr -> eq_expr .
    (35) eq_expr -> eq_expr . NE rel_expr
    (36) eq_expr -> eq_expr . EQ rel_expr
    AND             reduce using rule 39 (and_expr -> eq_expr .)
    RBRACKET        reduce using rule 39 (and_expr -> eq_expr .)
    OR              reduce using rule 39 (and_expr -> eq_expr .)
    SEMICOLON       reduce using rule 39 (and_expr -> eq_expr .)
    RPARENT         reduce using rule 39 (and_expr -> eq_expr .)
    RBRACE          reduce using rule 39 (and_expr -> eq_expr .)
    COMMA           reduce using rule 39 (and_expr -> eq_expr .)
    NE              shift and go to state 91
    EQ              shift and go to state 92


state 40

    (37) eq_expr -> rel_expr .
    (30) rel_expr -> rel_expr . LE add_expr
    (31) rel_expr -> rel_expr . GE add_expr
    (32) rel_expr -> rel_expr . LT add_expr
    (33) rel_expr -> rel_expr . GT add_expr
    NE              reduce using rule 37 (eq_expr -> rel_expr .)
    EQ              reduce using rule 37 (eq_expr -> rel_expr .)
    AND             reduce using rule 37 (eq_expr -> rel_expr .)
    RBRACKET        reduce using rule 37 (eq_expr -> rel_expr .)
    OR              reduce using rule 37 (eq_expr -> rel_expr .)
    SEMICOLON       reduce using rule 37 (eq_expr -> rel_expr .)
    RPARENT         reduce using rule 37 (eq_expr -> rel_expr .)
    RBRACE          reduce using rule 37 (eq_expr -> rel_expr .)
    COMMA           reduce using rule 37 (eq_expr -> rel_expr .)
    LE              shift and go to state 93
    GE              shift and go to state 94
    LT              shift and go to state 95
    GT              shift and go to state 96


state 41

    (34) rel_expr -> add_expr .
    (27) add_expr -> add_expr . MINUS mult_expr
    (28) add_expr -> add_expr . PLUS mult_expr
    LE              reduce using rule 34 (rel_expr -> add_expr .)
    GE              reduce using rule 34 (rel_expr -> add_expr .)
    LT              reduce using rule 34 (rel_expr -> add_expr .)
    GT              reduce using rule 34 (rel_expr -> add_expr .)
    NE              reduce using rule 34 (rel_expr -> add_expr .)
    EQ              reduce using rule 34 (rel_expr -> add_expr .)
    AND             reduce using rule 34 (rel_expr -> add_expr .)
    RBRACKET        reduce using rule 34 (rel_expr -> add_expr .)
    OR              reduce using rule 34 (rel_expr -> add_expr .)
    SEMICOLON       reduce using rule 34 (rel_expr -> add_expr .)
    RPARENT         reduce using rule 34 (rel_expr -> add_expr .)
    RBRACE          reduce using rule 34 (rel_expr -> add_expr .)
    COMMA           reduce using rule 34 (rel_expr -> add_expr .)
    MINUS           shift and go to state 97
    PLUS            shift and go to state 98


state 42

    (16) unary_expr -> MINUS . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    LPARENT         shift and go to state 47
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    cast_expr                      shift and go to state 99
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 43

    (29) add_expr -> mult_expr .
    (23) mult_expr -> mult_expr . MOD cast_expr
    (24) mult_expr -> mult_expr . DIV cast_expr
    (25) mult_expr -> mult_expr . MUL cast_expr
    MINUS           reduce using rule 29 (add_expr -> mult_expr .)
    PLUS            reduce using rule 29 (add_expr -> mult_expr .)
    LE              reduce using rule 29 (add_expr -> mult_expr .)
    GE              reduce using rule 29 (add_expr -> mult_expr .)
    LT              reduce using rule 29 (add_expr -> mult_expr .)
    GT              reduce using rule 29 (add_expr -> mult_expr .)
    NE              reduce using rule 29 (add_expr -> mult_expr .)
    EQ              reduce using rule 29 (add_expr -> mult_expr .)
    AND             reduce using rule 29 (add_expr -> mult_expr .)
    RBRACKET        reduce using rule 29 (add_expr -> mult_expr .)
    OR              reduce using rule 29 (add_expr -> mult_expr .)
    SEMICOLON       reduce using rule 29 (add_expr -> mult_expr .)
    RPARENT         reduce using rule 29 (add_expr -> mult_expr .)
    RBRACE          reduce using rule 29 (add_expr -> mult_expr .)
    COMMA           reduce using rule 29 (add_expr -> mult_expr .)
    MOD             shift and go to state 100
    DIV             shift and go to state 101
    MUL             shift and go to state 102


state 44

    (17) unary_expr -> PLUS . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    LPARENT         shift and go to state 47
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    cast_expr                      shift and go to state 103
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 45

    (26) mult_expr -> cast_expr .
    MOD             reduce using rule 26 (mult_expr -> cast_expr .)
    DIV             reduce using rule 26 (mult_expr -> cast_expr .)
    MUL             reduce using rule 26 (mult_expr -> cast_expr .)
    MINUS           reduce using rule 26 (mult_expr -> cast_expr .)
    PLUS            reduce using rule 26 (mult_expr -> cast_expr .)
    LE              reduce using rule 26 (mult_expr -> cast_expr .)
    GE              reduce using rule 26 (mult_expr -> cast_expr .)
    LT              reduce using rule 26 (mult_expr -> cast_expr .)
    GT              reduce using rule 26 (mult_expr -> cast_expr .)
    NE              reduce using rule 26 (mult_expr -> cast_expr .)
    EQ              reduce using rule 26 (mult_expr -> cast_expr .)
    AND             reduce using rule 26 (mult_expr -> cast_expr .)
    RBRACKET        reduce using rule 26 (mult_expr -> cast_expr .)
    OR              reduce using rule 26 (mult_expr -> cast_expr .)
    SEMICOLON       reduce using rule 26 (mult_expr -> cast_expr .)
    RPARENT         reduce using rule 26 (mult_expr -> cast_expr .)
    RBRACE          reduce using rule 26 (mult_expr -> cast_expr .)
    COMMA           reduce using rule 26 (mult_expr -> cast_expr .)


state 46

    (21) cast_expr -> unary_expr .
    MOD             reduce using rule 21 (cast_expr -> unary_expr .)
    DIV             reduce using rule 21 (cast_expr -> unary_expr .)
    MUL             reduce using rule 21 (cast_expr -> unary_expr .)
    MINUS           reduce using rule 21 (cast_expr -> unary_expr .)
    PLUS            reduce using rule 21 (cast_expr -> unary_expr .)
    LE              reduce using rule 21 (cast_expr -> unary_expr .)
    GE              reduce using rule 21 (cast_expr -> unary_expr .)
    LT              reduce using rule 21 (cast_expr -> unary_expr .)
    GT              reduce using rule 21 (cast_expr -> unary_expr .)
    NE              reduce using rule 21 (cast_expr -> unary_expr .)
    EQ              reduce using rule 21 (cast_expr -> unary_expr .)
    AND             reduce using rule 21 (cast_expr -> unary_expr .)
    RBRACKET        reduce using rule 21 (cast_expr -> unary_expr .)
    OR              reduce using rule 21 (cast_expr -> unary_expr .)
    ASSIGN          reduce using rule 21 (cast_expr -> unary_expr .)
    MODEQ           reduce using rule 21 (cast_expr -> unary_expr .)
    DIVEQ           reduce using rule 21 (cast_expr -> unary_expr .)
    MULEQ           reduce using rule 21 (cast_expr -> unary_expr .)
    MINUSEQ         reduce using rule 21 (cast_expr -> unary_expr .)
    PLUSEQ          reduce using rule 21 (cast_expr -> unary_expr .)
    SEMICOLON       reduce using rule 21 (cast_expr -> unary_expr .)
    RPARENT         reduce using rule 21 (cast_expr -> unary_expr .)
    RBRACE          reduce using rule 21 (cast_expr -> unary_expr .)
    COMMA           reduce using rule 21 (cast_expr -> unary_expr .)


state 47

    (22) cast_expr -> LPARENT . type RPARENT cast_expr
    (3) primary_expr -> LPARENT . expr RPARENT
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr LT add_expr
    (33) rel_expr -> . rel_expr GT add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    LPARENT         shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    type                           shift and go to state 104
    cast_expr                      shift and go to state 45
    expr                           shift and go to state 105
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 48

    (15) unary_expr -> NOT . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    LPARENT         shift and go to state 47
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    cast_expr                      shift and go to state 106
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 49

    (18) unary_expr -> DEC . unary_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    LPARENT         shift and go to state 108
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    unary_expr                     shift and go to state 107
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 50

    (19) unary_expr -> INC . unary_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    LPARENT         shift and go to state 108
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    unary_expr                     shift and go to state 109
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 51

    (20) unary_expr -> postfix_expr .
    (6) postfix_expr -> postfix_expr . DEC
    (7) postfix_expr -> postfix_expr . INC
    (8) postfix_expr -> postfix_expr . DOT IDENTIFIER
    (9) postfix_expr -> postfix_expr . LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> postfix_expr . LPARENT RPARENT
    (11) postfix_expr -> postfix_expr . LBRACKET expr RBRACKET
    MOD             reduce using rule 20 (unary_expr -> postfix_expr .)
    DIV             reduce using rule 20 (unary_expr -> postfix_expr .)
    MUL             reduce using rule 20 (unary_expr -> postfix_expr .)
    MINUS           reduce using rule 20 (unary_expr -> postfix_expr .)
    PLUS            reduce using rule 20 (unary_expr -> postfix_expr .)
    LE              reduce using rule 20 (unary_expr -> postfix_expr .)
    GE              reduce using rule 20 (unary_expr -> postfix_expr .)
    LT              reduce using rule 20 (unary_expr -> postfix_expr .)
    GT              reduce using rule 20 (unary_expr -> postfix_expr .)
    NE              reduce using rule 20 (unary_expr -> postfix_expr .)
    EQ              reduce using rule 20 (unary_expr -> postfix_expr .)
    AND             reduce using rule 20 (unary_expr -> postfix_expr .)
    RBRACKET        reduce using rule 20 (unary_expr -> postfix_expr .)
    OR              reduce using rule 20 (unary_expr -> postfix_expr .)
    ASSIGN          reduce using rule 20 (unary_expr -> postfix_expr .)
    MODEQ           reduce using rule 20 (unary_expr -> postfix_expr .)
    DIVEQ           reduce using rule 20 (unary_expr -> postfix_expr .)
    MULEQ           reduce using rule 20 (unary_expr -> postfix_expr .)
    MINUSEQ         reduce using rule 20 (unary_expr -> postfix_expr .)
    PLUSEQ          reduce using rule 20 (unary_expr -> postfix_expr .)
    SEMICOLON       reduce using rule 20 (unary_expr -> postfix_expr .)
    RPARENT         reduce using rule 20 (unary_expr -> postfix_expr .)
    RBRACE          reduce using rule 20 (unary_expr -> postfix_expr .)
    COMMA           reduce using rule 20 (unary_expr -> postfix_expr .)
    DEC             shift and go to state 110
    INC             shift and go to state 111
    DOT             shift and go to state 112
    LPARENT         shift and go to state 113
    LBRACKET        shift and go to state 114


state 52

    (5) primary_expr -> IDENTIFIER .
    DEC             reduce using rule 5 (primary_expr -> IDENTIFIER .)
    INC             reduce using rule 5 (primary_expr -> IDENTIFIER .)
    DOT             reduce using rule 5 (primary_expr -> IDENTIFIER .)
    LPARENT         reduce using rule 5 (primary_expr -> IDENTIFIER .)
    LBRACKET        reduce using rule 5 (primary_expr -> IDENTIFIER .)
    MOD             reduce using rule 5 (primary_expr -> IDENTIFIER .)
    DIV             reduce using rule 5 (primary_expr -> IDENTIFIER .)
    MUL             reduce using rule 5 (primary_expr -> IDENTIFIER .)
    MINUS           reduce using rule 5 (primary_expr -> IDENTIFIER .)
    PLUS            reduce using rule 5 (primary_expr -> IDENTIFIER .)
    LE              reduce using rule 5 (primary_expr -> IDENTIFIER .)
    GE              reduce using rule 5 (primary_expr -> IDENTIFIER .)
    LT              reduce using rule 5 (primary_expr -> IDENTIFIER .)
    GT              reduce using rule 5 (primary_expr -> IDENTIFIER .)
    NE              reduce using rule 5 (primary_expr -> IDENTIFIER .)
    EQ              reduce using rule 5 (primary_expr -> IDENTIFIER .)
    AND             reduce using rule 5 (primary_expr -> IDENTIFIER .)
    RBRACKET        reduce using rule 5 (primary_expr -> IDENTIFIER .)
    OR              reduce using rule 5 (primary_expr -> IDENTIFIER .)
    ASSIGN          reduce using rule 5 (primary_expr -> IDENTIFIER .)
    MODEQ           reduce using rule 5 (primary_expr -> IDENTIFIER .)
    DIVEQ           reduce using rule 5 (primary_expr -> IDENTIFIER .)
    MULEQ           reduce using rule 5 (primary_expr -> IDENTIFIER .)
    MINUSEQ         reduce using rule 5 (primary_expr -> IDENTIFIER .)
    PLUSEQ          reduce using rule 5 (primary_expr -> IDENTIFIER .)
    SEMICOLON       reduce using rule 5 (primary_expr -> IDENTIFIER .)
    RPARENT         reduce using rule 5 (primary_expr -> IDENTIFIER .)
    RBRACE          reduce using rule 5 (primary_expr -> IDENTIFIER .)
    COMMA           reduce using rule 5 (primary_expr -> IDENTIFIER .)


state 53

    (12) postfix_expr -> primary_expr .
    DEC             reduce using rule 12 (postfix_expr -> primary_expr .)
    INC             reduce using rule 12 (postfix_expr -> primary_expr .)
    DOT             reduce using rule 12 (postfix_expr -> primary_expr .)
    LPARENT         reduce using rule 12 (postfix_expr -> primary_expr .)
    LBRACKET        reduce using rule 12 (postfix_expr -> primary_expr .)
    MOD             reduce using rule 12 (postfix_expr -> primary_expr .)
    DIV             reduce using rule 12 (postfix_expr -> primary_expr .)
    MUL             reduce using rule 12 (postfix_expr -> primary_expr .)
    MINUS           reduce using rule 12 (postfix_expr -> primary_expr .)
    PLUS            reduce using rule 12 (postfix_expr -> primary_expr .)
    LE              reduce using rule 12 (postfix_expr -> primary_expr .)
    GE              reduce using rule 12 (postfix_expr -> primary_expr .)
    LT              reduce using rule 12 (postfix_expr -> primary_expr .)
    GT              reduce using rule 12 (postfix_expr -> primary_expr .)
    NE              reduce using rule 12 (postfix_expr -> primary_expr .)
    EQ              reduce using rule 12 (postfix_expr -> primary_expr .)
    AND             reduce using rule 12 (postfix_expr -> primary_expr .)
    RBRACKET        reduce using rule 12 (postfix_expr -> primary_expr .)
    OR              reduce using rule 12 (postfix_expr -> primary_expr .)
    ASSIGN          reduce using rule 12 (postfix_expr -> primary_expr .)
    MODEQ           reduce using rule 12 (postfix_expr -> primary_expr .)
    DIVEQ           reduce using rule 12 (postfix_expr -> primary_expr .)
    MULEQ           reduce using rule 12 (postfix_expr -> primary_expr .)
    MINUSEQ         reduce using rule 12 (postfix_expr -> primary_expr .)
    PLUSEQ          reduce using rule 12 (postfix_expr -> primary_expr .)
    SEMICOLON       reduce using rule 12 (postfix_expr -> primary_expr .)
    RPARENT         reduce using rule 12 (postfix_expr -> primary_expr .)
    RBRACE          reduce using rule 12 (postfix_expr -> primary_expr .)
    COMMA           reduce using rule 12 (postfix_expr -> primary_expr .)


state 54

    (4) primary_expr -> literal .
    DEC             reduce using rule 4 (primary_expr -> literal .)
    INC             reduce using rule 4 (primary_expr -> literal .)
    DOT             reduce using rule 4 (primary_expr -> literal .)
    LPARENT         reduce using rule 4 (primary_expr -> literal .)
    LBRACKET        reduce using rule 4 (primary_expr -> literal .)
    MOD             reduce using rule 4 (primary_expr -> literal .)
    DIV             reduce using rule 4 (primary_expr -> literal .)
    MUL             reduce using rule 4 (primary_expr -> literal .)
    MINUS           reduce using rule 4 (primary_expr -> literal .)
    PLUS            reduce using rule 4 (primary_expr -> literal .)
    LE              reduce using rule 4 (primary_expr -> literal .)
    GE              reduce using rule 4 (primary_expr -> literal .)
    LT              reduce using rule 4 (primary_expr -> literal .)
    GT              reduce using rule 4 (primary_expr -> literal .)
    NE              reduce using rule 4 (primary_expr -> literal .)
    EQ              reduce using rule 4 (primary_expr -> literal .)
    AND             reduce using rule 4 (primary_expr -> literal .)
    RBRACKET        reduce using rule 4 (primary_expr -> literal .)
    OR              reduce using rule 4 (primary_expr -> literal .)
    ASSIGN          reduce using rule 4 (primary_expr -> literal .)
    MODEQ           reduce using rule 4 (primary_expr -> literal .)
    DIVEQ           reduce using rule 4 (primary_expr -> literal .)
    MULEQ           reduce using rule 4 (primary_expr -> literal .)
    MINUSEQ         reduce using rule 4 (primary_expr -> literal .)
    PLUSEQ          reduce using rule 4 (primary_expr -> literal .)
    SEMICOLON       reduce using rule 4 (primary_expr -> literal .)
    RPARENT         reduce using rule 4 (primary_expr -> literal .)
    RBRACE          reduce using rule 4 (primary_expr -> literal .)
    COMMA           reduce using rule 4 (primary_expr -> literal .)


state 55

    (59) declarator -> declarator LPARENT RPARENT .
    LBRACKET        reduce using rule 59 (declarator -> declarator LPARENT RPARENT .)
    LPARENT         reduce using rule 59 (declarator -> declarator LPARENT RPARENT .)
    ASSIGN          reduce using rule 59 (declarator -> declarator LPARENT RPARENT .)
    LBRACE          reduce using rule 59 (declarator -> declarator LPARENT RPARENT .)
    SEMICOLON       reduce using rule 59 (declarator -> declarator LPARENT RPARENT .)
    RPARENT         reduce using rule 59 (declarator -> declarator LPARENT RPARENT .)
    COMMA           reduce using rule 59 (declarator -> declarator LPARENT RPARENT .)


state 56

    (60) declarator -> declarator LPARENT param_list . RPARENT
    (62) param_list -> param_list . COMMA param_decl
    RPARENT         shift and go to state 115
    COMMA           shift and go to state 116


state 57

    (63) param_list -> param_decl .
    RPARENT         reduce using rule 63 (param_list -> param_decl .)
    COMMA           reduce using rule 63 (param_list -> param_decl .)


state 58

    (64) param_decl -> type . declarator
    (57) declarator -> . declarator LBRACKET RBRACKET
    (58) declarator -> . declarator LBRACKET cond_expr RBRACKET
    (59) declarator -> . declarator LPARENT RPARENT
    (60) declarator -> . declarator LPARENT param_list RPARENT
    (61) declarator -> . IDENTIFIER
    IDENTIFIER      shift and go to state 22

    declarator                     shift and go to state 117

state 59

    (51) init_declarator -> declarator ASSIGN initializer .
    SEMICOLON       reduce using rule 51 (init_declarator -> declarator ASSIGN initializer .)


state 60

    (65) initializer -> LBRACE . initializer_list RBRACE
    (67) initializer_list -> . initializer_list COMMA initializer
    (68) initializer_list -> . initializer
    (65) initializer -> . LBRACE initializer_list RBRACE
    (66) initializer -> . expr
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr LT add_expr
    (33) rel_expr -> . rel_expr GT add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    LBRACE          shift and go to state 60
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    LPARENT         shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    initializer_list               shift and go to state 118
    initializer                    shift and go to state 119
    expr                           shift and go to state 61
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 61

    (66) initializer -> expr .
    SEMICOLON       reduce using rule 66 (initializer -> expr .)
    RBRACE          reduce using rule 66 (initializer -> expr .)
    COMMA           reduce using rule 66 (initializer -> expr .)


state 62

    (42) expr -> unary_expr . assignment_op expr
    (21) cast_expr -> unary_expr .
    (44) assignment_op -> . ASSIGN
    (45) assignment_op -> . MODEQ
    (46) assignment_op -> . DIVEQ
    (47) assignment_op -> . MULEQ
    (48) assignment_op -> . MINUSEQ
    (49) assignment_op -> . PLUSEQ
    MOD             reduce using rule 21 (cast_expr -> unary_expr .)
    DIV             reduce using rule 21 (cast_expr -> unary_expr .)
    MUL             reduce using rule 21 (cast_expr -> unary_expr .)
    MINUS           reduce using rule 21 (cast_expr -> unary_expr .)
    PLUS            reduce using rule 21 (cast_expr -> unary_expr .)
    LE              reduce using rule 21 (cast_expr -> unary_expr .)
    GE              reduce using rule 21 (cast_expr -> unary_expr .)
    LT              reduce using rule 21 (cast_expr -> unary_expr .)
    GT              reduce using rule 21 (cast_expr -> unary_expr .)
    NE              reduce using rule 21 (cast_expr -> unary_expr .)
    EQ              reduce using rule 21 (cast_expr -> unary_expr .)
    AND             reduce using rule 21 (cast_expr -> unary_expr .)
    OR              reduce using rule 21 (cast_expr -> unary_expr .)
    SEMICOLON       reduce using rule 21 (cast_expr -> unary_expr .)
    RPARENT         reduce using rule 21 (cast_expr -> unary_expr .)
    RBRACE          reduce using rule 21 (cast_expr -> unary_expr .)
    COMMA           reduce using rule 21 (cast_expr -> unary_expr .)
    RBRACKET        reduce using rule 21 (cast_expr -> unary_expr .)
    ASSIGN          shift and go to state 121
    MODEQ           shift and go to state 122
    DIVEQ           shift and go to state 123
    MULEQ           shift and go to state 124
    MINUSEQ         shift and go to state 125
    PLUSEQ          shift and go to state 126

    assignment_op                  shift and go to state 120

state 63

    (43) expr -> cond_expr .
    (40) cond_expr -> cond_expr . OR and_expr
    SEMICOLON       reduce using rule 43 (expr -> cond_expr .)
    RPARENT         reduce using rule 43 (expr -> cond_expr .)
    RBRACE          reduce using rule 43 (expr -> cond_expr .)
    COMMA           reduce using rule 43 (expr -> cond_expr .)
    RBRACKET        reduce using rule 43 (expr -> cond_expr .)
    OR              shift and go to state 89


state 64

    (3) primary_expr -> LPARENT . expr RPARENT
    (22) cast_expr -> LPARENT . type RPARENT cast_expr
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr LT add_expr
    (33) rel_expr -> . rel_expr GT add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    LPARENT         shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    expr                           shift and go to state 105
    type                           shift and go to state 104
    cast_expr                      shift and go to state 45
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 65

    (76) block_stmt -> LBRACE stmt_list . RBRACE
    (80) stmt_list -> stmt_list . stmt
    (69) stmt -> . jump_stmt
    (70) stmt -> . loop_stmt
    (71) stmt -> . if_stmt
    (72) stmt -> . expr_stmt
    (73) stmt -> . block_stmt
    (74) stmt -> . labeled_stmt
    (90) jump_stmt -> . RETURN expr SEMICOLON
    (91) jump_stmt -> . RETURN SEMICOLON
    (92) jump_stmt -> . BREAK SEMICOLON
    (93) jump_stmt -> . CONTINUE SEMICOLON
    (94) jump_stmt -> . GOTO IDENTIFIER SEMICOLON
    (87) loop_stmt -> . FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt
    (88) loop_stmt -> . DO stmt WHILE LPARENT expr RPARENT SEMICOLON
    (89) loop_stmt -> . WHILE LPARENT expr RPARENT stmt
    (85) if_stmt -> . IF LPARENT expr RPARENT stmt ELSE stmt
    (86) if_stmt -> . IF LPARENT expr RPARENT stmt
    (82) expr_stmt -> . decl
    (83) expr_stmt -> . expr SEMICOLON
    (84) expr_stmt -> . SEMICOLON
    (76) block_stmt -> . LBRACE stmt_list RBRACE
    (77) block_stmt -> . LBRACE RBRACE
    (75) labeled_stmt -> . IDENTIFIER COLON stmt
    (50) decl -> . type init_declarator SEMICOLON
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr LT add_expr
    (33) rel_expr -> . rel_expr GT add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    RBRACE          shift and go to state 127
    RETURN          shift and go to state 74
    BREAK           shift and go to state 77
    CONTINUE        shift and go to state 78
    GOTO            shift and go to state 79
    FOR             shift and go to state 81
    DO              shift and go to state 82
    WHILE           shift and go to state 83
    IF              shift and go to state 84
    SEMICOLON       shift and go to state 76
    LBRACE          shift and go to state 33
    IDENTIFIER      shift and go to state 80
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    LPARENT         shift and go to state 64
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    stmt                           shift and go to state 128
    jump_stmt                      shift and go to state 68
    loop_stmt                      shift and go to state 69
    if_stmt                        shift and go to state 70
    expr_stmt                      shift and go to state 71
    block_stmt                     shift and go to state 72
    labeled_stmt                   shift and go to state 73
    expr                           shift and go to state 75
    decl                           shift and go to state 85
    type                           shift and go to state 86
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 66

    (77) block_stmt -> LBRACE RBRACE .
    IMPORT          reduce using rule 77 (block_stmt -> LBRACE RBRACE .)
    DEFINE          reduce using rule 77 (block_stmt -> LBRACE RBRACE .)
    INCLUDE         reduce using rule 77 (block_stmt -> LBRACE RBRACE .)
    VOID            reduce using rule 77 (block_stmt -> LBRACE RBRACE .)
    STRING_T        reduce using rule 77 (block_stmt -> LBRACE RBRACE .)
    DOUBLE          reduce using rule 77 (block_stmt -> LBRACE RBRACE .)
    INT             reduce using rule 77 (block_stmt -> LBRACE RBRACE .)
    $end            reduce using rule 77 (block_stmt -> LBRACE RBRACE .)
    RBRACE          reduce using rule 77 (block_stmt -> LBRACE RBRACE .)
    RETURN          reduce using rule 77 (block_stmt -> LBRACE RBRACE .)
    BREAK           reduce using rule 77 (block_stmt -> LBRACE RBRACE .)
    CONTINUE        reduce using rule 77 (block_stmt -> LBRACE RBRACE .)
    GOTO            reduce using rule 77 (block_stmt -> LBRACE RBRACE .)
    FOR             reduce using rule 77 (block_stmt -> LBRACE RBRACE .)
    DO              reduce using rule 77 (block_stmt -> LBRACE RBRACE .)
    WHILE           reduce using rule 77 (block_stmt -> LBRACE RBRACE .)
    IF              reduce using rule 77 (block_stmt -> LBRACE RBRACE .)
    SEMICOLON       reduce using rule 77 (block_stmt -> LBRACE RBRACE .)
    LBRACE          reduce using rule 77 (block_stmt -> LBRACE RBRACE .)
    IDENTIFIER      reduce using rule 77 (block_stmt -> LBRACE RBRACE .)
    NOT             reduce using rule 77 (block_stmt -> LBRACE RBRACE .)
    MINUS           reduce using rule 77 (block_stmt -> LBRACE RBRACE .)
    PLUS            reduce using rule 77 (block_stmt -> LBRACE RBRACE .)
    DEC             reduce using rule 77 (block_stmt -> LBRACE RBRACE .)
    INC             reduce using rule 77 (block_stmt -> LBRACE RBRACE .)
    LPARENT         reduce using rule 77 (block_stmt -> LBRACE RBRACE .)
    FLOAT           reduce using rule 77 (block_stmt -> LBRACE RBRACE .)
    INTEGER         reduce using rule 77 (block_stmt -> LBRACE RBRACE .)
    ELSE            reduce using rule 77 (block_stmt -> LBRACE RBRACE .)


state 67

    (81) stmt_list -> stmt .
    RBRACE          reduce using rule 81 (stmt_list -> stmt .)
    RETURN          reduce using rule 81 (stmt_list -> stmt .)
    BREAK           reduce using rule 81 (stmt_list -> stmt .)
    CONTINUE        reduce using rule 81 (stmt_list -> stmt .)
    GOTO            reduce using rule 81 (stmt_list -> stmt .)
    FOR             reduce using rule 81 (stmt_list -> stmt .)
    DO              reduce using rule 81 (stmt_list -> stmt .)
    WHILE           reduce using rule 81 (stmt_list -> stmt .)
    IF              reduce using rule 81 (stmt_list -> stmt .)
    SEMICOLON       reduce using rule 81 (stmt_list -> stmt .)
    LBRACE          reduce using rule 81 (stmt_list -> stmt .)
    IDENTIFIER      reduce using rule 81 (stmt_list -> stmt .)
    VOID            reduce using rule 81 (stmt_list -> stmt .)
    STRING_T        reduce using rule 81 (stmt_list -> stmt .)
    DOUBLE          reduce using rule 81 (stmt_list -> stmt .)
    INT             reduce using rule 81 (stmt_list -> stmt .)
    NOT             reduce using rule 81 (stmt_list -> stmt .)
    MINUS           reduce using rule 81 (stmt_list -> stmt .)
    PLUS            reduce using rule 81 (stmt_list -> stmt .)
    DEC             reduce using rule 81 (stmt_list -> stmt .)
    INC             reduce using rule 81 (stmt_list -> stmt .)
    LPARENT         reduce using rule 81 (stmt_list -> stmt .)
    FLOAT           reduce using rule 81 (stmt_list -> stmt .)
    INTEGER         reduce using rule 81 (stmt_list -> stmt .)


state 68

    (69) stmt -> jump_stmt .
    RBRACE          reduce using rule 69 (stmt -> jump_stmt .)
    RETURN          reduce using rule 69 (stmt -> jump_stmt .)
    BREAK           reduce using rule 69 (stmt -> jump_stmt .)
    CONTINUE        reduce using rule 69 (stmt -> jump_stmt .)
    GOTO            reduce using rule 69 (stmt -> jump_stmt .)
    FOR             reduce using rule 69 (stmt -> jump_stmt .)
    DO              reduce using rule 69 (stmt -> jump_stmt .)
    WHILE           reduce using rule 69 (stmt -> jump_stmt .)
    IF              reduce using rule 69 (stmt -> jump_stmt .)
    SEMICOLON       reduce using rule 69 (stmt -> jump_stmt .)
    LBRACE          reduce using rule 69 (stmt -> jump_stmt .)
    IDENTIFIER      reduce using rule 69 (stmt -> jump_stmt .)
    VOID            reduce using rule 69 (stmt -> jump_stmt .)
    STRING_T        reduce using rule 69 (stmt -> jump_stmt .)
    DOUBLE          reduce using rule 69 (stmt -> jump_stmt .)
    INT             reduce using rule 69 (stmt -> jump_stmt .)
    NOT             reduce using rule 69 (stmt -> jump_stmt .)
    MINUS           reduce using rule 69 (stmt -> jump_stmt .)
    PLUS            reduce using rule 69 (stmt -> jump_stmt .)
    DEC             reduce using rule 69 (stmt -> jump_stmt .)
    INC             reduce using rule 69 (stmt -> jump_stmt .)
    LPARENT         reduce using rule 69 (stmt -> jump_stmt .)
    FLOAT           reduce using rule 69 (stmt -> jump_stmt .)
    INTEGER         reduce using rule 69 (stmt -> jump_stmt .)
    ELSE            reduce using rule 69 (stmt -> jump_stmt .)


state 69

    (70) stmt -> loop_stmt .
    RBRACE          reduce using rule 70 (stmt -> loop_stmt .)
    RETURN          reduce using rule 70 (stmt -> loop_stmt .)
    BREAK           reduce using rule 70 (stmt -> loop_stmt .)
    CONTINUE        reduce using rule 70 (stmt -> loop_stmt .)
    GOTO            reduce using rule 70 (stmt -> loop_stmt .)
    FOR             reduce using rule 70 (stmt -> loop_stmt .)
    DO              reduce using rule 70 (stmt -> loop_stmt .)
    WHILE           reduce using rule 70 (stmt -> loop_stmt .)
    IF              reduce using rule 70 (stmt -> loop_stmt .)
    SEMICOLON       reduce using rule 70 (stmt -> loop_stmt .)
    LBRACE          reduce using rule 70 (stmt -> loop_stmt .)
    IDENTIFIER      reduce using rule 70 (stmt -> loop_stmt .)
    VOID            reduce using rule 70 (stmt -> loop_stmt .)
    STRING_T        reduce using rule 70 (stmt -> loop_stmt .)
    DOUBLE          reduce using rule 70 (stmt -> loop_stmt .)
    INT             reduce using rule 70 (stmt -> loop_stmt .)
    NOT             reduce using rule 70 (stmt -> loop_stmt .)
    MINUS           reduce using rule 70 (stmt -> loop_stmt .)
    PLUS            reduce using rule 70 (stmt -> loop_stmt .)
    DEC             reduce using rule 70 (stmt -> loop_stmt .)
    INC             reduce using rule 70 (stmt -> loop_stmt .)
    LPARENT         reduce using rule 70 (stmt -> loop_stmt .)
    FLOAT           reduce using rule 70 (stmt -> loop_stmt .)
    INTEGER         reduce using rule 70 (stmt -> loop_stmt .)
    ELSE            reduce using rule 70 (stmt -> loop_stmt .)


state 70

    (71) stmt -> if_stmt .
    RBRACE          reduce using rule 71 (stmt -> if_stmt .)
    RETURN          reduce using rule 71 (stmt -> if_stmt .)
    BREAK           reduce using rule 71 (stmt -> if_stmt .)
    CONTINUE        reduce using rule 71 (stmt -> if_stmt .)
    GOTO            reduce using rule 71 (stmt -> if_stmt .)
    FOR             reduce using rule 71 (stmt -> if_stmt .)
    DO              reduce using rule 71 (stmt -> if_stmt .)
    WHILE           reduce using rule 71 (stmt -> if_stmt .)
    IF              reduce using rule 71 (stmt -> if_stmt .)
    SEMICOLON       reduce using rule 71 (stmt -> if_stmt .)
    LBRACE          reduce using rule 71 (stmt -> if_stmt .)
    IDENTIFIER      reduce using rule 71 (stmt -> if_stmt .)
    VOID            reduce using rule 71 (stmt -> if_stmt .)
    STRING_T        reduce using rule 71 (stmt -> if_stmt .)
    DOUBLE          reduce using rule 71 (stmt -> if_stmt .)
    INT             reduce using rule 71 (stmt -> if_stmt .)
    NOT             reduce using rule 71 (stmt -> if_stmt .)
    MINUS           reduce using rule 71 (stmt -> if_stmt .)
    PLUS            reduce using rule 71 (stmt -> if_stmt .)
    DEC             reduce using rule 71 (stmt -> if_stmt .)
    INC             reduce using rule 71 (stmt -> if_stmt .)
    LPARENT         reduce using rule 71 (stmt -> if_stmt .)
    FLOAT           reduce using rule 71 (stmt -> if_stmt .)
    INTEGER         reduce using rule 71 (stmt -> if_stmt .)
    ELSE            reduce using rule 71 (stmt -> if_stmt .)


state 71

    (72) stmt -> expr_stmt .
    RBRACE          reduce using rule 72 (stmt -> expr_stmt .)
    RETURN          reduce using rule 72 (stmt -> expr_stmt .)
    BREAK           reduce using rule 72 (stmt -> expr_stmt .)
    CONTINUE        reduce using rule 72 (stmt -> expr_stmt .)
    GOTO            reduce using rule 72 (stmt -> expr_stmt .)
    FOR             reduce using rule 72 (stmt -> expr_stmt .)
    DO              reduce using rule 72 (stmt -> expr_stmt .)
    WHILE           reduce using rule 72 (stmt -> expr_stmt .)
    IF              reduce using rule 72 (stmt -> expr_stmt .)
    SEMICOLON       reduce using rule 72 (stmt -> expr_stmt .)
    LBRACE          reduce using rule 72 (stmt -> expr_stmt .)
    IDENTIFIER      reduce using rule 72 (stmt -> expr_stmt .)
    VOID            reduce using rule 72 (stmt -> expr_stmt .)
    STRING_T        reduce using rule 72 (stmt -> expr_stmt .)
    DOUBLE          reduce using rule 72 (stmt -> expr_stmt .)
    INT             reduce using rule 72 (stmt -> expr_stmt .)
    NOT             reduce using rule 72 (stmt -> expr_stmt .)
    MINUS           reduce using rule 72 (stmt -> expr_stmt .)
    PLUS            reduce using rule 72 (stmt -> expr_stmt .)
    DEC             reduce using rule 72 (stmt -> expr_stmt .)
    INC             reduce using rule 72 (stmt -> expr_stmt .)
    LPARENT         reduce using rule 72 (stmt -> expr_stmt .)
    FLOAT           reduce using rule 72 (stmt -> expr_stmt .)
    INTEGER         reduce using rule 72 (stmt -> expr_stmt .)
    ELSE            reduce using rule 72 (stmt -> expr_stmt .)


state 72

    (73) stmt -> block_stmt .
    RBRACE          reduce using rule 73 (stmt -> block_stmt .)
    RETURN          reduce using rule 73 (stmt -> block_stmt .)
    BREAK           reduce using rule 73 (stmt -> block_stmt .)
    CONTINUE        reduce using rule 73 (stmt -> block_stmt .)
    GOTO            reduce using rule 73 (stmt -> block_stmt .)
    FOR             reduce using rule 73 (stmt -> block_stmt .)
    DO              reduce using rule 73 (stmt -> block_stmt .)
    WHILE           reduce using rule 73 (stmt -> block_stmt .)
    IF              reduce using rule 73 (stmt -> block_stmt .)
    SEMICOLON       reduce using rule 73 (stmt -> block_stmt .)
    LBRACE          reduce using rule 73 (stmt -> block_stmt .)
    IDENTIFIER      reduce using rule 73 (stmt -> block_stmt .)
    VOID            reduce using rule 73 (stmt -> block_stmt .)
    STRING_T        reduce using rule 73 (stmt -> block_stmt .)
    DOUBLE          reduce using rule 73 (stmt -> block_stmt .)
    INT             reduce using rule 73 (stmt -> block_stmt .)
    NOT             reduce using rule 73 (stmt -> block_stmt .)
    MINUS           reduce using rule 73 (stmt -> block_stmt .)
    PLUS            reduce using rule 73 (stmt -> block_stmt .)
    DEC             reduce using rule 73 (stmt -> block_stmt .)
    INC             reduce using rule 73 (stmt -> block_stmt .)
    LPARENT         reduce using rule 73 (stmt -> block_stmt .)
    FLOAT           reduce using rule 73 (stmt -> block_stmt .)
    INTEGER         reduce using rule 73 (stmt -> block_stmt .)
    ELSE            reduce using rule 73 (stmt -> block_stmt .)


state 73

    (74) stmt -> labeled_stmt .
    RBRACE          reduce using rule 74 (stmt -> labeled_stmt .)
    RETURN          reduce using rule 74 (stmt -> labeled_stmt .)
    BREAK           reduce using rule 74 (stmt -> labeled_stmt .)
    CONTINUE        reduce using rule 74 (stmt -> labeled_stmt .)
    GOTO            reduce using rule 74 (stmt -> labeled_stmt .)
    FOR             reduce using rule 74 (stmt -> labeled_stmt .)
    DO              reduce using rule 74 (stmt -> labeled_stmt .)
    WHILE           reduce using rule 74 (stmt -> labeled_stmt .)
    IF              reduce using rule 74 (stmt -> labeled_stmt .)
    SEMICOLON       reduce using rule 74 (stmt -> labeled_stmt .)
    LBRACE          reduce using rule 74 (stmt -> labeled_stmt .)
    IDENTIFIER      reduce using rule 74 (stmt -> labeled_stmt .)
    VOID            reduce using rule 74 (stmt -> labeled_stmt .)
    STRING_T        reduce using rule 74 (stmt -> labeled_stmt .)
    DOUBLE          reduce using rule 74 (stmt -> labeled_stmt .)
    INT             reduce using rule 74 (stmt -> labeled_stmt .)
    NOT             reduce using rule 74 (stmt -> labeled_stmt .)
    MINUS           reduce using rule 74 (stmt -> labeled_stmt .)
    PLUS            reduce using rule 74 (stmt -> labeled_stmt .)
    DEC             reduce using rule 74 (stmt -> labeled_stmt .)
    INC             reduce using rule 74 (stmt -> labeled_stmt .)
    LPARENT         reduce using rule 74 (stmt -> labeled_stmt .)
    FLOAT           reduce using rule 74 (stmt -> labeled_stmt .)
    INTEGER         reduce using rule 74 (stmt -> labeled_stmt .)
    ELSE            reduce using rule 74 (stmt -> labeled_stmt .)


state 74

    (90) jump_stmt -> RETURN . expr SEMICOLON
    (91) jump_stmt -> RETURN . SEMICOLON
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr LT add_expr
    (33) rel_expr -> . rel_expr GT add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    SEMICOLON       shift and go to state 130
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    LPARENT         shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    expr                           shift and go to state 129
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 75

    (83) expr_stmt -> expr . SEMICOLON
    SEMICOLON       shift and go to state 131


state 76

    (84) expr_stmt -> SEMICOLON .
    RBRACE          reduce using rule 84 (expr_stmt -> SEMICOLON .)
    RETURN          reduce using rule 84 (expr_stmt -> SEMICOLON .)
    BREAK           reduce using rule 84 (expr_stmt -> SEMICOLON .)
    CONTINUE        reduce using rule 84 (expr_stmt -> SEMICOLON .)
    GOTO            reduce using rule 84 (expr_stmt -> SEMICOLON .)
    FOR             reduce using rule 84 (expr_stmt -> SEMICOLON .)
    DO              reduce using rule 84 (expr_stmt -> SEMICOLON .)
    WHILE           reduce using rule 84 (expr_stmt -> SEMICOLON .)
    IF              reduce using rule 84 (expr_stmt -> SEMICOLON .)
    SEMICOLON       reduce using rule 84 (expr_stmt -> SEMICOLON .)
    LBRACE          reduce using rule 84 (expr_stmt -> SEMICOLON .)
    IDENTIFIER      reduce using rule 84 (expr_stmt -> SEMICOLON .)
    VOID            reduce using rule 84 (expr_stmt -> SEMICOLON .)
    STRING_T        reduce using rule 84 (expr_stmt -> SEMICOLON .)
    DOUBLE          reduce using rule 84 (expr_stmt -> SEMICOLON .)
    INT             reduce using rule 84 (expr_stmt -> SEMICOLON .)
    NOT             reduce using rule 84 (expr_stmt -> SEMICOLON .)
    MINUS           reduce using rule 84 (expr_stmt -> SEMICOLON .)
    PLUS            reduce using rule 84 (expr_stmt -> SEMICOLON .)
    DEC             reduce using rule 84 (expr_stmt -> SEMICOLON .)
    INC             reduce using rule 84 (expr_stmt -> SEMICOLON .)
    LPARENT         reduce using rule 84 (expr_stmt -> SEMICOLON .)
    FLOAT           reduce using rule 84 (expr_stmt -> SEMICOLON .)
    INTEGER         reduce using rule 84 (expr_stmt -> SEMICOLON .)
    ELSE            reduce using rule 84 (expr_stmt -> SEMICOLON .)


state 77

    (92) jump_stmt -> BREAK . SEMICOLON
    SEMICOLON       shift and go to state 132


state 78

    (93) jump_stmt -> CONTINUE . SEMICOLON
    SEMICOLON       shift and go to state 133


state 79

    (94) jump_stmt -> GOTO . IDENTIFIER SEMICOLON
    IDENTIFIER      shift and go to state 134


state 80

    (75) labeled_stmt -> IDENTIFIER . COLON stmt
    (5) primary_expr -> IDENTIFIER .
    COLON           shift and go to state 135
    DEC             reduce using rule 5 (primary_expr -> IDENTIFIER .)
    INC             reduce using rule 5 (primary_expr -> IDENTIFIER .)
    DOT             reduce using rule 5 (primary_expr -> IDENTIFIER .)
    LPARENT         reduce using rule 5 (primary_expr -> IDENTIFIER .)
    LBRACKET        reduce using rule 5 (primary_expr -> IDENTIFIER .)
    ASSIGN          reduce using rule 5 (primary_expr -> IDENTIFIER .)
    MODEQ           reduce using rule 5 (primary_expr -> IDENTIFIER .)
    DIVEQ           reduce using rule 5 (primary_expr -> IDENTIFIER .)
    MULEQ           reduce using rule 5 (primary_expr -> IDENTIFIER .)
    MINUSEQ         reduce using rule 5 (primary_expr -> IDENTIFIER .)
    PLUSEQ          reduce using rule 5 (primary_expr -> IDENTIFIER .)
    MOD             reduce using rule 5 (primary_expr -> IDENTIFIER .)
    DIV             reduce using rule 5 (primary_expr -> IDENTIFIER .)
    MUL             reduce using rule 5 (primary_expr -> IDENTIFIER .)
    MINUS           reduce using rule 5 (primary_expr -> IDENTIFIER .)
    PLUS            reduce using rule 5 (primary_expr -> IDENTIFIER .)
    LE              reduce using rule 5 (primary_expr -> IDENTIFIER .)
    GE              reduce using rule 5 (primary_expr -> IDENTIFIER .)
    LT              reduce using rule 5 (primary_expr -> IDENTIFIER .)
    GT              reduce using rule 5 (primary_expr -> IDENTIFIER .)
    NE              reduce using rule 5 (primary_expr -> IDENTIFIER .)
    EQ              reduce using rule 5 (primary_expr -> IDENTIFIER .)
    AND             reduce using rule 5 (primary_expr -> IDENTIFIER .)
    OR              reduce using rule 5 (primary_expr -> IDENTIFIER .)
    SEMICOLON       reduce using rule 5 (primary_expr -> IDENTIFIER .)


state 81

    (87) loop_stmt -> FOR . LPARENT expr_stmt expr_stmt expr RPARENT stmt
    LPARENT         shift and go to state 136


state 82

    (88) loop_stmt -> DO . stmt WHILE LPARENT expr RPARENT SEMICOLON
    (69) stmt -> . jump_stmt
    (70) stmt -> . loop_stmt
    (71) stmt -> . if_stmt
    (72) stmt -> . expr_stmt
    (73) stmt -> . block_stmt
    (74) stmt -> . labeled_stmt
    (90) jump_stmt -> . RETURN expr SEMICOLON
    (91) jump_stmt -> . RETURN SEMICOLON
    (92) jump_stmt -> . BREAK SEMICOLON
    (93) jump_stmt -> . CONTINUE SEMICOLON
    (94) jump_stmt -> . GOTO IDENTIFIER SEMICOLON
    (87) loop_stmt -> . FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt
    (88) loop_stmt -> . DO stmt WHILE LPARENT expr RPARENT SEMICOLON
    (89) loop_stmt -> . WHILE LPARENT expr RPARENT stmt
    (85) if_stmt -> . IF LPARENT expr RPARENT stmt ELSE stmt
    (86) if_stmt -> . IF LPARENT expr RPARENT stmt
    (82) expr_stmt -> . decl
    (83) expr_stmt -> . expr SEMICOLON
    (84) expr_stmt -> . SEMICOLON
    (76) block_stmt -> . LBRACE stmt_list RBRACE
    (77) block_stmt -> . LBRACE RBRACE
    (75) labeled_stmt -> . IDENTIFIER COLON stmt
    (50) decl -> . type init_declarator SEMICOLON
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr LT add_expr
    (33) rel_expr -> . rel_expr GT add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    RETURN          shift and go to state 74
    BREAK           shift and go to state 77
    CONTINUE        shift and go to state 78
    GOTO            shift and go to state 79
    FOR             shift and go to state 81
    DO              shift and go to state 82
    WHILE           shift and go to state 83
    IF              shift and go to state 84
    SEMICOLON       shift and go to state 76
    LBRACE          shift and go to state 33
    IDENTIFIER      shift and go to state 80
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    LPARENT         shift and go to state 64
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    stmt                           shift and go to state 137
    expr                           shift and go to state 75
    jump_stmt                      shift and go to state 68
    loop_stmt                      shift and go to state 69
    if_stmt                        shift and go to state 70
    expr_stmt                      shift and go to state 71
    block_stmt                     shift and go to state 72
    labeled_stmt                   shift and go to state 73
    decl                           shift and go to state 85
    type                           shift and go to state 86
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 83

    (89) loop_stmt -> WHILE . LPARENT expr RPARENT stmt
    LPARENT         shift and go to state 138


state 84

    (85) if_stmt -> IF . LPARENT expr RPARENT stmt ELSE stmt
    (86) if_stmt -> IF . LPARENT expr RPARENT stmt
    LPARENT         shift and go to state 139


state 85

    (82) expr_stmt -> decl .
    RBRACE          reduce using rule 82 (expr_stmt -> decl .)
    RETURN          reduce using rule 82 (expr_stmt -> decl .)
    BREAK           reduce using rule 82 (expr_stmt -> decl .)
    CONTINUE        reduce using rule 82 (expr_stmt -> decl .)
    GOTO            reduce using rule 82 (expr_stmt -> decl .)
    FOR             reduce using rule 82 (expr_stmt -> decl .)
    DO              reduce using rule 82 (expr_stmt -> decl .)
    WHILE           reduce using rule 82 (expr_stmt -> decl .)
    IF              reduce using rule 82 (expr_stmt -> decl .)
    SEMICOLON       reduce using rule 82 (expr_stmt -> decl .)
    LBRACE          reduce using rule 82 (expr_stmt -> decl .)
    IDENTIFIER      reduce using rule 82 (expr_stmt -> decl .)
    VOID            reduce using rule 82 (expr_stmt -> decl .)
    STRING_T        reduce using rule 82 (expr_stmt -> decl .)
    DOUBLE          reduce using rule 82 (expr_stmt -> decl .)
    INT             reduce using rule 82 (expr_stmt -> decl .)
    NOT             reduce using rule 82 (expr_stmt -> decl .)
    MINUS           reduce using rule 82 (expr_stmt -> decl .)
    PLUS            reduce using rule 82 (expr_stmt -> decl .)
    DEC             reduce using rule 82 (expr_stmt -> decl .)
    INC             reduce using rule 82 (expr_stmt -> decl .)
    LPARENT         reduce using rule 82 (expr_stmt -> decl .)
    FLOAT           reduce using rule 82 (expr_stmt -> decl .)
    INTEGER         reduce using rule 82 (expr_stmt -> decl .)
    ELSE            reduce using rule 82 (expr_stmt -> decl .)


state 86

    (50) decl -> type . init_declarator SEMICOLON
    (51) init_declarator -> . declarator ASSIGN initializer
    (52) init_declarator -> . declarator
    (57) declarator -> . declarator LBRACKET RBRACKET
    (58) declarator -> . declarator LBRACKET cond_expr RBRACKET
    (59) declarator -> . declarator LPARENT RPARENT
    (60) declarator -> . declarator LPARENT param_list RPARENT
    (61) declarator -> . IDENTIFIER
    IDENTIFIER      shift and go to state 22

    init_declarator                shift and go to state 21
    declarator                     shift and go to state 140

state 87

    (107) import_decl -> IMPORT IDENTIFIER INTEGER INTEGER STRING . IDENTIFIER
    IDENTIFIER      shift and go to state 141


state 88

    (58) declarator -> declarator LBRACKET cond_expr RBRACKET .
    LBRACKET        reduce using rule 58 (declarator -> declarator LBRACKET cond_expr RBRACKET .)
    LPARENT         reduce using rule 58 (declarator -> declarator LBRACKET cond_expr RBRACKET .)
    ASSIGN          reduce using rule 58 (declarator -> declarator LBRACKET cond_expr RBRACKET .)
    LBRACE          reduce using rule 58 (declarator -> declarator LBRACKET cond_expr RBRACKET .)
    SEMICOLON       reduce using rule 58 (declarator -> declarator LBRACKET cond_expr RBRACKET .)
    RPARENT         reduce using rule 58 (declarator -> declarator LBRACKET cond_expr RBRACKET .)
    COMMA           reduce using rule 58 (declarator -> declarator LBRACKET cond_expr RBRACKET .)


state 89

    (40) cond_expr -> cond_expr OR . and_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr LT add_expr
    (33) rel_expr -> . rel_expr GT add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    LPARENT         shift and go to state 47
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    and_expr                       shift and go to state 142
    eq_expr                        shift and go to state 39
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43
    cast_expr                      shift and go to state 45
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 90

    (38) and_expr -> and_expr AND . eq_expr
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr LT add_expr
    (33) rel_expr -> . rel_expr GT add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    LPARENT         shift and go to state 47
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    eq_expr                        shift and go to state 143
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43
    cast_expr                      shift and go to state 45
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 91

    (35) eq_expr -> eq_expr NE . rel_expr
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr LT add_expr
    (33) rel_expr -> . rel_expr GT add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    LPARENT         shift and go to state 47
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    rel_expr                       shift and go to state 144
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43
    cast_expr                      shift and go to state 45
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 92

    (36) eq_expr -> eq_expr EQ . rel_expr
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr LT add_expr
    (33) rel_expr -> . rel_expr GT add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    LPARENT         shift and go to state 47
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    rel_expr                       shift and go to state 145
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43
    cast_expr                      shift and go to state 45
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 93

    (30) rel_expr -> rel_expr LE . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    LPARENT         shift and go to state 47
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    add_expr                       shift and go to state 146
    mult_expr                      shift and go to state 43
    cast_expr                      shift and go to state 45
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 94

    (31) rel_expr -> rel_expr GE . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    LPARENT         shift and go to state 47
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    add_expr                       shift and go to state 147
    mult_expr                      shift and go to state 43
    cast_expr                      shift and go to state 45
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 95

    (32) rel_expr -> rel_expr LT . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    LPARENT         shift and go to state 47
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    add_expr                       shift and go to state 148
    mult_expr                      shift and go to state 43
    cast_expr                      shift and go to state 45
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 96

    (33) rel_expr -> rel_expr GT . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    LPARENT         shift and go to state 47
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    add_expr                       shift and go to state 149
    mult_expr                      shift and go to state 43
    cast_expr                      shift and go to state 45
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 97

    (27) add_expr -> add_expr MINUS . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    LPARENT         shift and go to state 47
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    mult_expr                      shift and go to state 150
    cast_expr                      shift and go to state 45
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 98

    (28) add_expr -> add_expr PLUS . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    LPARENT         shift and go to state 47
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    mult_expr                      shift and go to state 151
    cast_expr                      shift and go to state 45
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 99

    (16) unary_expr -> MINUS cast_expr .
    MOD             reduce using rule 16 (unary_expr -> MINUS cast_expr .)
    DIV             reduce using rule 16 (unary_expr -> MINUS cast_expr .)
    MUL             reduce using rule 16 (unary_expr -> MINUS cast_expr .)
    MINUS           reduce using rule 16 (unary_expr -> MINUS cast_expr .)
    PLUS            reduce using rule 16 (unary_expr -> MINUS cast_expr .)
    LE              reduce using rule 16 (unary_expr -> MINUS cast_expr .)
    GE              reduce using rule 16 (unary_expr -> MINUS cast_expr .)
    LT              reduce using rule 16 (unary_expr -> MINUS cast_expr .)
    GT              reduce using rule 16 (unary_expr -> MINUS cast_expr .)
    NE              reduce using rule 16 (unary_expr -> MINUS cast_expr .)
    EQ              reduce using rule 16 (unary_expr -> MINUS cast_expr .)
    AND             reduce using rule 16 (unary_expr -> MINUS cast_expr .)
    RBRACKET        reduce using rule 16 (unary_expr -> MINUS cast_expr .)
    OR              reduce using rule 16 (unary_expr -> MINUS cast_expr .)
    ASSIGN          reduce using rule 16 (unary_expr -> MINUS cast_expr .)
    MODEQ           reduce using rule 16 (unary_expr -> MINUS cast_expr .)
    DIVEQ           reduce using rule 16 (unary_expr -> MINUS cast_expr .)
    MULEQ           reduce using rule 16 (unary_expr -> MINUS cast_expr .)
    MINUSEQ         reduce using rule 16 (unary_expr -> MINUS cast_expr .)
    PLUSEQ          reduce using rule 16 (unary_expr -> MINUS cast_expr .)
    SEMICOLON       reduce using rule 16 (unary_expr -> MINUS cast_expr .)
    RPARENT         reduce using rule 16 (unary_expr -> MINUS cast_expr .)
    RBRACE          reduce using rule 16 (unary_expr -> MINUS cast_expr .)
    COMMA           reduce using rule 16 (unary_expr -> MINUS cast_expr .)


state 100

    (23) mult_expr -> mult_expr MOD . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    LPARENT         shift and go to state 47
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    cast_expr                      shift and go to state 152
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 101

    (24) mult_expr -> mult_expr DIV . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    LPARENT         shift and go to state 47
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    cast_expr                      shift and go to state 153
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 102

    (25) mult_expr -> mult_expr MUL . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    LPARENT         shift and go to state 47
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    cast_expr                      shift and go to state 154
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 103

    (17) unary_expr -> PLUS cast_expr .
    MOD             reduce using rule 17 (unary_expr -> PLUS cast_expr .)
    DIV             reduce using rule 17 (unary_expr -> PLUS cast_expr .)
    MUL             reduce using rule 17 (unary_expr -> PLUS cast_expr .)
    MINUS           reduce using rule 17 (unary_expr -> PLUS cast_expr .)
    PLUS            reduce using rule 17 (unary_expr -> PLUS cast_expr .)
    LE              reduce using rule 17 (unary_expr -> PLUS cast_expr .)
    GE              reduce using rule 17 (unary_expr -> PLUS cast_expr .)
    LT              reduce using rule 17 (unary_expr -> PLUS cast_expr .)
    GT              reduce using rule 17 (unary_expr -> PLUS cast_expr .)
    NE              reduce using rule 17 (unary_expr -> PLUS cast_expr .)
    EQ              reduce using rule 17 (unary_expr -> PLUS cast_expr .)
    AND             reduce using rule 17 (unary_expr -> PLUS cast_expr .)
    RBRACKET        reduce using rule 17 (unary_expr -> PLUS cast_expr .)
    OR              reduce using rule 17 (unary_expr -> PLUS cast_expr .)
    ASSIGN          reduce using rule 17 (unary_expr -> PLUS cast_expr .)
    MODEQ           reduce using rule 17 (unary_expr -> PLUS cast_expr .)
    DIVEQ           reduce using rule 17 (unary_expr -> PLUS cast_expr .)
    MULEQ           reduce using rule 17 (unary_expr -> PLUS cast_expr .)
    MINUSEQ         reduce using rule 17 (unary_expr -> PLUS cast_expr .)
    PLUSEQ          reduce using rule 17 (unary_expr -> PLUS cast_expr .)
    SEMICOLON       reduce using rule 17 (unary_expr -> PLUS cast_expr .)
    RPARENT         reduce using rule 17 (unary_expr -> PLUS cast_expr .)
    RBRACE          reduce using rule 17 (unary_expr -> PLUS cast_expr .)
    COMMA           reduce using rule 17 (unary_expr -> PLUS cast_expr .)


state 104

    (22) cast_expr -> LPARENT type . RPARENT cast_expr
    RPARENT         shift and go to state 155


state 105

    (3) primary_expr -> LPARENT expr . RPARENT
    RPARENT         shift and go to state 156


state 106

    (15) unary_expr -> NOT cast_expr .
    MOD             reduce using rule 15 (unary_expr -> NOT cast_expr .)
    DIV             reduce using rule 15 (unary_expr -> NOT cast_expr .)
    MUL             reduce using rule 15 (unary_expr -> NOT cast_expr .)
    MINUS           reduce using rule 15 (unary_expr -> NOT cast_expr .)
    PLUS            reduce using rule 15 (unary_expr -> NOT cast_expr .)
    LE              reduce using rule 15 (unary_expr -> NOT cast_expr .)
    GE              reduce using rule 15 (unary_expr -> NOT cast_expr .)
    LT              reduce using rule 15 (unary_expr -> NOT cast_expr .)
    GT              reduce using rule 15 (unary_expr -> NOT cast_expr .)
    NE              reduce using rule 15 (unary_expr -> NOT cast_expr .)
    EQ              reduce using rule 15 (unary_expr -> NOT cast_expr .)
    AND             reduce using rule 15 (unary_expr -> NOT cast_expr .)
    RBRACKET        reduce using rule 15 (unary_expr -> NOT cast_expr .)
    OR              reduce using rule 15 (unary_expr -> NOT cast_expr .)
    ASSIGN          reduce using rule 15 (unary_expr -> NOT cast_expr .)
    MODEQ           reduce using rule 15 (unary_expr -> NOT cast_expr .)
    DIVEQ           reduce using rule 15 (unary_expr -> NOT cast_expr .)
    MULEQ           reduce using rule 15 (unary_expr -> NOT cast_expr .)
    MINUSEQ         reduce using rule 15 (unary_expr -> NOT cast_expr .)
    PLUSEQ          reduce using rule 15 (unary_expr -> NOT cast_expr .)
    SEMICOLON       reduce using rule 15 (unary_expr -> NOT cast_expr .)
    RPARENT         reduce using rule 15 (unary_expr -> NOT cast_expr .)
    RBRACE          reduce using rule 15 (unary_expr -> NOT cast_expr .)
    COMMA           reduce using rule 15 (unary_expr -> NOT cast_expr .)


state 107

    (18) unary_expr -> DEC unary_expr .
    MOD             reduce using rule 18 (unary_expr -> DEC unary_expr .)
    DIV             reduce using rule 18 (unary_expr -> DEC unary_expr .)
    MUL             reduce using rule 18 (unary_expr -> DEC unary_expr .)
    MINUS           reduce using rule 18 (unary_expr -> DEC unary_expr .)
    PLUS            reduce using rule 18 (unary_expr -> DEC unary_expr .)
    LE              reduce using rule 18 (unary_expr -> DEC unary_expr .)
    GE              reduce using rule 18 (unary_expr -> DEC unary_expr .)
    LT              reduce using rule 18 (unary_expr -> DEC unary_expr .)
    GT              reduce using rule 18 (unary_expr -> DEC unary_expr .)
    NE              reduce using rule 18 (unary_expr -> DEC unary_expr .)
    EQ              reduce using rule 18 (unary_expr -> DEC unary_expr .)
    AND             reduce using rule 18 (unary_expr -> DEC unary_expr .)
    RBRACKET        reduce using rule 18 (unary_expr -> DEC unary_expr .)
    OR              reduce using rule 18 (unary_expr -> DEC unary_expr .)
    ASSIGN          reduce using rule 18 (unary_expr -> DEC unary_expr .)
    MODEQ           reduce using rule 18 (unary_expr -> DEC unary_expr .)
    DIVEQ           reduce using rule 18 (unary_expr -> DEC unary_expr .)
    MULEQ           reduce using rule 18 (unary_expr -> DEC unary_expr .)
    MINUSEQ         reduce using rule 18 (unary_expr -> DEC unary_expr .)
    PLUSEQ          reduce using rule 18 (unary_expr -> DEC unary_expr .)
    SEMICOLON       reduce using rule 18 (unary_expr -> DEC unary_expr .)
    RPARENT         reduce using rule 18 (unary_expr -> DEC unary_expr .)
    RBRACE          reduce using rule 18 (unary_expr -> DEC unary_expr .)
    COMMA           reduce using rule 18 (unary_expr -> DEC unary_expr .)


state 108

    (3) primary_expr -> LPARENT . expr RPARENT
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr LT add_expr
    (33) rel_expr -> . rel_expr GT add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    LPARENT         shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    expr                           shift and go to state 105
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 109

    (19) unary_expr -> INC unary_expr .
    MOD             reduce using rule 19 (unary_expr -> INC unary_expr .)
    DIV             reduce using rule 19 (unary_expr -> INC unary_expr .)
    MUL             reduce using rule 19 (unary_expr -> INC unary_expr .)
    MINUS           reduce using rule 19 (unary_expr -> INC unary_expr .)
    PLUS            reduce using rule 19 (unary_expr -> INC unary_expr .)
    LE              reduce using rule 19 (unary_expr -> INC unary_expr .)
    GE              reduce using rule 19 (unary_expr -> INC unary_expr .)
    LT              reduce using rule 19 (unary_expr -> INC unary_expr .)
    GT              reduce using rule 19 (unary_expr -> INC unary_expr .)
    NE              reduce using rule 19 (unary_expr -> INC unary_expr .)
    EQ              reduce using rule 19 (unary_expr -> INC unary_expr .)
    AND             reduce using rule 19 (unary_expr -> INC unary_expr .)
    RBRACKET        reduce using rule 19 (unary_expr -> INC unary_expr .)
    OR              reduce using rule 19 (unary_expr -> INC unary_expr .)
    ASSIGN          reduce using rule 19 (unary_expr -> INC unary_expr .)
    MODEQ           reduce using rule 19 (unary_expr -> INC unary_expr .)
    DIVEQ           reduce using rule 19 (unary_expr -> INC unary_expr .)
    MULEQ           reduce using rule 19 (unary_expr -> INC unary_expr .)
    MINUSEQ         reduce using rule 19 (unary_expr -> INC unary_expr .)
    PLUSEQ          reduce using rule 19 (unary_expr -> INC unary_expr .)
    SEMICOLON       reduce using rule 19 (unary_expr -> INC unary_expr .)
    RPARENT         reduce using rule 19 (unary_expr -> INC unary_expr .)
    RBRACE          reduce using rule 19 (unary_expr -> INC unary_expr .)
    COMMA           reduce using rule 19 (unary_expr -> INC unary_expr .)


state 110

    (6) postfix_expr -> postfix_expr DEC .
    DEC             reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    INC             reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    DOT             reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    LPARENT         reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    LBRACKET        reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    MOD             reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    DIV             reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    MUL             reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    MINUS           reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    PLUS            reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    LE              reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    GE              reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    LT              reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    GT              reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    NE              reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    EQ              reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    AND             reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    RBRACKET        reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    OR              reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    ASSIGN          reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    MODEQ           reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    DIVEQ           reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    MULEQ           reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    MINUSEQ         reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    PLUSEQ          reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    SEMICOLON       reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    RPARENT         reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    RBRACE          reduce using rule 6 (postfix_expr -> postfix_expr DEC .)
    COMMA           reduce using rule 6 (postfix_expr -> postfix_expr DEC .)


state 111

    (7) postfix_expr -> postfix_expr INC .
    DEC             reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    INC             reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    DOT             reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    LPARENT         reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    LBRACKET        reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    MOD             reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    DIV             reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    MUL             reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    MINUS           reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    PLUS            reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    LE              reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    GE              reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    LT              reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    GT              reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    NE              reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    EQ              reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    AND             reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    RBRACKET        reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    OR              reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    ASSIGN          reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    MODEQ           reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    DIVEQ           reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    MULEQ           reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    MINUSEQ         reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    PLUSEQ          reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    SEMICOLON       reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    RPARENT         reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    RBRACE          reduce using rule 7 (postfix_expr -> postfix_expr INC .)
    COMMA           reduce using rule 7 (postfix_expr -> postfix_expr INC .)


state 112

    (8) postfix_expr -> postfix_expr DOT . IDENTIFIER
    IDENTIFIER      shift and go to state 157


state 113

    (9) postfix_expr -> postfix_expr LPARENT . arg_expr_list RPARENT
    (10) postfix_expr -> postfix_expr LPARENT . RPARENT
    (13) arg_expr_list -> . arg_expr_list COMMA expr
    (14) arg_expr_list -> . expr
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr LT add_expr
    (33) rel_expr -> . rel_expr GT add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    RPARENT         shift and go to state 159
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    LPARENT         shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    postfix_expr                   shift and go to state 51
    arg_expr_list                  shift and go to state 158
    expr                           shift and go to state 160
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 114

    (11) postfix_expr -> postfix_expr LBRACKET . expr RBRACKET
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr LT add_expr
    (33) rel_expr -> . rel_expr GT add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    LPARENT         shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    postfix_expr                   shift and go to state 51
    expr                           shift and go to state 161
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 115

    (60) declarator -> declarator LPARENT param_list RPARENT .
    LBRACKET        reduce using rule 60 (declarator -> declarator LPARENT param_list RPARENT .)
    LPARENT         reduce using rule 60 (declarator -> declarator LPARENT param_list RPARENT .)
    ASSIGN          reduce using rule 60 (declarator -> declarator LPARENT param_list RPARENT .)
    LBRACE          reduce using rule 60 (declarator -> declarator LPARENT param_list RPARENT .)
    SEMICOLON       reduce using rule 60 (declarator -> declarator LPARENT param_list RPARENT .)
    RPARENT         reduce using rule 60 (declarator -> declarator LPARENT param_list RPARENT .)
    COMMA           reduce using rule 60 (declarator -> declarator LPARENT param_list RPARENT .)


state 116

    (62) param_list -> param_list COMMA . param_decl
    (64) param_decl -> . type declarator
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15

    param_decl                     shift and go to state 162
    type                           shift and go to state 58

state 117

    (64) param_decl -> type declarator .
    (57) declarator -> declarator . LBRACKET RBRACKET
    (58) declarator -> declarator . LBRACKET cond_expr RBRACKET
    (59) declarator -> declarator . LPARENT RPARENT
    (60) declarator -> declarator . LPARENT param_list RPARENT
    RPARENT         reduce using rule 64 (param_decl -> type declarator .)
    COMMA           reduce using rule 64 (param_decl -> type declarator .)
    LBRACKET        shift and go to state 30
    LPARENT         shift and go to state 31


state 118

    (65) initializer -> LBRACE initializer_list . RBRACE
    (67) initializer_list -> initializer_list . COMMA initializer
    RBRACE          shift and go to state 163
    COMMA           shift and go to state 164


state 119

    (68) initializer_list -> initializer .
    RBRACE          reduce using rule 68 (initializer_list -> initializer .)
    COMMA           reduce using rule 68 (initializer_list -> initializer .)


state 120

    (42) expr -> unary_expr assignment_op . expr
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr LT add_expr
    (33) rel_expr -> . rel_expr GT add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    LPARENT         shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    unary_expr                     shift and go to state 62
    expr                           shift and go to state 165
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 121

    (44) assignment_op -> ASSIGN .
    NOT             reduce using rule 44 (assignment_op -> ASSIGN .)
    MINUS           reduce using rule 44 (assignment_op -> ASSIGN .)
    PLUS            reduce using rule 44 (assignment_op -> ASSIGN .)
    DEC             reduce using rule 44 (assignment_op -> ASSIGN .)
    INC             reduce using rule 44 (assignment_op -> ASSIGN .)
    LPARENT         reduce using rule 44 (assignment_op -> ASSIGN .)
    IDENTIFIER      reduce using rule 44 (assignment_op -> ASSIGN .)
    FLOAT           reduce using rule 44 (assignment_op -> ASSIGN .)
    INTEGER         reduce using rule 44 (assignment_op -> ASSIGN .)


state 122

    (45) assignment_op -> MODEQ .
    NOT             reduce using rule 45 (assignment_op -> MODEQ .)
    MINUS           reduce using rule 45 (assignment_op -> MODEQ .)
    PLUS            reduce using rule 45 (assignment_op -> MODEQ .)
    DEC             reduce using rule 45 (assignment_op -> MODEQ .)
    INC             reduce using rule 45 (assignment_op -> MODEQ .)
    LPARENT         reduce using rule 45 (assignment_op -> MODEQ .)
    IDENTIFIER      reduce using rule 45 (assignment_op -> MODEQ .)
    FLOAT           reduce using rule 45 (assignment_op -> MODEQ .)
    INTEGER         reduce using rule 45 (assignment_op -> MODEQ .)


state 123

    (46) assignment_op -> DIVEQ .
    NOT             reduce using rule 46 (assignment_op -> DIVEQ .)
    MINUS           reduce using rule 46 (assignment_op -> DIVEQ .)
    PLUS            reduce using rule 46 (assignment_op -> DIVEQ .)
    DEC             reduce using rule 46 (assignment_op -> DIVEQ .)
    INC             reduce using rule 46 (assignment_op -> DIVEQ .)
    LPARENT         reduce using rule 46 (assignment_op -> DIVEQ .)
    IDENTIFIER      reduce using rule 46 (assignment_op -> DIVEQ .)
    FLOAT           reduce using rule 46 (assignment_op -> DIVEQ .)
    INTEGER         reduce using rule 46 (assignment_op -> DIVEQ .)


state 124

    (47) assignment_op -> MULEQ .
    NOT             reduce using rule 47 (assignment_op -> MULEQ .)
    MINUS           reduce using rule 47 (assignment_op -> MULEQ .)
    PLUS            reduce using rule 47 (assignment_op -> MULEQ .)
    DEC             reduce using rule 47 (assignment_op -> MULEQ .)
    INC             reduce using rule 47 (assignment_op -> MULEQ .)
    LPARENT         reduce using rule 47 (assignment_op -> MULEQ .)
    IDENTIFIER      reduce using rule 47 (assignment_op -> MULEQ .)
    FLOAT           reduce using rule 47 (assignment_op -> MULEQ .)
    INTEGER         reduce using rule 47 (assignment_op -> MULEQ .)


state 125

    (48) assignment_op -> MINUSEQ .
    NOT             reduce using rule 48 (assignment_op -> MINUSEQ .)
    MINUS           reduce using rule 48 (assignment_op -> MINUSEQ .)
    PLUS            reduce using rule 48 (assignment_op -> MINUSEQ .)
    DEC             reduce using rule 48 (assignment_op -> MINUSEQ .)
    INC             reduce using rule 48 (assignment_op -> MINUSEQ .)
    LPARENT         reduce using rule 48 (assignment_op -> MINUSEQ .)
    IDENTIFIER      reduce using rule 48 (assignment_op -> MINUSEQ .)
    FLOAT           reduce using rule 48 (assignment_op -> MINUSEQ .)
    INTEGER         reduce using rule 48 (assignment_op -> MINUSEQ .)


state 126

    (49) assignment_op -> PLUSEQ .
    NOT             reduce using rule 49 (assignment_op -> PLUSEQ .)
    MINUS           reduce using rule 49 (assignment_op -> PLUSEQ .)
    PLUS            reduce using rule 49 (assignment_op -> PLUSEQ .)
    DEC             reduce using rule 49 (assignment_op -> PLUSEQ .)
    INC             reduce using rule 49 (assignment_op -> PLUSEQ .)
    LPARENT         reduce using rule 49 (assignment_op -> PLUSEQ .)
    IDENTIFIER      reduce using rule 49 (assignment_op -> PLUSEQ .)
    FLOAT           reduce using rule 49 (assignment_op -> PLUSEQ .)
    INTEGER         reduce using rule 49 (assignment_op -> PLUSEQ .)


state 127

    (76) block_stmt -> LBRACE stmt_list RBRACE .
    IMPORT          reduce using rule 76 (block_stmt -> LBRACE stmt_list RBRACE .)
    DEFINE          reduce using rule 76 (block_stmt -> LBRACE stmt_list RBRACE .)
    INCLUDE         reduce using rule 76 (block_stmt -> LBRACE stmt_list RBRACE .)
    VOID            reduce using rule 76 (block_stmt -> LBRACE stmt_list RBRACE .)
    STRING_T        reduce using rule 76 (block_stmt -> LBRACE stmt_list RBRACE .)
    DOUBLE          reduce using rule 76 (block_stmt -> LBRACE stmt_list RBRACE .)
    INT             reduce using rule 76 (block_stmt -> LBRACE stmt_list RBRACE .)
    $end            reduce using rule 76 (block_stmt -> LBRACE stmt_list RBRACE .)
    RBRACE          reduce using rule 76 (block_stmt -> LBRACE stmt_list RBRACE .)
    RETURN          reduce using rule 76 (block_stmt -> LBRACE stmt_list RBRACE .)
    BREAK           reduce using rule 76 (block_stmt -> LBRACE stmt_list RBRACE .)
    CONTINUE        reduce using rule 76 (block_stmt -> LBRACE stmt_list RBRACE .)
    GOTO            reduce using rule 76 (block_stmt -> LBRACE stmt_list RBRACE .)
    FOR             reduce using rule 76 (block_stmt -> LBRACE stmt_list RBRACE .)
    DO              reduce using rule 76 (block_stmt -> LBRACE stmt_list RBRACE .)
    WHILE           reduce using rule 76 (block_stmt -> LBRACE stmt_list RBRACE .)
    IF              reduce using rule 76 (block_stmt -> LBRACE stmt_list RBRACE .)
    SEMICOLON       reduce using rule 76 (block_stmt -> LBRACE stmt_list RBRACE .)
    LBRACE          reduce using rule 76 (block_stmt -> LBRACE stmt_list RBRACE .)
    IDENTIFIER      reduce using rule 76 (block_stmt -> LBRACE stmt_list RBRACE .)
    NOT             reduce using rule 76 (block_stmt -> LBRACE stmt_list RBRACE .)
    MINUS           reduce using rule 76 (block_stmt -> LBRACE stmt_list RBRACE .)
    PLUS            reduce using rule 76 (block_stmt -> LBRACE stmt_list RBRACE .)
    DEC             reduce using rule 76 (block_stmt -> LBRACE stmt_list RBRACE .)
    INC             reduce using rule 76 (block_stmt -> LBRACE stmt_list RBRACE .)
    LPARENT         reduce using rule 76 (block_stmt -> LBRACE stmt_list RBRACE .)
    FLOAT           reduce using rule 76 (block_stmt -> LBRACE stmt_list RBRACE .)
    INTEGER         reduce using rule 76 (block_stmt -> LBRACE stmt_list RBRACE .)
    ELSE            reduce using rule 76 (block_stmt -> LBRACE stmt_list RBRACE .)


state 128

    (80) stmt_list -> stmt_list stmt .
    RBRACE          reduce using rule 80 (stmt_list -> stmt_list stmt .)
    RETURN          reduce using rule 80 (stmt_list -> stmt_list stmt .)
    BREAK           reduce using rule 80 (stmt_list -> stmt_list stmt .)
    CONTINUE        reduce using rule 80 (stmt_list -> stmt_list stmt .)
    GOTO            reduce using rule 80 (stmt_list -> stmt_list stmt .)
    FOR             reduce using rule 80 (stmt_list -> stmt_list stmt .)
    DO              reduce using rule 80 (stmt_list -> stmt_list stmt .)
    WHILE           reduce using rule 80 (stmt_list -> stmt_list stmt .)
    IF              reduce using rule 80 (stmt_list -> stmt_list stmt .)
    SEMICOLON       reduce using rule 80 (stmt_list -> stmt_list stmt .)
    LBRACE          reduce using rule 80 (stmt_list -> stmt_list stmt .)
    IDENTIFIER      reduce using rule 80 (stmt_list -> stmt_list stmt .)
    VOID            reduce using rule 80 (stmt_list -> stmt_list stmt .)
    STRING_T        reduce using rule 80 (stmt_list -> stmt_list stmt .)
    DOUBLE          reduce using rule 80 (stmt_list -> stmt_list stmt .)
    INT             reduce using rule 80 (stmt_list -> stmt_list stmt .)
    NOT             reduce using rule 80 (stmt_list -> stmt_list stmt .)
    MINUS           reduce using rule 80 (stmt_list -> stmt_list stmt .)
    PLUS            reduce using rule 80 (stmt_list -> stmt_list stmt .)
    DEC             reduce using rule 80 (stmt_list -> stmt_list stmt .)
    INC             reduce using rule 80 (stmt_list -> stmt_list stmt .)
    LPARENT         reduce using rule 80 (stmt_list -> stmt_list stmt .)
    FLOAT           reduce using rule 80 (stmt_list -> stmt_list stmt .)
    INTEGER         reduce using rule 80 (stmt_list -> stmt_list stmt .)


state 129

    (90) jump_stmt -> RETURN expr . SEMICOLON
    SEMICOLON       shift and go to state 166


state 130

    (91) jump_stmt -> RETURN SEMICOLON .
    RBRACE          reduce using rule 91 (jump_stmt -> RETURN SEMICOLON .)
    RETURN          reduce using rule 91 (jump_stmt -> RETURN SEMICOLON .)
    BREAK           reduce using rule 91 (jump_stmt -> RETURN SEMICOLON .)
    CONTINUE        reduce using rule 91 (jump_stmt -> RETURN SEMICOLON .)
    GOTO            reduce using rule 91 (jump_stmt -> RETURN SEMICOLON .)
    FOR             reduce using rule 91 (jump_stmt -> RETURN SEMICOLON .)
    DO              reduce using rule 91 (jump_stmt -> RETURN SEMICOLON .)
    WHILE           reduce using rule 91 (jump_stmt -> RETURN SEMICOLON .)
    IF              reduce using rule 91 (jump_stmt -> RETURN SEMICOLON .)
    SEMICOLON       reduce using rule 91 (jump_stmt -> RETURN SEMICOLON .)
    LBRACE          reduce using rule 91 (jump_stmt -> RETURN SEMICOLON .)
    IDENTIFIER      reduce using rule 91 (jump_stmt -> RETURN SEMICOLON .)
    VOID            reduce using rule 91 (jump_stmt -> RETURN SEMICOLON .)
    STRING_T        reduce using rule 91 (jump_stmt -> RETURN SEMICOLON .)
    DOUBLE          reduce using rule 91 (jump_stmt -> RETURN SEMICOLON .)
    INT             reduce using rule 91 (jump_stmt -> RETURN SEMICOLON .)
    NOT             reduce using rule 91 (jump_stmt -> RETURN SEMICOLON .)
    MINUS           reduce using rule 91 (jump_stmt -> RETURN SEMICOLON .)
    PLUS            reduce using rule 91 (jump_stmt -> RETURN SEMICOLON .)
    DEC             reduce using rule 91 (jump_stmt -> RETURN SEMICOLON .)
    INC             reduce using rule 91 (jump_stmt -> RETURN SEMICOLON .)
    LPARENT         reduce using rule 91 (jump_stmt -> RETURN SEMICOLON .)
    FLOAT           reduce using rule 91 (jump_stmt -> RETURN SEMICOLON .)
    INTEGER         reduce using rule 91 (jump_stmt -> RETURN SEMICOLON .)
    ELSE            reduce using rule 91 (jump_stmt -> RETURN SEMICOLON .)


state 131

    (83) expr_stmt -> expr SEMICOLON .
    RBRACE          reduce using rule 83 (expr_stmt -> expr SEMICOLON .)
    RETURN          reduce using rule 83 (expr_stmt -> expr SEMICOLON .)
    BREAK           reduce using rule 83 (expr_stmt -> expr SEMICOLON .)
    CONTINUE        reduce using rule 83 (expr_stmt -> expr SEMICOLON .)
    GOTO            reduce using rule 83 (expr_stmt -> expr SEMICOLON .)
    FOR             reduce using rule 83 (expr_stmt -> expr SEMICOLON .)
    DO              reduce using rule 83 (expr_stmt -> expr SEMICOLON .)
    WHILE           reduce using rule 83 (expr_stmt -> expr SEMICOLON .)
    IF              reduce using rule 83 (expr_stmt -> expr SEMICOLON .)
    SEMICOLON       reduce using rule 83 (expr_stmt -> expr SEMICOLON .)
    LBRACE          reduce using rule 83 (expr_stmt -> expr SEMICOLON .)
    IDENTIFIER      reduce using rule 83 (expr_stmt -> expr SEMICOLON .)
    VOID            reduce using rule 83 (expr_stmt -> expr SEMICOLON .)
    STRING_T        reduce using rule 83 (expr_stmt -> expr SEMICOLON .)
    DOUBLE          reduce using rule 83 (expr_stmt -> expr SEMICOLON .)
    INT             reduce using rule 83 (expr_stmt -> expr SEMICOLON .)
    NOT             reduce using rule 83 (expr_stmt -> expr SEMICOLON .)
    MINUS           reduce using rule 83 (expr_stmt -> expr SEMICOLON .)
    PLUS            reduce using rule 83 (expr_stmt -> expr SEMICOLON .)
    DEC             reduce using rule 83 (expr_stmt -> expr SEMICOLON .)
    INC             reduce using rule 83 (expr_stmt -> expr SEMICOLON .)
    LPARENT         reduce using rule 83 (expr_stmt -> expr SEMICOLON .)
    FLOAT           reduce using rule 83 (expr_stmt -> expr SEMICOLON .)
    INTEGER         reduce using rule 83 (expr_stmt -> expr SEMICOLON .)
    ELSE            reduce using rule 83 (expr_stmt -> expr SEMICOLON .)


state 132

    (92) jump_stmt -> BREAK SEMICOLON .
    RBRACE          reduce using rule 92 (jump_stmt -> BREAK SEMICOLON .)
    RETURN          reduce using rule 92 (jump_stmt -> BREAK SEMICOLON .)
    BREAK           reduce using rule 92 (jump_stmt -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 92 (jump_stmt -> BREAK SEMICOLON .)
    GOTO            reduce using rule 92 (jump_stmt -> BREAK SEMICOLON .)
    FOR             reduce using rule 92 (jump_stmt -> BREAK SEMICOLON .)
    DO              reduce using rule 92 (jump_stmt -> BREAK SEMICOLON .)
    WHILE           reduce using rule 92 (jump_stmt -> BREAK SEMICOLON .)
    IF              reduce using rule 92 (jump_stmt -> BREAK SEMICOLON .)
    SEMICOLON       reduce using rule 92 (jump_stmt -> BREAK SEMICOLON .)
    LBRACE          reduce using rule 92 (jump_stmt -> BREAK SEMICOLON .)
    IDENTIFIER      reduce using rule 92 (jump_stmt -> BREAK SEMICOLON .)
    VOID            reduce using rule 92 (jump_stmt -> BREAK SEMICOLON .)
    STRING_T        reduce using rule 92 (jump_stmt -> BREAK SEMICOLON .)
    DOUBLE          reduce using rule 92 (jump_stmt -> BREAK SEMICOLON .)
    INT             reduce using rule 92 (jump_stmt -> BREAK SEMICOLON .)
    NOT             reduce using rule 92 (jump_stmt -> BREAK SEMICOLON .)
    MINUS           reduce using rule 92 (jump_stmt -> BREAK SEMICOLON .)
    PLUS            reduce using rule 92 (jump_stmt -> BREAK SEMICOLON .)
    DEC             reduce using rule 92 (jump_stmt -> BREAK SEMICOLON .)
    INC             reduce using rule 92 (jump_stmt -> BREAK SEMICOLON .)
    LPARENT         reduce using rule 92 (jump_stmt -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 92 (jump_stmt -> BREAK SEMICOLON .)
    INTEGER         reduce using rule 92 (jump_stmt -> BREAK SEMICOLON .)
    ELSE            reduce using rule 92 (jump_stmt -> BREAK SEMICOLON .)


state 133

    (93) jump_stmt -> CONTINUE SEMICOLON .
    RBRACE          reduce using rule 93 (jump_stmt -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 93 (jump_stmt -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 93 (jump_stmt -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 93 (jump_stmt -> CONTINUE SEMICOLON .)
    GOTO            reduce using rule 93 (jump_stmt -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 93 (jump_stmt -> CONTINUE SEMICOLON .)
    DO              reduce using rule 93 (jump_stmt -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 93 (jump_stmt -> CONTINUE SEMICOLON .)
    IF              reduce using rule 93 (jump_stmt -> CONTINUE SEMICOLON .)
    SEMICOLON       reduce using rule 93 (jump_stmt -> CONTINUE SEMICOLON .)
    LBRACE          reduce using rule 93 (jump_stmt -> CONTINUE SEMICOLON .)
    IDENTIFIER      reduce using rule 93 (jump_stmt -> CONTINUE SEMICOLON .)
    VOID            reduce using rule 93 (jump_stmt -> CONTINUE SEMICOLON .)
    STRING_T        reduce using rule 93 (jump_stmt -> CONTINUE SEMICOLON .)
    DOUBLE          reduce using rule 93 (jump_stmt -> CONTINUE SEMICOLON .)
    INT             reduce using rule 93 (jump_stmt -> CONTINUE SEMICOLON .)
    NOT             reduce using rule 93 (jump_stmt -> CONTINUE SEMICOLON .)
    MINUS           reduce using rule 93 (jump_stmt -> CONTINUE SEMICOLON .)
    PLUS            reduce using rule 93 (jump_stmt -> CONTINUE SEMICOLON .)
    DEC             reduce using rule 93 (jump_stmt -> CONTINUE SEMICOLON .)
    INC             reduce using rule 93 (jump_stmt -> CONTINUE SEMICOLON .)
    LPARENT         reduce using rule 93 (jump_stmt -> CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 93 (jump_stmt -> CONTINUE SEMICOLON .)
    INTEGER         reduce using rule 93 (jump_stmt -> CONTINUE SEMICOLON .)
    ELSE            reduce using rule 93 (jump_stmt -> CONTINUE SEMICOLON .)


state 134

    (94) jump_stmt -> GOTO IDENTIFIER . SEMICOLON
    SEMICOLON       shift and go to state 167


state 135

    (75) labeled_stmt -> IDENTIFIER COLON . stmt
    (69) stmt -> . jump_stmt
    (70) stmt -> . loop_stmt
    (71) stmt -> . if_stmt
    (72) stmt -> . expr_stmt
    (73) stmt -> . block_stmt
    (74) stmt -> . labeled_stmt
    (90) jump_stmt -> . RETURN expr SEMICOLON
    (91) jump_stmt -> . RETURN SEMICOLON
    (92) jump_stmt -> . BREAK SEMICOLON
    (93) jump_stmt -> . CONTINUE SEMICOLON
    (94) jump_stmt -> . GOTO IDENTIFIER SEMICOLON
    (87) loop_stmt -> . FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt
    (88) loop_stmt -> . DO stmt WHILE LPARENT expr RPARENT SEMICOLON
    (89) loop_stmt -> . WHILE LPARENT expr RPARENT stmt
    (85) if_stmt -> . IF LPARENT expr RPARENT stmt ELSE stmt
    (86) if_stmt -> . IF LPARENT expr RPARENT stmt
    (82) expr_stmt -> . decl
    (83) expr_stmt -> . expr SEMICOLON
    (84) expr_stmt -> . SEMICOLON
    (76) block_stmt -> . LBRACE stmt_list RBRACE
    (77) block_stmt -> . LBRACE RBRACE
    (75) labeled_stmt -> . IDENTIFIER COLON stmt
    (50) decl -> . type init_declarator SEMICOLON
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr LT add_expr
    (33) rel_expr -> . rel_expr GT add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    RETURN          shift and go to state 74
    BREAK           shift and go to state 77
    CONTINUE        shift and go to state 78
    GOTO            shift and go to state 79
    FOR             shift and go to state 81
    DO              shift and go to state 82
    WHILE           shift and go to state 83
    IF              shift and go to state 84
    SEMICOLON       shift and go to state 76
    LBRACE          shift and go to state 33
    IDENTIFIER      shift and go to state 80
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    LPARENT         shift and go to state 64
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    stmt                           shift and go to state 168
    jump_stmt                      shift and go to state 68
    loop_stmt                      shift and go to state 69
    if_stmt                        shift and go to state 70
    expr_stmt                      shift and go to state 71
    block_stmt                     shift and go to state 72
    labeled_stmt                   shift and go to state 73
    expr                           shift and go to state 75
    decl                           shift and go to state 85
    type                           shift and go to state 86
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 136

    (87) loop_stmt -> FOR LPARENT . expr_stmt expr_stmt expr RPARENT stmt
    (82) expr_stmt -> . decl
    (83) expr_stmt -> . expr SEMICOLON
    (84) expr_stmt -> . SEMICOLON
    (50) decl -> . type init_declarator SEMICOLON
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr LT add_expr
    (33) rel_expr -> . rel_expr GT add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    SEMICOLON       shift and go to state 76
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    LPARENT         shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    expr_stmt                      shift and go to state 169
    expr                           shift and go to state 75
    decl                           shift and go to state 85
    type                           shift and go to state 86
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 137

    (88) loop_stmt -> DO stmt . WHILE LPARENT expr RPARENT SEMICOLON
    WHILE           shift and go to state 170


state 138

    (89) loop_stmt -> WHILE LPARENT . expr RPARENT stmt
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr LT add_expr
    (33) rel_expr -> . rel_expr GT add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    LPARENT         shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    expr                           shift and go to state 171
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 139

    (85) if_stmt -> IF LPARENT . expr RPARENT stmt ELSE stmt
    (86) if_stmt -> IF LPARENT . expr RPARENT stmt
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr LT add_expr
    (33) rel_expr -> . rel_expr GT add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    LPARENT         shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    expr                           shift and go to state 172
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 140

    (51) init_declarator -> declarator . ASSIGN initializer
    (52) init_declarator -> declarator .
    (57) declarator -> declarator . LBRACKET RBRACKET
    (58) declarator -> declarator . LBRACKET cond_expr RBRACKET
    (59) declarator -> declarator . LPARENT RPARENT
    (60) declarator -> declarator . LPARENT param_list RPARENT
    ASSIGN          shift and go to state 32
    SEMICOLON       reduce using rule 52 (init_declarator -> declarator .)
    LBRACKET        shift and go to state 30
    LPARENT         shift and go to state 31


state 141

    (107) import_decl -> IMPORT IDENTIFIER INTEGER INTEGER STRING IDENTIFIER .
    IMPORT          reduce using rule 107 (import_decl -> IMPORT IDENTIFIER INTEGER INTEGER STRING IDENTIFIER .)
    DEFINE          reduce using rule 107 (import_decl -> IMPORT IDENTIFIER INTEGER INTEGER STRING IDENTIFIER .)
    INCLUDE         reduce using rule 107 (import_decl -> IMPORT IDENTIFIER INTEGER INTEGER STRING IDENTIFIER .)
    VOID            reduce using rule 107 (import_decl -> IMPORT IDENTIFIER INTEGER INTEGER STRING IDENTIFIER .)
    STRING_T        reduce using rule 107 (import_decl -> IMPORT IDENTIFIER INTEGER INTEGER STRING IDENTIFIER .)
    DOUBLE          reduce using rule 107 (import_decl -> IMPORT IDENTIFIER INTEGER INTEGER STRING IDENTIFIER .)
    INT             reduce using rule 107 (import_decl -> IMPORT IDENTIFIER INTEGER INTEGER STRING IDENTIFIER .)
    $end            reduce using rule 107 (import_decl -> IMPORT IDENTIFIER INTEGER INTEGER STRING IDENTIFIER .)


state 142

    (40) cond_expr -> cond_expr OR and_expr .
    (38) and_expr -> and_expr . AND eq_expr
    RBRACKET        reduce using rule 40 (cond_expr -> cond_expr OR and_expr .)
    OR              reduce using rule 40 (cond_expr -> cond_expr OR and_expr .)
    SEMICOLON       reduce using rule 40 (cond_expr -> cond_expr OR and_expr .)
    RPARENT         reduce using rule 40 (cond_expr -> cond_expr OR and_expr .)
    RBRACE          reduce using rule 40 (cond_expr -> cond_expr OR and_expr .)
    COMMA           reduce using rule 40 (cond_expr -> cond_expr OR and_expr .)
    AND             shift and go to state 90


state 143

    (38) and_expr -> and_expr AND eq_expr .
    (35) eq_expr -> eq_expr . NE rel_expr
    (36) eq_expr -> eq_expr . EQ rel_expr
    AND             reduce using rule 38 (and_expr -> and_expr AND eq_expr .)
    RBRACKET        reduce using rule 38 (and_expr -> and_expr AND eq_expr .)
    OR              reduce using rule 38 (and_expr -> and_expr AND eq_expr .)
    SEMICOLON       reduce using rule 38 (and_expr -> and_expr AND eq_expr .)
    RPARENT         reduce using rule 38 (and_expr -> and_expr AND eq_expr .)
    RBRACE          reduce using rule 38 (and_expr -> and_expr AND eq_expr .)
    COMMA           reduce using rule 38 (and_expr -> and_expr AND eq_expr .)
    NE              shift and go to state 91
    EQ              shift and go to state 92


state 144

    (35) eq_expr -> eq_expr NE rel_expr .
    (30) rel_expr -> rel_expr . LE add_expr
    (31) rel_expr -> rel_expr . GE add_expr
    (32) rel_expr -> rel_expr . LT add_expr
    (33) rel_expr -> rel_expr . GT add_expr
    NE              reduce using rule 35 (eq_expr -> eq_expr NE rel_expr .)
    EQ              reduce using rule 35 (eq_expr -> eq_expr NE rel_expr .)
    AND             reduce using rule 35 (eq_expr -> eq_expr NE rel_expr .)
    RBRACKET        reduce using rule 35 (eq_expr -> eq_expr NE rel_expr .)
    OR              reduce using rule 35 (eq_expr -> eq_expr NE rel_expr .)
    SEMICOLON       reduce using rule 35 (eq_expr -> eq_expr NE rel_expr .)
    RPARENT         reduce using rule 35 (eq_expr -> eq_expr NE rel_expr .)
    RBRACE          reduce using rule 35 (eq_expr -> eq_expr NE rel_expr .)
    COMMA           reduce using rule 35 (eq_expr -> eq_expr NE rel_expr .)
    LE              shift and go to state 93
    GE              shift and go to state 94
    LT              shift and go to state 95
    GT              shift and go to state 96


state 145

    (36) eq_expr -> eq_expr EQ rel_expr .
    (30) rel_expr -> rel_expr . LE add_expr
    (31) rel_expr -> rel_expr . GE add_expr
    (32) rel_expr -> rel_expr . LT add_expr
    (33) rel_expr -> rel_expr . GT add_expr
    NE              reduce using rule 36 (eq_expr -> eq_expr EQ rel_expr .)
    EQ              reduce using rule 36 (eq_expr -> eq_expr EQ rel_expr .)
    AND             reduce using rule 36 (eq_expr -> eq_expr EQ rel_expr .)
    RBRACKET        reduce using rule 36 (eq_expr -> eq_expr EQ rel_expr .)
    OR              reduce using rule 36 (eq_expr -> eq_expr EQ rel_expr .)
    SEMICOLON       reduce using rule 36 (eq_expr -> eq_expr EQ rel_expr .)
    RPARENT         reduce using rule 36 (eq_expr -> eq_expr EQ rel_expr .)
    RBRACE          reduce using rule 36 (eq_expr -> eq_expr EQ rel_expr .)
    COMMA           reduce using rule 36 (eq_expr -> eq_expr EQ rel_expr .)
    LE              shift and go to state 93
    GE              shift and go to state 94
    LT              shift and go to state 95
    GT              shift and go to state 96


state 146

    (30) rel_expr -> rel_expr LE add_expr .
    (27) add_expr -> add_expr . MINUS mult_expr
    (28) add_expr -> add_expr . PLUS mult_expr
    LE              reduce using rule 30 (rel_expr -> rel_expr LE add_expr .)
    GE              reduce using rule 30 (rel_expr -> rel_expr LE add_expr .)
    LT              reduce using rule 30 (rel_expr -> rel_expr LE add_expr .)
    GT              reduce using rule 30 (rel_expr -> rel_expr LE add_expr .)
    NE              reduce using rule 30 (rel_expr -> rel_expr LE add_expr .)
    EQ              reduce using rule 30 (rel_expr -> rel_expr LE add_expr .)
    AND             reduce using rule 30 (rel_expr -> rel_expr LE add_expr .)
    RBRACKET        reduce using rule 30 (rel_expr -> rel_expr LE add_expr .)
    OR              reduce using rule 30 (rel_expr -> rel_expr LE add_expr .)
    SEMICOLON       reduce using rule 30 (rel_expr -> rel_expr LE add_expr .)
    RPARENT         reduce using rule 30 (rel_expr -> rel_expr LE add_expr .)
    RBRACE          reduce using rule 30 (rel_expr -> rel_expr LE add_expr .)
    COMMA           reduce using rule 30 (rel_expr -> rel_expr LE add_expr .)
    MINUS           shift and go to state 97
    PLUS            shift and go to state 98


state 147

    (31) rel_expr -> rel_expr GE add_expr .
    (27) add_expr -> add_expr . MINUS mult_expr
    (28) add_expr -> add_expr . PLUS mult_expr
    LE              reduce using rule 31 (rel_expr -> rel_expr GE add_expr .)
    GE              reduce using rule 31 (rel_expr -> rel_expr GE add_expr .)
    LT              reduce using rule 31 (rel_expr -> rel_expr GE add_expr .)
    GT              reduce using rule 31 (rel_expr -> rel_expr GE add_expr .)
    NE              reduce using rule 31 (rel_expr -> rel_expr GE add_expr .)
    EQ              reduce using rule 31 (rel_expr -> rel_expr GE add_expr .)
    AND             reduce using rule 31 (rel_expr -> rel_expr GE add_expr .)
    RBRACKET        reduce using rule 31 (rel_expr -> rel_expr GE add_expr .)
    OR              reduce using rule 31 (rel_expr -> rel_expr GE add_expr .)
    SEMICOLON       reduce using rule 31 (rel_expr -> rel_expr GE add_expr .)
    RPARENT         reduce using rule 31 (rel_expr -> rel_expr GE add_expr .)
    RBRACE          reduce using rule 31 (rel_expr -> rel_expr GE add_expr .)
    COMMA           reduce using rule 31 (rel_expr -> rel_expr GE add_expr .)
    MINUS           shift and go to state 97
    PLUS            shift and go to state 98


state 148

    (32) rel_expr -> rel_expr LT add_expr .
    (27) add_expr -> add_expr . MINUS mult_expr
    (28) add_expr -> add_expr . PLUS mult_expr
    LE              reduce using rule 32 (rel_expr -> rel_expr LT add_expr .)
    GE              reduce using rule 32 (rel_expr -> rel_expr LT add_expr .)
    LT              reduce using rule 32 (rel_expr -> rel_expr LT add_expr .)
    GT              reduce using rule 32 (rel_expr -> rel_expr LT add_expr .)
    NE              reduce using rule 32 (rel_expr -> rel_expr LT add_expr .)
    EQ              reduce using rule 32 (rel_expr -> rel_expr LT add_expr .)
    AND             reduce using rule 32 (rel_expr -> rel_expr LT add_expr .)
    RBRACKET        reduce using rule 32 (rel_expr -> rel_expr LT add_expr .)
    OR              reduce using rule 32 (rel_expr -> rel_expr LT add_expr .)
    SEMICOLON       reduce using rule 32 (rel_expr -> rel_expr LT add_expr .)
    RPARENT         reduce using rule 32 (rel_expr -> rel_expr LT add_expr .)
    RBRACE          reduce using rule 32 (rel_expr -> rel_expr LT add_expr .)
    COMMA           reduce using rule 32 (rel_expr -> rel_expr LT add_expr .)
    MINUS           shift and go to state 97
    PLUS            shift and go to state 98


state 149

    (33) rel_expr -> rel_expr GT add_expr .
    (27) add_expr -> add_expr . MINUS mult_expr
    (28) add_expr -> add_expr . PLUS mult_expr
    LE              reduce using rule 33 (rel_expr -> rel_expr GT add_expr .)
    GE              reduce using rule 33 (rel_expr -> rel_expr GT add_expr .)
    LT              reduce using rule 33 (rel_expr -> rel_expr GT add_expr .)
    GT              reduce using rule 33 (rel_expr -> rel_expr GT add_expr .)
    NE              reduce using rule 33 (rel_expr -> rel_expr GT add_expr .)
    EQ              reduce using rule 33 (rel_expr -> rel_expr GT add_expr .)
    AND             reduce using rule 33 (rel_expr -> rel_expr GT add_expr .)
    RBRACKET        reduce using rule 33 (rel_expr -> rel_expr GT add_expr .)
    OR              reduce using rule 33 (rel_expr -> rel_expr GT add_expr .)
    SEMICOLON       reduce using rule 33 (rel_expr -> rel_expr GT add_expr .)
    RPARENT         reduce using rule 33 (rel_expr -> rel_expr GT add_expr .)
    RBRACE          reduce using rule 33 (rel_expr -> rel_expr GT add_expr .)
    COMMA           reduce using rule 33 (rel_expr -> rel_expr GT add_expr .)
    MINUS           shift and go to state 97
    PLUS            shift and go to state 98


state 150

    (27) add_expr -> add_expr MINUS mult_expr .
    (23) mult_expr -> mult_expr . MOD cast_expr
    (24) mult_expr -> mult_expr . DIV cast_expr
    (25) mult_expr -> mult_expr . MUL cast_expr
    MINUS           reduce using rule 27 (add_expr -> add_expr MINUS mult_expr .)
    PLUS            reduce using rule 27 (add_expr -> add_expr MINUS mult_expr .)
    LE              reduce using rule 27 (add_expr -> add_expr MINUS mult_expr .)
    GE              reduce using rule 27 (add_expr -> add_expr MINUS mult_expr .)
    LT              reduce using rule 27 (add_expr -> add_expr MINUS mult_expr .)
    GT              reduce using rule 27 (add_expr -> add_expr MINUS mult_expr .)
    NE              reduce using rule 27 (add_expr -> add_expr MINUS mult_expr .)
    EQ              reduce using rule 27 (add_expr -> add_expr MINUS mult_expr .)
    AND             reduce using rule 27 (add_expr -> add_expr MINUS mult_expr .)
    RBRACKET        reduce using rule 27 (add_expr -> add_expr MINUS mult_expr .)
    OR              reduce using rule 27 (add_expr -> add_expr MINUS mult_expr .)
    SEMICOLON       reduce using rule 27 (add_expr -> add_expr MINUS mult_expr .)
    RPARENT         reduce using rule 27 (add_expr -> add_expr MINUS mult_expr .)
    RBRACE          reduce using rule 27 (add_expr -> add_expr MINUS mult_expr .)
    COMMA           reduce using rule 27 (add_expr -> add_expr MINUS mult_expr .)
    MOD             shift and go to state 100
    DIV             shift and go to state 101
    MUL             shift and go to state 102


state 151

    (28) add_expr -> add_expr PLUS mult_expr .
    (23) mult_expr -> mult_expr . MOD cast_expr
    (24) mult_expr -> mult_expr . DIV cast_expr
    (25) mult_expr -> mult_expr . MUL cast_expr
    MINUS           reduce using rule 28 (add_expr -> add_expr PLUS mult_expr .)
    PLUS            reduce using rule 28 (add_expr -> add_expr PLUS mult_expr .)
    LE              reduce using rule 28 (add_expr -> add_expr PLUS mult_expr .)
    GE              reduce using rule 28 (add_expr -> add_expr PLUS mult_expr .)
    LT              reduce using rule 28 (add_expr -> add_expr PLUS mult_expr .)
    GT              reduce using rule 28 (add_expr -> add_expr PLUS mult_expr .)
    NE              reduce using rule 28 (add_expr -> add_expr PLUS mult_expr .)
    EQ              reduce using rule 28 (add_expr -> add_expr PLUS mult_expr .)
    AND             reduce using rule 28 (add_expr -> add_expr PLUS mult_expr .)
    RBRACKET        reduce using rule 28 (add_expr -> add_expr PLUS mult_expr .)
    OR              reduce using rule 28 (add_expr -> add_expr PLUS mult_expr .)
    SEMICOLON       reduce using rule 28 (add_expr -> add_expr PLUS mult_expr .)
    RPARENT         reduce using rule 28 (add_expr -> add_expr PLUS mult_expr .)
    RBRACE          reduce using rule 28 (add_expr -> add_expr PLUS mult_expr .)
    COMMA           reduce using rule 28 (add_expr -> add_expr PLUS mult_expr .)
    MOD             shift and go to state 100
    DIV             shift and go to state 101
    MUL             shift and go to state 102


state 152

    (23) mult_expr -> mult_expr MOD cast_expr .
    MOD             reduce using rule 23 (mult_expr -> mult_expr MOD cast_expr .)
    DIV             reduce using rule 23 (mult_expr -> mult_expr MOD cast_expr .)
    MUL             reduce using rule 23 (mult_expr -> mult_expr MOD cast_expr .)
    MINUS           reduce using rule 23 (mult_expr -> mult_expr MOD cast_expr .)
    PLUS            reduce using rule 23 (mult_expr -> mult_expr MOD cast_expr .)
    LE              reduce using rule 23 (mult_expr -> mult_expr MOD cast_expr .)
    GE              reduce using rule 23 (mult_expr -> mult_expr MOD cast_expr .)
    LT              reduce using rule 23 (mult_expr -> mult_expr MOD cast_expr .)
    GT              reduce using rule 23 (mult_expr -> mult_expr MOD cast_expr .)
    NE              reduce using rule 23 (mult_expr -> mult_expr MOD cast_expr .)
    EQ              reduce using rule 23 (mult_expr -> mult_expr MOD cast_expr .)
    AND             reduce using rule 23 (mult_expr -> mult_expr MOD cast_expr .)
    RBRACKET        reduce using rule 23 (mult_expr -> mult_expr MOD cast_expr .)
    OR              reduce using rule 23 (mult_expr -> mult_expr MOD cast_expr .)
    SEMICOLON       reduce using rule 23 (mult_expr -> mult_expr MOD cast_expr .)
    RPARENT         reduce using rule 23 (mult_expr -> mult_expr MOD cast_expr .)
    RBRACE          reduce using rule 23 (mult_expr -> mult_expr MOD cast_expr .)
    COMMA           reduce using rule 23 (mult_expr -> mult_expr MOD cast_expr .)


state 153

    (24) mult_expr -> mult_expr DIV cast_expr .
    MOD             reduce using rule 24 (mult_expr -> mult_expr DIV cast_expr .)
    DIV             reduce using rule 24 (mult_expr -> mult_expr DIV cast_expr .)
    MUL             reduce using rule 24 (mult_expr -> mult_expr DIV cast_expr .)
    MINUS           reduce using rule 24 (mult_expr -> mult_expr DIV cast_expr .)
    PLUS            reduce using rule 24 (mult_expr -> mult_expr DIV cast_expr .)
    LE              reduce using rule 24 (mult_expr -> mult_expr DIV cast_expr .)
    GE              reduce using rule 24 (mult_expr -> mult_expr DIV cast_expr .)
    LT              reduce using rule 24 (mult_expr -> mult_expr DIV cast_expr .)
    GT              reduce using rule 24 (mult_expr -> mult_expr DIV cast_expr .)
    NE              reduce using rule 24 (mult_expr -> mult_expr DIV cast_expr .)
    EQ              reduce using rule 24 (mult_expr -> mult_expr DIV cast_expr .)
    AND             reduce using rule 24 (mult_expr -> mult_expr DIV cast_expr .)
    RBRACKET        reduce using rule 24 (mult_expr -> mult_expr DIV cast_expr .)
    OR              reduce using rule 24 (mult_expr -> mult_expr DIV cast_expr .)
    SEMICOLON       reduce using rule 24 (mult_expr -> mult_expr DIV cast_expr .)
    RPARENT         reduce using rule 24 (mult_expr -> mult_expr DIV cast_expr .)
    RBRACE          reduce using rule 24 (mult_expr -> mult_expr DIV cast_expr .)
    COMMA           reduce using rule 24 (mult_expr -> mult_expr DIV cast_expr .)


state 154

    (25) mult_expr -> mult_expr MUL cast_expr .
    MOD             reduce using rule 25 (mult_expr -> mult_expr MUL cast_expr .)
    DIV             reduce using rule 25 (mult_expr -> mult_expr MUL cast_expr .)
    MUL             reduce using rule 25 (mult_expr -> mult_expr MUL cast_expr .)
    MINUS           reduce using rule 25 (mult_expr -> mult_expr MUL cast_expr .)
    PLUS            reduce using rule 25 (mult_expr -> mult_expr MUL cast_expr .)
    LE              reduce using rule 25 (mult_expr -> mult_expr MUL cast_expr .)
    GE              reduce using rule 25 (mult_expr -> mult_expr MUL cast_expr .)
    LT              reduce using rule 25 (mult_expr -> mult_expr MUL cast_expr .)
    GT              reduce using rule 25 (mult_expr -> mult_expr MUL cast_expr .)
    NE              reduce using rule 25 (mult_expr -> mult_expr MUL cast_expr .)
    EQ              reduce using rule 25 (mult_expr -> mult_expr MUL cast_expr .)
    AND             reduce using rule 25 (mult_expr -> mult_expr MUL cast_expr .)
    RBRACKET        reduce using rule 25 (mult_expr -> mult_expr MUL cast_expr .)
    OR              reduce using rule 25 (mult_expr -> mult_expr MUL cast_expr .)
    SEMICOLON       reduce using rule 25 (mult_expr -> mult_expr MUL cast_expr .)
    RPARENT         reduce using rule 25 (mult_expr -> mult_expr MUL cast_expr .)
    RBRACE          reduce using rule 25 (mult_expr -> mult_expr MUL cast_expr .)
    COMMA           reduce using rule 25 (mult_expr -> mult_expr MUL cast_expr .)


state 155

    (22) cast_expr -> LPARENT type RPARENT . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    LPARENT         shift and go to state 47
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    cast_expr                      shift and go to state 173
    unary_expr                     shift and go to state 46
    postfix_expr                   shift and go to state 51
    primary_expr                   shift and go to state 53
    literal                        shift and go to state 54

state 156

    (3) primary_expr -> LPARENT expr RPARENT .
    DEC             reduce using rule 3 (primary_expr -> LPARENT expr RPARENT .)
    INC             reduce using rule 3 (primary_expr -> LPARENT expr RPARENT .)
    DOT             reduce using rule 3 (primary_expr -> LPARENT expr RPARENT .)
    LPARENT         reduce using rule 3 (primary_expr -> LPARENT expr RPARENT .)
    LBRACKET        reduce using rule 3 (primary_expr -> LPARENT expr RPARENT .)
    MOD             reduce using rule 3 (primary_expr -> LPARENT expr RPARENT .)
    DIV             reduce using rule 3 (primary_expr -> LPARENT expr RPARENT .)
    MUL             reduce using rule 3 (primary_expr -> LPARENT expr RPARENT .)
    MINUS           reduce using rule 3 (primary_expr -> LPARENT expr RPARENT .)
    PLUS            reduce using rule 3 (primary_expr -> LPARENT expr RPARENT .)
    LE              reduce using rule 3 (primary_expr -> LPARENT expr RPARENT .)
    GE              reduce using rule 3 (primary_expr -> LPARENT expr RPARENT .)
    LT              reduce using rule 3 (primary_expr -> LPARENT expr RPARENT .)
    GT              reduce using rule 3 (primary_expr -> LPARENT expr RPARENT .)
    NE              reduce using rule 3 (primary_expr -> LPARENT expr RPARENT .)
    EQ              reduce using rule 3 (primary_expr -> LPARENT expr RPARENT .)
    AND             reduce using rule 3 (primary_expr -> LPARENT expr RPARENT .)
    RBRACKET        reduce using rule 3 (primary_expr -> LPARENT expr RPARENT .)
    OR              reduce using rule 3 (primary_expr -> LPARENT expr RPARENT .)
    ASSIGN          reduce using rule 3 (primary_expr -> LPARENT expr RPARENT .)
    MODEQ           reduce using rule 3 (primary_expr -> LPARENT expr RPARENT .)
    DIVEQ           reduce using rule 3 (primary_expr -> LPARENT expr RPARENT .)
    MULEQ           reduce using rule 3 (primary_expr -> LPARENT expr RPARENT .)
    MINUSEQ         reduce using rule 3 (primary_expr -> LPARENT expr RPARENT .)
    PLUSEQ          reduce using rule 3 (primary_expr -> LPARENT expr RPARENT .)
    SEMICOLON       reduce using rule 3 (primary_expr -> LPARENT expr RPARENT .)
    RPARENT         reduce using rule 3 (primary_expr -> LPARENT expr RPARENT .)
    RBRACE          reduce using rule 3 (primary_expr -> LPARENT expr RPARENT .)
    COMMA           reduce using rule 3 (primary_expr -> LPARENT expr RPARENT .)


state 157

    (8) postfix_expr -> postfix_expr DOT IDENTIFIER .
    DEC             reduce using rule 8 (postfix_expr -> postfix_expr DOT IDENTIFIER .)
    INC             reduce using rule 8 (postfix_expr -> postfix_expr DOT IDENTIFIER .)
    DOT             reduce using rule 8 (postfix_expr -> postfix_expr DOT IDENTIFIER .)
    LPARENT         reduce using rule 8 (postfix_expr -> postfix_expr DOT IDENTIFIER .)
    LBRACKET        reduce using rule 8 (postfix_expr -> postfix_expr DOT IDENTIFIER .)
    MOD             reduce using rule 8 (postfix_expr -> postfix_expr DOT IDENTIFIER .)
    DIV             reduce using rule 8 (postfix_expr -> postfix_expr DOT IDENTIFIER .)
    MUL             reduce using rule 8 (postfix_expr -> postfix_expr DOT IDENTIFIER .)
    MINUS           reduce using rule 8 (postfix_expr -> postfix_expr DOT IDENTIFIER .)
    PLUS            reduce using rule 8 (postfix_expr -> postfix_expr DOT IDENTIFIER .)
    LE              reduce using rule 8 (postfix_expr -> postfix_expr DOT IDENTIFIER .)
    GE              reduce using rule 8 (postfix_expr -> postfix_expr DOT IDENTIFIER .)
    LT              reduce using rule 8 (postfix_expr -> postfix_expr DOT IDENTIFIER .)
    GT              reduce using rule 8 (postfix_expr -> postfix_expr DOT IDENTIFIER .)
    NE              reduce using rule 8 (postfix_expr -> postfix_expr DOT IDENTIFIER .)
    EQ              reduce using rule 8 (postfix_expr -> postfix_expr DOT IDENTIFIER .)
    AND             reduce using rule 8 (postfix_expr -> postfix_expr DOT IDENTIFIER .)
    RBRACKET        reduce using rule 8 (postfix_expr -> postfix_expr DOT IDENTIFIER .)
    OR              reduce using rule 8 (postfix_expr -> postfix_expr DOT IDENTIFIER .)
    ASSIGN          reduce using rule 8 (postfix_expr -> postfix_expr DOT IDENTIFIER .)
    MODEQ           reduce using rule 8 (postfix_expr -> postfix_expr DOT IDENTIFIER .)
    DIVEQ           reduce using rule 8 (postfix_expr -> postfix_expr DOT IDENTIFIER .)
    MULEQ           reduce using rule 8 (postfix_expr -> postfix_expr DOT IDENTIFIER .)
    MINUSEQ         reduce using rule 8 (postfix_expr -> postfix_expr DOT IDENTIFIER .)
    PLUSEQ          reduce using rule 8 (postfix_expr -> postfix_expr DOT IDENTIFIER .)
    SEMICOLON       reduce using rule 8 (postfix_expr -> postfix_expr DOT IDENTIFIER .)
    RPARENT         reduce using rule 8 (postfix_expr -> postfix_expr DOT IDENTIFIER .)
    RBRACE          reduce using rule 8 (postfix_expr -> postfix_expr DOT IDENTIFIER .)
    COMMA           reduce using rule 8 (postfix_expr -> postfix_expr DOT IDENTIFIER .)


state 158

    (9) postfix_expr -> postfix_expr LPARENT arg_expr_list . RPARENT
    (13) arg_expr_list -> arg_expr_list . COMMA expr
    RPARENT         shift and go to state 174
    COMMA           shift and go to state 175


state 159

    (10) postfix_expr -> postfix_expr LPARENT RPARENT .
    DEC             reduce using rule 10 (postfix_expr -> postfix_expr LPARENT RPARENT .)
    INC             reduce using rule 10 (postfix_expr -> postfix_expr LPARENT RPARENT .)
    DOT             reduce using rule 10 (postfix_expr -> postfix_expr LPARENT RPARENT .)
    LPARENT         reduce using rule 10 (postfix_expr -> postfix_expr LPARENT RPARENT .)
    LBRACKET        reduce using rule 10 (postfix_expr -> postfix_expr LPARENT RPARENT .)
    MOD             reduce using rule 10 (postfix_expr -> postfix_expr LPARENT RPARENT .)
    DIV             reduce using rule 10 (postfix_expr -> postfix_expr LPARENT RPARENT .)
    MUL             reduce using rule 10 (postfix_expr -> postfix_expr LPARENT RPARENT .)
    MINUS           reduce using rule 10 (postfix_expr -> postfix_expr LPARENT RPARENT .)
    PLUS            reduce using rule 10 (postfix_expr -> postfix_expr LPARENT RPARENT .)
    LE              reduce using rule 10 (postfix_expr -> postfix_expr LPARENT RPARENT .)
    GE              reduce using rule 10 (postfix_expr -> postfix_expr LPARENT RPARENT .)
    LT              reduce using rule 10 (postfix_expr -> postfix_expr LPARENT RPARENT .)
    GT              reduce using rule 10 (postfix_expr -> postfix_expr LPARENT RPARENT .)
    NE              reduce using rule 10 (postfix_expr -> postfix_expr LPARENT RPARENT .)
    EQ              reduce using rule 10 (postfix_expr -> postfix_expr LPARENT RPARENT .)
    AND             reduce using rule 10 (postfix_expr -> postfix_expr LPARENT RPARENT .)
    RBRACKET        reduce using rule 10 (postfix_expr -> postfix_expr LPARENT RPARENT .)
    OR              reduce using rule 10 (postfix_expr -> postfix_expr LPARENT RPARENT .)
    ASSIGN          reduce using rule 10 (postfix_expr -> postfix_expr LPARENT RPARENT .)
    MODEQ           reduce using rule 10 (postfix_expr -> postfix_expr LPARENT RPARENT .)
    DIVEQ           reduce using rule 10 (postfix_expr -> postfix_expr LPARENT RPARENT .)
    MULEQ           reduce using rule 10 (postfix_expr -> postfix_expr LPARENT RPARENT .)
    MINUSEQ         reduce using rule 10 (postfix_expr -> postfix_expr LPARENT RPARENT .)
    PLUSEQ          reduce using rule 10 (postfix_expr -> postfix_expr LPARENT RPARENT .)
    SEMICOLON       reduce using rule 10 (postfix_expr -> postfix_expr LPARENT RPARENT .)
    RPARENT         reduce using rule 10 (postfix_expr -> postfix_expr LPARENT RPARENT .)
    RBRACE          reduce using rule 10 (postfix_expr -> postfix_expr LPARENT RPARENT .)
    COMMA           reduce using rule 10 (postfix_expr -> postfix_expr LPARENT RPARENT .)


state 160

    (14) arg_expr_list -> expr .
    RPARENT         reduce using rule 14 (arg_expr_list -> expr .)
    COMMA           reduce using rule 14 (arg_expr_list -> expr .)


state 161

    (11) postfix_expr -> postfix_expr LBRACKET expr . RBRACKET
    RBRACKET        shift and go to state 176


state 162

    (62) param_list -> param_list COMMA param_decl .
    RPARENT         reduce using rule 62 (param_list -> param_list COMMA param_decl .)
    COMMA           reduce using rule 62 (param_list -> param_list COMMA param_decl .)


state 163

    (65) initializer -> LBRACE initializer_list RBRACE .
    SEMICOLON       reduce using rule 65 (initializer -> LBRACE initializer_list RBRACE .)
    RBRACE          reduce using rule 65 (initializer -> LBRACE initializer_list RBRACE .)
    COMMA           reduce using rule 65 (initializer -> LBRACE initializer_list RBRACE .)


state 164

    (67) initializer_list -> initializer_list COMMA . initializer
    (65) initializer -> . LBRACE initializer_list RBRACE
    (66) initializer -> . expr
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr LT add_expr
    (33) rel_expr -> . rel_expr GT add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    LBRACE          shift and go to state 60
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    LPARENT         shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    initializer                    shift and go to state 177
    expr                           shift and go to state 61
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 165

    (42) expr -> unary_expr assignment_op expr .
    SEMICOLON       reduce using rule 42 (expr -> unary_expr assignment_op expr .)
    RPARENT         reduce using rule 42 (expr -> unary_expr assignment_op expr .)
    RBRACE          reduce using rule 42 (expr -> unary_expr assignment_op expr .)
    COMMA           reduce using rule 42 (expr -> unary_expr assignment_op expr .)
    RBRACKET        reduce using rule 42 (expr -> unary_expr assignment_op expr .)


state 166

    (90) jump_stmt -> RETURN expr SEMICOLON .
    RBRACE          reduce using rule 90 (jump_stmt -> RETURN expr SEMICOLON .)
    RETURN          reduce using rule 90 (jump_stmt -> RETURN expr SEMICOLON .)
    BREAK           reduce using rule 90 (jump_stmt -> RETURN expr SEMICOLON .)
    CONTINUE        reduce using rule 90 (jump_stmt -> RETURN expr SEMICOLON .)
    GOTO            reduce using rule 90 (jump_stmt -> RETURN expr SEMICOLON .)
    FOR             reduce using rule 90 (jump_stmt -> RETURN expr SEMICOLON .)
    DO              reduce using rule 90 (jump_stmt -> RETURN expr SEMICOLON .)
    WHILE           reduce using rule 90 (jump_stmt -> RETURN expr SEMICOLON .)
    IF              reduce using rule 90 (jump_stmt -> RETURN expr SEMICOLON .)
    SEMICOLON       reduce using rule 90 (jump_stmt -> RETURN expr SEMICOLON .)
    LBRACE          reduce using rule 90 (jump_stmt -> RETURN expr SEMICOLON .)
    IDENTIFIER      reduce using rule 90 (jump_stmt -> RETURN expr SEMICOLON .)
    VOID            reduce using rule 90 (jump_stmt -> RETURN expr SEMICOLON .)
    STRING_T        reduce using rule 90 (jump_stmt -> RETURN expr SEMICOLON .)
    DOUBLE          reduce using rule 90 (jump_stmt -> RETURN expr SEMICOLON .)
    INT             reduce using rule 90 (jump_stmt -> RETURN expr SEMICOLON .)
    NOT             reduce using rule 90 (jump_stmt -> RETURN expr SEMICOLON .)
    MINUS           reduce using rule 90 (jump_stmt -> RETURN expr SEMICOLON .)
    PLUS            reduce using rule 90 (jump_stmt -> RETURN expr SEMICOLON .)
    DEC             reduce using rule 90 (jump_stmt -> RETURN expr SEMICOLON .)
    INC             reduce using rule 90 (jump_stmt -> RETURN expr SEMICOLON .)
    LPARENT         reduce using rule 90 (jump_stmt -> RETURN expr SEMICOLON .)
    FLOAT           reduce using rule 90 (jump_stmt -> RETURN expr SEMICOLON .)
    INTEGER         reduce using rule 90 (jump_stmt -> RETURN expr SEMICOLON .)
    ELSE            reduce using rule 90 (jump_stmt -> RETURN expr SEMICOLON .)


state 167

    (94) jump_stmt -> GOTO IDENTIFIER SEMICOLON .
    RBRACE          reduce using rule 94 (jump_stmt -> GOTO IDENTIFIER SEMICOLON .)
    RETURN          reduce using rule 94 (jump_stmt -> GOTO IDENTIFIER SEMICOLON .)
    BREAK           reduce using rule 94 (jump_stmt -> GOTO IDENTIFIER SEMICOLON .)
    CONTINUE        reduce using rule 94 (jump_stmt -> GOTO IDENTIFIER SEMICOLON .)
    GOTO            reduce using rule 94 (jump_stmt -> GOTO IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 94 (jump_stmt -> GOTO IDENTIFIER SEMICOLON .)
    DO              reduce using rule 94 (jump_stmt -> GOTO IDENTIFIER SEMICOLON .)
    WHILE           reduce using rule 94 (jump_stmt -> GOTO IDENTIFIER SEMICOLON .)
    IF              reduce using rule 94 (jump_stmt -> GOTO IDENTIFIER SEMICOLON .)
    SEMICOLON       reduce using rule 94 (jump_stmt -> GOTO IDENTIFIER SEMICOLON .)
    LBRACE          reduce using rule 94 (jump_stmt -> GOTO IDENTIFIER SEMICOLON .)
    IDENTIFIER      reduce using rule 94 (jump_stmt -> GOTO IDENTIFIER SEMICOLON .)
    VOID            reduce using rule 94 (jump_stmt -> GOTO IDENTIFIER SEMICOLON .)
    STRING_T        reduce using rule 94 (jump_stmt -> GOTO IDENTIFIER SEMICOLON .)
    DOUBLE          reduce using rule 94 (jump_stmt -> GOTO IDENTIFIER SEMICOLON .)
    INT             reduce using rule 94 (jump_stmt -> GOTO IDENTIFIER SEMICOLON .)
    NOT             reduce using rule 94 (jump_stmt -> GOTO IDENTIFIER SEMICOLON .)
    MINUS           reduce using rule 94 (jump_stmt -> GOTO IDENTIFIER SEMICOLON .)
    PLUS            reduce using rule 94 (jump_stmt -> GOTO IDENTIFIER SEMICOLON .)
    DEC             reduce using rule 94 (jump_stmt -> GOTO IDENTIFIER SEMICOLON .)
    INC             reduce using rule 94 (jump_stmt -> GOTO IDENTIFIER SEMICOLON .)
    LPARENT         reduce using rule 94 (jump_stmt -> GOTO IDENTIFIER SEMICOLON .)
    FLOAT           reduce using rule 94 (jump_stmt -> GOTO IDENTIFIER SEMICOLON .)
    INTEGER         reduce using rule 94 (jump_stmt -> GOTO IDENTIFIER SEMICOLON .)
    ELSE            reduce using rule 94 (jump_stmt -> GOTO IDENTIFIER SEMICOLON .)


state 168

    (75) labeled_stmt -> IDENTIFIER COLON stmt .
    RBRACE          reduce using rule 75 (labeled_stmt -> IDENTIFIER COLON stmt .)
    RETURN          reduce using rule 75 (labeled_stmt -> IDENTIFIER COLON stmt .)
    BREAK           reduce using rule 75 (labeled_stmt -> IDENTIFIER COLON stmt .)
    CONTINUE        reduce using rule 75 (labeled_stmt -> IDENTIFIER COLON stmt .)
    GOTO            reduce using rule 75 (labeled_stmt -> IDENTIFIER COLON stmt .)
    FOR             reduce using rule 75 (labeled_stmt -> IDENTIFIER COLON stmt .)
    DO              reduce using rule 75 (labeled_stmt -> IDENTIFIER COLON stmt .)
    WHILE           reduce using rule 75 (labeled_stmt -> IDENTIFIER COLON stmt .)
    IF              reduce using rule 75 (labeled_stmt -> IDENTIFIER COLON stmt .)
    SEMICOLON       reduce using rule 75 (labeled_stmt -> IDENTIFIER COLON stmt .)
    LBRACE          reduce using rule 75 (labeled_stmt -> IDENTIFIER COLON stmt .)
    IDENTIFIER      reduce using rule 75 (labeled_stmt -> IDENTIFIER COLON stmt .)
    VOID            reduce using rule 75 (labeled_stmt -> IDENTIFIER COLON stmt .)
    STRING_T        reduce using rule 75 (labeled_stmt -> IDENTIFIER COLON stmt .)
    DOUBLE          reduce using rule 75 (labeled_stmt -> IDENTIFIER COLON stmt .)
    INT             reduce using rule 75 (labeled_stmt -> IDENTIFIER COLON stmt .)
    NOT             reduce using rule 75 (labeled_stmt -> IDENTIFIER COLON stmt .)
    MINUS           reduce using rule 75 (labeled_stmt -> IDENTIFIER COLON stmt .)
    PLUS            reduce using rule 75 (labeled_stmt -> IDENTIFIER COLON stmt .)
    DEC             reduce using rule 75 (labeled_stmt -> IDENTIFIER COLON stmt .)
    INC             reduce using rule 75 (labeled_stmt -> IDENTIFIER COLON stmt .)
    LPARENT         reduce using rule 75 (labeled_stmt -> IDENTIFIER COLON stmt .)
    FLOAT           reduce using rule 75 (labeled_stmt -> IDENTIFIER COLON stmt .)
    INTEGER         reduce using rule 75 (labeled_stmt -> IDENTIFIER COLON stmt .)
    ELSE            reduce using rule 75 (labeled_stmt -> IDENTIFIER COLON stmt .)


state 169

    (87) loop_stmt -> FOR LPARENT expr_stmt . expr_stmt expr RPARENT stmt
    (82) expr_stmt -> . decl
    (83) expr_stmt -> . expr SEMICOLON
    (84) expr_stmt -> . SEMICOLON
    (50) decl -> . type init_declarator SEMICOLON
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr LT add_expr
    (33) rel_expr -> . rel_expr GT add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    SEMICOLON       shift and go to state 76
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    LPARENT         shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    expr_stmt                      shift and go to state 178
    expr                           shift and go to state 75
    decl                           shift and go to state 85
    type                           shift and go to state 86
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 170

    (88) loop_stmt -> DO stmt WHILE . LPARENT expr RPARENT SEMICOLON
    LPARENT         shift and go to state 179


state 171

    (89) loop_stmt -> WHILE LPARENT expr . RPARENT stmt
    RPARENT         shift and go to state 180


state 172

    (85) if_stmt -> IF LPARENT expr . RPARENT stmt ELSE stmt
    (86) if_stmt -> IF LPARENT expr . RPARENT stmt
    RPARENT         shift and go to state 181


state 173

    (22) cast_expr -> LPARENT type RPARENT cast_expr .
    MOD             reduce using rule 22 (cast_expr -> LPARENT type RPARENT cast_expr .)
    DIV             reduce using rule 22 (cast_expr -> LPARENT type RPARENT cast_expr .)
    MUL             reduce using rule 22 (cast_expr -> LPARENT type RPARENT cast_expr .)
    MINUS           reduce using rule 22 (cast_expr -> LPARENT type RPARENT cast_expr .)
    PLUS            reduce using rule 22 (cast_expr -> LPARENT type RPARENT cast_expr .)
    LE              reduce using rule 22 (cast_expr -> LPARENT type RPARENT cast_expr .)
    GE              reduce using rule 22 (cast_expr -> LPARENT type RPARENT cast_expr .)
    LT              reduce using rule 22 (cast_expr -> LPARENT type RPARENT cast_expr .)
    GT              reduce using rule 22 (cast_expr -> LPARENT type RPARENT cast_expr .)
    NE              reduce using rule 22 (cast_expr -> LPARENT type RPARENT cast_expr .)
    EQ              reduce using rule 22 (cast_expr -> LPARENT type RPARENT cast_expr .)
    AND             reduce using rule 22 (cast_expr -> LPARENT type RPARENT cast_expr .)
    RBRACKET        reduce using rule 22 (cast_expr -> LPARENT type RPARENT cast_expr .)
    OR              reduce using rule 22 (cast_expr -> LPARENT type RPARENT cast_expr .)
    SEMICOLON       reduce using rule 22 (cast_expr -> LPARENT type RPARENT cast_expr .)
    ASSIGN          reduce using rule 22 (cast_expr -> LPARENT type RPARENT cast_expr .)
    MODEQ           reduce using rule 22 (cast_expr -> LPARENT type RPARENT cast_expr .)
    DIVEQ           reduce using rule 22 (cast_expr -> LPARENT type RPARENT cast_expr .)
    MULEQ           reduce using rule 22 (cast_expr -> LPARENT type RPARENT cast_expr .)
    MINUSEQ         reduce using rule 22 (cast_expr -> LPARENT type RPARENT cast_expr .)
    PLUSEQ          reduce using rule 22 (cast_expr -> LPARENT type RPARENT cast_expr .)
    RPARENT         reduce using rule 22 (cast_expr -> LPARENT type RPARENT cast_expr .)
    RBRACE          reduce using rule 22 (cast_expr -> LPARENT type RPARENT cast_expr .)
    COMMA           reduce using rule 22 (cast_expr -> LPARENT type RPARENT cast_expr .)


state 174

    (9) postfix_expr -> postfix_expr LPARENT arg_expr_list RPARENT .
    DEC             reduce using rule 9 (postfix_expr -> postfix_expr LPARENT arg_expr_list RPARENT .)
    INC             reduce using rule 9 (postfix_expr -> postfix_expr LPARENT arg_expr_list RPARENT .)
    DOT             reduce using rule 9 (postfix_expr -> postfix_expr LPARENT arg_expr_list RPARENT .)
    LPARENT         reduce using rule 9 (postfix_expr -> postfix_expr LPARENT arg_expr_list RPARENT .)
    LBRACKET        reduce using rule 9 (postfix_expr -> postfix_expr LPARENT arg_expr_list RPARENT .)
    MOD             reduce using rule 9 (postfix_expr -> postfix_expr LPARENT arg_expr_list RPARENT .)
    DIV             reduce using rule 9 (postfix_expr -> postfix_expr LPARENT arg_expr_list RPARENT .)
    MUL             reduce using rule 9 (postfix_expr -> postfix_expr LPARENT arg_expr_list RPARENT .)
    MINUS           reduce using rule 9 (postfix_expr -> postfix_expr LPARENT arg_expr_list RPARENT .)
    PLUS            reduce using rule 9 (postfix_expr -> postfix_expr LPARENT arg_expr_list RPARENT .)
    LE              reduce using rule 9 (postfix_expr -> postfix_expr LPARENT arg_expr_list RPARENT .)
    GE              reduce using rule 9 (postfix_expr -> postfix_expr LPARENT arg_expr_list RPARENT .)
    LT              reduce using rule 9 (postfix_expr -> postfix_expr LPARENT arg_expr_list RPARENT .)
    GT              reduce using rule 9 (postfix_expr -> postfix_expr LPARENT arg_expr_list RPARENT .)
    NE              reduce using rule 9 (postfix_expr -> postfix_expr LPARENT arg_expr_list RPARENT .)
    EQ              reduce using rule 9 (postfix_expr -> postfix_expr LPARENT arg_expr_list RPARENT .)
    AND             reduce using rule 9 (postfix_expr -> postfix_expr LPARENT arg_expr_list RPARENT .)
    RBRACKET        reduce using rule 9 (postfix_expr -> postfix_expr LPARENT arg_expr_list RPARENT .)
    OR              reduce using rule 9 (postfix_expr -> postfix_expr LPARENT arg_expr_list RPARENT .)
    ASSIGN          reduce using rule 9 (postfix_expr -> postfix_expr LPARENT arg_expr_list RPARENT .)
    MODEQ           reduce using rule 9 (postfix_expr -> postfix_expr LPARENT arg_expr_list RPARENT .)
    DIVEQ           reduce using rule 9 (postfix_expr -> postfix_expr LPARENT arg_expr_list RPARENT .)
    MULEQ           reduce using rule 9 (postfix_expr -> postfix_expr LPARENT arg_expr_list RPARENT .)
    MINUSEQ         reduce using rule 9 (postfix_expr -> postfix_expr LPARENT arg_expr_list RPARENT .)
    PLUSEQ          reduce using rule 9 (postfix_expr -> postfix_expr LPARENT arg_expr_list RPARENT .)
    SEMICOLON       reduce using rule 9 (postfix_expr -> postfix_expr LPARENT arg_expr_list RPARENT .)
    RPARENT         reduce using rule 9 (postfix_expr -> postfix_expr LPARENT arg_expr_list RPARENT .)
    RBRACE          reduce using rule 9 (postfix_expr -> postfix_expr LPARENT arg_expr_list RPARENT .)
    COMMA           reduce using rule 9 (postfix_expr -> postfix_expr LPARENT arg_expr_list RPARENT .)


state 175

    (13) arg_expr_list -> arg_expr_list COMMA . expr
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr LT add_expr
    (33) rel_expr -> . rel_expr GT add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    LPARENT         shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    expr                           shift and go to state 182
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 176

    (11) postfix_expr -> postfix_expr LBRACKET expr RBRACKET .
    DEC             reduce using rule 11 (postfix_expr -> postfix_expr LBRACKET expr RBRACKET .)
    INC             reduce using rule 11 (postfix_expr -> postfix_expr LBRACKET expr RBRACKET .)
    DOT             reduce using rule 11 (postfix_expr -> postfix_expr LBRACKET expr RBRACKET .)
    LPARENT         reduce using rule 11 (postfix_expr -> postfix_expr LBRACKET expr RBRACKET .)
    LBRACKET        reduce using rule 11 (postfix_expr -> postfix_expr LBRACKET expr RBRACKET .)
    MOD             reduce using rule 11 (postfix_expr -> postfix_expr LBRACKET expr RBRACKET .)
    DIV             reduce using rule 11 (postfix_expr -> postfix_expr LBRACKET expr RBRACKET .)
    MUL             reduce using rule 11 (postfix_expr -> postfix_expr LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 11 (postfix_expr -> postfix_expr LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 11 (postfix_expr -> postfix_expr LBRACKET expr RBRACKET .)
    LE              reduce using rule 11 (postfix_expr -> postfix_expr LBRACKET expr RBRACKET .)
    GE              reduce using rule 11 (postfix_expr -> postfix_expr LBRACKET expr RBRACKET .)
    LT              reduce using rule 11 (postfix_expr -> postfix_expr LBRACKET expr RBRACKET .)
    GT              reduce using rule 11 (postfix_expr -> postfix_expr LBRACKET expr RBRACKET .)
    NE              reduce using rule 11 (postfix_expr -> postfix_expr LBRACKET expr RBRACKET .)
    EQ              reduce using rule 11 (postfix_expr -> postfix_expr LBRACKET expr RBRACKET .)
    AND             reduce using rule 11 (postfix_expr -> postfix_expr LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 11 (postfix_expr -> postfix_expr LBRACKET expr RBRACKET .)
    OR              reduce using rule 11 (postfix_expr -> postfix_expr LBRACKET expr RBRACKET .)
    ASSIGN          reduce using rule 11 (postfix_expr -> postfix_expr LBRACKET expr RBRACKET .)
    MODEQ           reduce using rule 11 (postfix_expr -> postfix_expr LBRACKET expr RBRACKET .)
    DIVEQ           reduce using rule 11 (postfix_expr -> postfix_expr LBRACKET expr RBRACKET .)
    MULEQ           reduce using rule 11 (postfix_expr -> postfix_expr LBRACKET expr RBRACKET .)
    MINUSEQ         reduce using rule 11 (postfix_expr -> postfix_expr LBRACKET expr RBRACKET .)
    PLUSEQ          reduce using rule 11 (postfix_expr -> postfix_expr LBRACKET expr RBRACKET .)
    SEMICOLON       reduce using rule 11 (postfix_expr -> postfix_expr LBRACKET expr RBRACKET .)
    RPARENT         reduce using rule 11 (postfix_expr -> postfix_expr LBRACKET expr RBRACKET .)
    RBRACE          reduce using rule 11 (postfix_expr -> postfix_expr LBRACKET expr RBRACKET .)
    COMMA           reduce using rule 11 (postfix_expr -> postfix_expr LBRACKET expr RBRACKET .)


state 177

    (67) initializer_list -> initializer_list COMMA initializer .
    RBRACE          reduce using rule 67 (initializer_list -> initializer_list COMMA initializer .)
    COMMA           reduce using rule 67 (initializer_list -> initializer_list COMMA initializer .)


state 178

    (87) loop_stmt -> FOR LPARENT expr_stmt expr_stmt . expr RPARENT stmt
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr LT add_expr
    (33) rel_expr -> . rel_expr GT add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    LPARENT         shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    expr                           shift and go to state 183
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 179

    (88) loop_stmt -> DO stmt WHILE LPARENT . expr RPARENT SEMICOLON
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr LT add_expr
    (33) rel_expr -> . rel_expr GT add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    LPARENT         shift and go to state 64
    IDENTIFIER      shift and go to state 52
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    expr                           shift and go to state 184
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 180

    (89) loop_stmt -> WHILE LPARENT expr RPARENT . stmt
    (69) stmt -> . jump_stmt
    (70) stmt -> . loop_stmt
    (71) stmt -> . if_stmt
    (72) stmt -> . expr_stmt
    (73) stmt -> . block_stmt
    (74) stmt -> . labeled_stmt
    (90) jump_stmt -> . RETURN expr SEMICOLON
    (91) jump_stmt -> . RETURN SEMICOLON
    (92) jump_stmt -> . BREAK SEMICOLON
    (93) jump_stmt -> . CONTINUE SEMICOLON
    (94) jump_stmt -> . GOTO IDENTIFIER SEMICOLON
    (87) loop_stmt -> . FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt
    (88) loop_stmt -> . DO stmt WHILE LPARENT expr RPARENT SEMICOLON
    (89) loop_stmt -> . WHILE LPARENT expr RPARENT stmt
    (85) if_stmt -> . IF LPARENT expr RPARENT stmt ELSE stmt
    (86) if_stmt -> . IF LPARENT expr RPARENT stmt
    (82) expr_stmt -> . decl
    (83) expr_stmt -> . expr SEMICOLON
    (84) expr_stmt -> . SEMICOLON
    (76) block_stmt -> . LBRACE stmt_list RBRACE
    (77) block_stmt -> . LBRACE RBRACE
    (75) labeled_stmt -> . IDENTIFIER COLON stmt
    (50) decl -> . type init_declarator SEMICOLON
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr LT add_expr
    (33) rel_expr -> . rel_expr GT add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    RETURN          shift and go to state 74
    BREAK           shift and go to state 77
    CONTINUE        shift and go to state 78
    GOTO            shift and go to state 79
    FOR             shift and go to state 81
    DO              shift and go to state 82
    WHILE           shift and go to state 83
    IF              shift and go to state 84
    SEMICOLON       shift and go to state 76
    LBRACE          shift and go to state 33
    IDENTIFIER      shift and go to state 80
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    LPARENT         shift and go to state 64
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    expr                           shift and go to state 75
    stmt                           shift and go to state 185
    jump_stmt                      shift and go to state 68
    loop_stmt                      shift and go to state 69
    if_stmt                        shift and go to state 70
    expr_stmt                      shift and go to state 71
    block_stmt                     shift and go to state 72
    labeled_stmt                   shift and go to state 73
    decl                           shift and go to state 85
    type                           shift and go to state 86
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 181

    (85) if_stmt -> IF LPARENT expr RPARENT . stmt ELSE stmt
    (86) if_stmt -> IF LPARENT expr RPARENT . stmt
    (69) stmt -> . jump_stmt
    (70) stmt -> . loop_stmt
    (71) stmt -> . if_stmt
    (72) stmt -> . expr_stmt
    (73) stmt -> . block_stmt
    (74) stmt -> . labeled_stmt
    (90) jump_stmt -> . RETURN expr SEMICOLON
    (91) jump_stmt -> . RETURN SEMICOLON
    (92) jump_stmt -> . BREAK SEMICOLON
    (93) jump_stmt -> . CONTINUE SEMICOLON
    (94) jump_stmt -> . GOTO IDENTIFIER SEMICOLON
    (87) loop_stmt -> . FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt
    (88) loop_stmt -> . DO stmt WHILE LPARENT expr RPARENT SEMICOLON
    (89) loop_stmt -> . WHILE LPARENT expr RPARENT stmt
    (85) if_stmt -> . IF LPARENT expr RPARENT stmt ELSE stmt
    (86) if_stmt -> . IF LPARENT expr RPARENT stmt
    (82) expr_stmt -> . decl
    (83) expr_stmt -> . expr SEMICOLON
    (84) expr_stmt -> . SEMICOLON
    (76) block_stmt -> . LBRACE stmt_list RBRACE
    (77) block_stmt -> . LBRACE RBRACE
    (75) labeled_stmt -> . IDENTIFIER COLON stmt
    (50) decl -> . type init_declarator SEMICOLON
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr LT add_expr
    (33) rel_expr -> . rel_expr GT add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    RETURN          shift and go to state 74
    BREAK           shift and go to state 77
    CONTINUE        shift and go to state 78
    GOTO            shift and go to state 79
    FOR             shift and go to state 81
    DO              shift and go to state 82
    WHILE           shift and go to state 83
    IF              shift and go to state 84
    SEMICOLON       shift and go to state 76
    LBRACE          shift and go to state 33
    IDENTIFIER      shift and go to state 80
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    LPARENT         shift and go to state 64
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    expr                           shift and go to state 75
    stmt                           shift and go to state 186
    jump_stmt                      shift and go to state 68
    loop_stmt                      shift and go to state 69
    if_stmt                        shift and go to state 70
    expr_stmt                      shift and go to state 71
    block_stmt                     shift and go to state 72
    labeled_stmt                   shift and go to state 73
    decl                           shift and go to state 85
    type                           shift and go to state 86
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 182

    (13) arg_expr_list -> arg_expr_list COMMA expr .
    RPARENT         reduce using rule 13 (arg_expr_list -> arg_expr_list COMMA expr .)
    COMMA           reduce using rule 13 (arg_expr_list -> arg_expr_list COMMA expr .)


state 183

    (87) loop_stmt -> FOR LPARENT expr_stmt expr_stmt expr . RPARENT stmt
    RPARENT         shift and go to state 187


state 184

    (88) loop_stmt -> DO stmt WHILE LPARENT expr . RPARENT SEMICOLON
    RPARENT         shift and go to state 188


state 185

    (89) loop_stmt -> WHILE LPARENT expr RPARENT stmt .
    RBRACE          reduce using rule 89 (loop_stmt -> WHILE LPARENT expr RPARENT stmt .)
    RETURN          reduce using rule 89 (loop_stmt -> WHILE LPARENT expr RPARENT stmt .)
    BREAK           reduce using rule 89 (loop_stmt -> WHILE LPARENT expr RPARENT stmt .)
    CONTINUE        reduce using rule 89 (loop_stmt -> WHILE LPARENT expr RPARENT stmt .)
    GOTO            reduce using rule 89 (loop_stmt -> WHILE LPARENT expr RPARENT stmt .)
    FOR             reduce using rule 89 (loop_stmt -> WHILE LPARENT expr RPARENT stmt .)
    DO              reduce using rule 89 (loop_stmt -> WHILE LPARENT expr RPARENT stmt .)
    WHILE           reduce using rule 89 (loop_stmt -> WHILE LPARENT expr RPARENT stmt .)
    IF              reduce using rule 89 (loop_stmt -> WHILE LPARENT expr RPARENT stmt .)
    SEMICOLON       reduce using rule 89 (loop_stmt -> WHILE LPARENT expr RPARENT stmt .)
    LBRACE          reduce using rule 89 (loop_stmt -> WHILE LPARENT expr RPARENT stmt .)
    IDENTIFIER      reduce using rule 89 (loop_stmt -> WHILE LPARENT expr RPARENT stmt .)
    VOID            reduce using rule 89 (loop_stmt -> WHILE LPARENT expr RPARENT stmt .)
    STRING_T        reduce using rule 89 (loop_stmt -> WHILE LPARENT expr RPARENT stmt .)
    DOUBLE          reduce using rule 89 (loop_stmt -> WHILE LPARENT expr RPARENT stmt .)
    INT             reduce using rule 89 (loop_stmt -> WHILE LPARENT expr RPARENT stmt .)
    NOT             reduce using rule 89 (loop_stmt -> WHILE LPARENT expr RPARENT stmt .)
    MINUS           reduce using rule 89 (loop_stmt -> WHILE LPARENT expr RPARENT stmt .)
    PLUS            reduce using rule 89 (loop_stmt -> WHILE LPARENT expr RPARENT stmt .)
    DEC             reduce using rule 89 (loop_stmt -> WHILE LPARENT expr RPARENT stmt .)
    INC             reduce using rule 89 (loop_stmt -> WHILE LPARENT expr RPARENT stmt .)
    LPARENT         reduce using rule 89 (loop_stmt -> WHILE LPARENT expr RPARENT stmt .)
    FLOAT           reduce using rule 89 (loop_stmt -> WHILE LPARENT expr RPARENT stmt .)
    INTEGER         reduce using rule 89 (loop_stmt -> WHILE LPARENT expr RPARENT stmt .)
    ELSE            reduce using rule 89 (loop_stmt -> WHILE LPARENT expr RPARENT stmt .)


state 186

    (85) if_stmt -> IF LPARENT expr RPARENT stmt . ELSE stmt
    (86) if_stmt -> IF LPARENT expr RPARENT stmt .
  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 189
    RBRACE          reduce using rule 86 (if_stmt -> IF LPARENT expr RPARENT stmt .)
    RETURN          reduce using rule 86 (if_stmt -> IF LPARENT expr RPARENT stmt .)
    BREAK           reduce using rule 86 (if_stmt -> IF LPARENT expr RPARENT stmt .)
    CONTINUE        reduce using rule 86 (if_stmt -> IF LPARENT expr RPARENT stmt .)
    GOTO            reduce using rule 86 (if_stmt -> IF LPARENT expr RPARENT stmt .)
    FOR             reduce using rule 86 (if_stmt -> IF LPARENT expr RPARENT stmt .)
    DO              reduce using rule 86 (if_stmt -> IF LPARENT expr RPARENT stmt .)
    WHILE           reduce using rule 86 (if_stmt -> IF LPARENT expr RPARENT stmt .)
    IF              reduce using rule 86 (if_stmt -> IF LPARENT expr RPARENT stmt .)
    SEMICOLON       reduce using rule 86 (if_stmt -> IF LPARENT expr RPARENT stmt .)
    LBRACE          reduce using rule 86 (if_stmt -> IF LPARENT expr RPARENT stmt .)
    IDENTIFIER      reduce using rule 86 (if_stmt -> IF LPARENT expr RPARENT stmt .)
    VOID            reduce using rule 86 (if_stmt -> IF LPARENT expr RPARENT stmt .)
    STRING_T        reduce using rule 86 (if_stmt -> IF LPARENT expr RPARENT stmt .)
    DOUBLE          reduce using rule 86 (if_stmt -> IF LPARENT expr RPARENT stmt .)
    INT             reduce using rule 86 (if_stmt -> IF LPARENT expr RPARENT stmt .)
    NOT             reduce using rule 86 (if_stmt -> IF LPARENT expr RPARENT stmt .)
    MINUS           reduce using rule 86 (if_stmt -> IF LPARENT expr RPARENT stmt .)
    PLUS            reduce using rule 86 (if_stmt -> IF LPARENT expr RPARENT stmt .)
    DEC             reduce using rule 86 (if_stmt -> IF LPARENT expr RPARENT stmt .)
    INC             reduce using rule 86 (if_stmt -> IF LPARENT expr RPARENT stmt .)
    LPARENT         reduce using rule 86 (if_stmt -> IF LPARENT expr RPARENT stmt .)
    FLOAT           reduce using rule 86 (if_stmt -> IF LPARENT expr RPARENT stmt .)
    INTEGER         reduce using rule 86 (if_stmt -> IF LPARENT expr RPARENT stmt .)


state 187

    (87) loop_stmt -> FOR LPARENT expr_stmt expr_stmt expr RPARENT . stmt
    (69) stmt -> . jump_stmt
    (70) stmt -> . loop_stmt
    (71) stmt -> . if_stmt
    (72) stmt -> . expr_stmt
    (73) stmt -> . block_stmt
    (74) stmt -> . labeled_stmt
    (90) jump_stmt -> . RETURN expr SEMICOLON
    (91) jump_stmt -> . RETURN SEMICOLON
    (92) jump_stmt -> . BREAK SEMICOLON
    (93) jump_stmt -> . CONTINUE SEMICOLON
    (94) jump_stmt -> . GOTO IDENTIFIER SEMICOLON
    (87) loop_stmt -> . FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt
    (88) loop_stmt -> . DO stmt WHILE LPARENT expr RPARENT SEMICOLON
    (89) loop_stmt -> . WHILE LPARENT expr RPARENT stmt
    (85) if_stmt -> . IF LPARENT expr RPARENT stmt ELSE stmt
    (86) if_stmt -> . IF LPARENT expr RPARENT stmt
    (82) expr_stmt -> . decl
    (83) expr_stmt -> . expr SEMICOLON
    (84) expr_stmt -> . SEMICOLON
    (76) block_stmt -> . LBRACE stmt_list RBRACE
    (77) block_stmt -> . LBRACE RBRACE
    (75) labeled_stmt -> . IDENTIFIER COLON stmt
    (50) decl -> . type init_declarator SEMICOLON
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr LT add_expr
    (33) rel_expr -> . rel_expr GT add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    RETURN          shift and go to state 74
    BREAK           shift and go to state 77
    CONTINUE        shift and go to state 78
    GOTO            shift and go to state 79
    FOR             shift and go to state 81
    DO              shift and go to state 82
    WHILE           shift and go to state 83
    IF              shift and go to state 84
    SEMICOLON       shift and go to state 76
    LBRACE          shift and go to state 33
    IDENTIFIER      shift and go to state 80
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    LPARENT         shift and go to state 64
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    expr_stmt                      shift and go to state 71
    expr                           shift and go to state 75
    stmt                           shift and go to state 190
    jump_stmt                      shift and go to state 68
    loop_stmt                      shift and go to state 69
    if_stmt                        shift and go to state 70
    block_stmt                     shift and go to state 72
    labeled_stmt                   shift and go to state 73
    decl                           shift and go to state 85
    type                           shift and go to state 86
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 188

    (88) loop_stmt -> DO stmt WHILE LPARENT expr RPARENT . SEMICOLON
    SEMICOLON       shift and go to state 191


state 189

    (85) if_stmt -> IF LPARENT expr RPARENT stmt ELSE . stmt
    (69) stmt -> . jump_stmt
    (70) stmt -> . loop_stmt
    (71) stmt -> . if_stmt
    (72) stmt -> . expr_stmt
    (73) stmt -> . block_stmt
    (74) stmt -> . labeled_stmt
    (90) jump_stmt -> . RETURN expr SEMICOLON
    (91) jump_stmt -> . RETURN SEMICOLON
    (92) jump_stmt -> . BREAK SEMICOLON
    (93) jump_stmt -> . CONTINUE SEMICOLON
    (94) jump_stmt -> . GOTO IDENTIFIER SEMICOLON
    (87) loop_stmt -> . FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt
    (88) loop_stmt -> . DO stmt WHILE LPARENT expr RPARENT SEMICOLON
    (89) loop_stmt -> . WHILE LPARENT expr RPARENT stmt
    (85) if_stmt -> . IF LPARENT expr RPARENT stmt ELSE stmt
    (86) if_stmt -> . IF LPARENT expr RPARENT stmt
    (82) expr_stmt -> . decl
    (83) expr_stmt -> . expr SEMICOLON
    (84) expr_stmt -> . SEMICOLON
    (76) block_stmt -> . LBRACE stmt_list RBRACE
    (77) block_stmt -> . LBRACE RBRACE
    (75) labeled_stmt -> . IDENTIFIER COLON stmt
    (50) decl -> . type init_declarator SEMICOLON
    (42) expr -> . unary_expr assignment_op expr
    (43) expr -> . cond_expr
    (53) type -> . VOID
    (54) type -> . STRING_T
    (55) type -> . DOUBLE
    (56) type -> . INT
    (15) unary_expr -> . NOT cast_expr
    (16) unary_expr -> . MINUS cast_expr
    (17) unary_expr -> . PLUS cast_expr
    (18) unary_expr -> . DEC unary_expr
    (19) unary_expr -> . INC unary_expr
    (20) unary_expr -> . postfix_expr
    (40) cond_expr -> . cond_expr OR and_expr
    (41) cond_expr -> . and_expr
    (6) postfix_expr -> . postfix_expr DEC
    (7) postfix_expr -> . postfix_expr INC
    (8) postfix_expr -> . postfix_expr DOT IDENTIFIER
    (9) postfix_expr -> . postfix_expr LPARENT arg_expr_list RPARENT
    (10) postfix_expr -> . postfix_expr LPARENT RPARENT
    (11) postfix_expr -> . postfix_expr LBRACKET expr RBRACKET
    (12) postfix_expr -> . primary_expr
    (38) and_expr -> . and_expr AND eq_expr
    (39) and_expr -> . eq_expr
    (3) primary_expr -> . LPARENT expr RPARENT
    (4) primary_expr -> . literal
    (5) primary_expr -> . IDENTIFIER
    (35) eq_expr -> . eq_expr NE rel_expr
    (36) eq_expr -> . eq_expr EQ rel_expr
    (37) eq_expr -> . rel_expr
    (1) literal -> . FLOAT
    (2) literal -> . INTEGER
    (30) rel_expr -> . rel_expr LE add_expr
    (31) rel_expr -> . rel_expr GE add_expr
    (32) rel_expr -> . rel_expr LT add_expr
    (33) rel_expr -> . rel_expr GT add_expr
    (34) rel_expr -> . add_expr
    (27) add_expr -> . add_expr MINUS mult_expr
    (28) add_expr -> . add_expr PLUS mult_expr
    (29) add_expr -> . mult_expr
    (23) mult_expr -> . mult_expr MOD cast_expr
    (24) mult_expr -> . mult_expr DIV cast_expr
    (25) mult_expr -> . mult_expr MUL cast_expr
    (26) mult_expr -> . cast_expr
    (21) cast_expr -> . unary_expr
    (22) cast_expr -> . LPARENT type RPARENT cast_expr
    RETURN          shift and go to state 74
    BREAK           shift and go to state 77
    CONTINUE        shift and go to state 78
    GOTO            shift and go to state 79
    FOR             shift and go to state 81
    DO              shift and go to state 82
    WHILE           shift and go to state 83
    IF              shift and go to state 84
    SEMICOLON       shift and go to state 76
    LBRACE          shift and go to state 33
    IDENTIFIER      shift and go to state 80
    VOID            shift and go to state 12
    STRING_T        shift and go to state 13
    DOUBLE          shift and go to state 14
    INT             shift and go to state 15
    NOT             shift and go to state 48
    MINUS           shift and go to state 42
    PLUS            shift and go to state 44
    DEC             shift and go to state 49
    INC             shift and go to state 50
    LPARENT         shift and go to state 64
    FLOAT           shift and go to state 27
    INTEGER         shift and go to state 28

    expr                           shift and go to state 75
    stmt                           shift and go to state 192
    jump_stmt                      shift and go to state 68
    loop_stmt                      shift and go to state 69
    if_stmt                        shift and go to state 70
    expr_stmt                      shift and go to state 71
    block_stmt                     shift and go to state 72
    labeled_stmt                   shift and go to state 73
    decl                           shift and go to state 85
    type                           shift and go to state 86
    unary_expr                     shift and go to state 62
    cond_expr                      shift and go to state 63
    cast_expr                      shift and go to state 45
    postfix_expr                   shift and go to state 51
    and_expr                       shift and go to state 38
    primary_expr                   shift and go to state 53
    eq_expr                        shift and go to state 39
    literal                        shift and go to state 54
    rel_expr                       shift and go to state 40
    add_expr                       shift and go to state 41
    mult_expr                      shift and go to state 43

state 190

    (87) loop_stmt -> FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt .
    RBRACE          reduce using rule 87 (loop_stmt -> FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt .)
    RETURN          reduce using rule 87 (loop_stmt -> FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt .)
    BREAK           reduce using rule 87 (loop_stmt -> FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt .)
    CONTINUE        reduce using rule 87 (loop_stmt -> FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt .)
    GOTO            reduce using rule 87 (loop_stmt -> FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt .)
    FOR             reduce using rule 87 (loop_stmt -> FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt .)
    DO              reduce using rule 87 (loop_stmt -> FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt .)
    WHILE           reduce using rule 87 (loop_stmt -> FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt .)
    IF              reduce using rule 87 (loop_stmt -> FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt .)
    SEMICOLON       reduce using rule 87 (loop_stmt -> FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt .)
    LBRACE          reduce using rule 87 (loop_stmt -> FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt .)
    IDENTIFIER      reduce using rule 87 (loop_stmt -> FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt .)
    VOID            reduce using rule 87 (loop_stmt -> FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt .)
    STRING_T        reduce using rule 87 (loop_stmt -> FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt .)
    DOUBLE          reduce using rule 87 (loop_stmt -> FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt .)
    INT             reduce using rule 87 (loop_stmt -> FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt .)
    NOT             reduce using rule 87 (loop_stmt -> FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt .)
    MINUS           reduce using rule 87 (loop_stmt -> FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt .)
    PLUS            reduce using rule 87 (loop_stmt -> FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt .)
    DEC             reduce using rule 87 (loop_stmt -> FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt .)
    INC             reduce using rule 87 (loop_stmt -> FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt .)
    LPARENT         reduce using rule 87 (loop_stmt -> FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt .)
    FLOAT           reduce using rule 87 (loop_stmt -> FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt .)
    INTEGER         reduce using rule 87 (loop_stmt -> FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt .)
    ELSE            reduce using rule 87 (loop_stmt -> FOR LPARENT expr_stmt expr_stmt expr RPARENT stmt .)


state 191

    (88) loop_stmt -> DO stmt WHILE LPARENT expr RPARENT SEMICOLON .
    RBRACE          reduce using rule 88 (loop_stmt -> DO stmt WHILE LPARENT expr RPARENT SEMICOLON .)
    RETURN          reduce using rule 88 (loop_stmt -> DO stmt WHILE LPARENT expr RPARENT SEMICOLON .)
    BREAK           reduce using rule 88 (loop_stmt -> DO stmt WHILE LPARENT expr RPARENT SEMICOLON .)
    CONTINUE        reduce using rule 88 (loop_stmt -> DO stmt WHILE LPARENT expr RPARENT SEMICOLON .)
    GOTO            reduce using rule 88 (loop_stmt -> DO stmt WHILE LPARENT expr RPARENT SEMICOLON .)
    FOR             reduce using rule 88 (loop_stmt -> DO stmt WHILE LPARENT expr RPARENT SEMICOLON .)
    DO              reduce using rule 88 (loop_stmt -> DO stmt WHILE LPARENT expr RPARENT SEMICOLON .)
    WHILE           reduce using rule 88 (loop_stmt -> DO stmt WHILE LPARENT expr RPARENT SEMICOLON .)
    IF              reduce using rule 88 (loop_stmt -> DO stmt WHILE LPARENT expr RPARENT SEMICOLON .)
    SEMICOLON       reduce using rule 88 (loop_stmt -> DO stmt WHILE LPARENT expr RPARENT SEMICOLON .)
    LBRACE          reduce using rule 88 (loop_stmt -> DO stmt WHILE LPARENT expr RPARENT SEMICOLON .)
    IDENTIFIER      reduce using rule 88 (loop_stmt -> DO stmt WHILE LPARENT expr RPARENT SEMICOLON .)
    VOID            reduce using rule 88 (loop_stmt -> DO stmt WHILE LPARENT expr RPARENT SEMICOLON .)
    STRING_T        reduce using rule 88 (loop_stmt -> DO stmt WHILE LPARENT expr RPARENT SEMICOLON .)
    DOUBLE          reduce using rule 88 (loop_stmt -> DO stmt WHILE LPARENT expr RPARENT SEMICOLON .)
    INT             reduce using rule 88 (loop_stmt -> DO stmt WHILE LPARENT expr RPARENT SEMICOLON .)
    NOT             reduce using rule 88 (loop_stmt -> DO stmt WHILE LPARENT expr RPARENT SEMICOLON .)
    MINUS           reduce using rule 88 (loop_stmt -> DO stmt WHILE LPARENT expr RPARENT SEMICOLON .)
    PLUS            reduce using rule 88 (loop_stmt -> DO stmt WHILE LPARENT expr RPARENT SEMICOLON .)
    DEC             reduce using rule 88 (loop_stmt -> DO stmt WHILE LPARENT expr RPARENT SEMICOLON .)
    INC             reduce using rule 88 (loop_stmt -> DO stmt WHILE LPARENT expr RPARENT SEMICOLON .)
    LPARENT         reduce using rule 88 (loop_stmt -> DO stmt WHILE LPARENT expr RPARENT SEMICOLON .)
    FLOAT           reduce using rule 88 (loop_stmt -> DO stmt WHILE LPARENT expr RPARENT SEMICOLON .)
    INTEGER         reduce using rule 88 (loop_stmt -> DO stmt WHILE LPARENT expr RPARENT SEMICOLON .)
    ELSE            reduce using rule 88 (loop_stmt -> DO stmt WHILE LPARENT expr RPARENT SEMICOLON .)


state 192

    (85) if_stmt -> IF LPARENT expr RPARENT stmt ELSE stmt .
    RBRACE          reduce using rule 85 (if_stmt -> IF LPARENT expr RPARENT stmt ELSE stmt .)
    RETURN          reduce using rule 85 (if_stmt -> IF LPARENT expr RPARENT stmt ELSE stmt .)
    BREAK           reduce using rule 85 (if_stmt -> IF LPARENT expr RPARENT stmt ELSE stmt .)
    CONTINUE        reduce using rule 85 (if_stmt -> IF LPARENT expr RPARENT stmt ELSE stmt .)
    GOTO            reduce using rule 85 (if_stmt -> IF LPARENT expr RPARENT stmt ELSE stmt .)
    FOR             reduce using rule 85 (if_stmt -> IF LPARENT expr RPARENT stmt ELSE stmt .)
    DO              reduce using rule 85 (if_stmt -> IF LPARENT expr RPARENT stmt ELSE stmt .)
    WHILE           reduce using rule 85 (if_stmt -> IF LPARENT expr RPARENT stmt ELSE stmt .)
    IF              reduce using rule 85 (if_stmt -> IF LPARENT expr RPARENT stmt ELSE stmt .)
    SEMICOLON       reduce using rule 85 (if_stmt -> IF LPARENT expr RPARENT stmt ELSE stmt .)
    LBRACE          reduce using rule 85 (if_stmt -> IF LPARENT expr RPARENT stmt ELSE stmt .)
    IDENTIFIER      reduce using rule 85 (if_stmt -> IF LPARENT expr RPARENT stmt ELSE stmt .)
    VOID            reduce using rule 85 (if_stmt -> IF LPARENT expr RPARENT stmt ELSE stmt .)
    STRING_T        reduce using rule 85 (if_stmt -> IF LPARENT expr RPARENT stmt ELSE stmt .)
    DOUBLE          reduce using rule 85 (if_stmt -> IF LPARENT expr RPARENT stmt ELSE stmt .)
    INT             reduce using rule 85 (if_stmt -> IF LPARENT expr RPARENT stmt ELSE stmt .)
    NOT             reduce using rule 85 (if_stmt -> IF LPARENT expr RPARENT stmt ELSE stmt .)
    MINUS           reduce using rule 85 (if_stmt -> IF LPARENT expr RPARENT stmt ELSE stmt .)
    PLUS            reduce using rule 85 (if_stmt -> IF LPARENT expr RPARENT stmt ELSE stmt .)
    DEC             reduce using rule 85 (if_stmt -> IF LPARENT expr RPARENT stmt ELSE stmt .)
    INC             reduce using rule 85 (if_stmt -> IF LPARENT expr RPARENT stmt ELSE stmt .)
    LPARENT         reduce using rule 85 (if_stmt -> IF LPARENT expr RPARENT stmt ELSE stmt .)
    FLOAT           reduce using rule 85 (if_stmt -> IF LPARENT expr RPARENT stmt ELSE stmt .)
    INTEGER         reduce using rule 85 (if_stmt -> IF LPARENT expr RPARENT stmt ELSE stmt .)
    ELSE            reduce using rule 85 (if_stmt -> IF LPARENT expr RPARENT stmt ELSE stmt .)


Conflicts:

shift/reduce conflict for ELSE in state 186 resolved as shift